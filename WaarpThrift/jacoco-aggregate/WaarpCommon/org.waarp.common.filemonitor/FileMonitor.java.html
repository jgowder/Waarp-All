<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileMonitor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Thrift</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.filemonitor</a> &gt; <span class="el_source">FileMonitor.java</span></div><h1>FileMonitor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.filemonitor;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import io.netty.util.HashedWheelTimer;
import io.netty.util.Timeout;
import io.netty.util.Timer;
import io.netty.util.TimerTask;
import org.waarp.common.database.DbConstant;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.digest.FilesystemBasedDigest.DigestAlgo;
import org.waarp.common.file.AbstractDir;
import org.waarp.common.future.WaarpFuture;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpThreadFactory;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * This package would like to propose a JSE 6 compatible way to scan a directory
 * for new, deleted and changed
 * files, in order to allow some functions like pooling a directory before
 * actions.
 */
public class FileMonitor {
  /**
   * Internal Logger
   */
  protected static volatile WaarpLogger logger;
<span class="fc" id="L76">  protected static final DigestAlgo defaultDigestAlgo = DigestAlgo.MD5;</span>
  protected static final long MINIMAL_DELAY = 100;
  protected static final long DEFAULT_DELAY = 1000;
  protected static final long DEFAULT_CHECK_DELAY = 300000; // 5 minutes

  protected WaarpFuture future;
  protected WaarpFuture internalfuture;
  protected boolean stopped;
  protected final String name;
  protected final File statusFile;
  protected final File stopFile;
<span class="fc" id="L87">  protected final List&lt;File&gt; directories = new ArrayList&lt;File&gt;();</span>
  protected final DigestAlgo digest;
<span class="fc" id="L89">  protected long elapseTime = DEFAULT_DELAY; // default to 1s</span>
<span class="fc" id="L90">  protected long elapseWaarpTime = -1; // default set to run after each run</span>
<span class="fc" id="L91">  protected long checkDelay = DEFAULT_CHECK_DELAY; // default set to 5 minutes</span>
  protected Timer timer;
  protected Timer timerWaarp;
  // used only if elapseWaarpTime &gt; defaultDelay (1s)
  protected final boolean scanSubDir;

<span class="fc" id="L97">  protected boolean ignoreAlreadyUsed = false;</span>

  protected boolean initialized;
  protected File checkFile;

<span class="fc" id="L102">  protected final ConcurrentHashMap&lt;String, FileItem&gt; fileItems =</span>
      new ConcurrentHashMap&lt;String, FileItem&gt;();
<span class="fc" id="L104">  protected final ConcurrentHashMap&lt;String, FileItem&gt; lastFileItems =</span>
      new ConcurrentHashMap&lt;String, FileItem&gt;();

<span class="fc" id="L107">  protected FileFilter filter = new FileFilter() {</span>
    @Override
    public boolean accept(File pathname) {
<span class="fc" id="L110">      return pathname.isFile();</span>
    }
  };
  protected final FileMonitorCommandRunnableFuture commandValidFile;
  protected FileMonitorCommandFactory commandValidFileFactory;
  protected ExecutorService executor;
  protected int fixedThreadPool;
  protected final FileMonitorCommandRunnableFuture commandRemovedFile;
  protected FileMonitorCommandRunnableFuture commandCheckIteration;

<span class="fc" id="L120">  protected final ConcurrentLinkedQueue&lt;FileItem&gt; toUse =</span>
      new ConcurrentLinkedQueue&lt;FileItem&gt;();
<span class="fc" id="L122">  protected final ConcurrentLinkedQueue&lt;Future&lt;?&gt;&gt; results =</span>
      new ConcurrentLinkedQueue&lt;Future&lt;?&gt;&gt;();

<span class="fc" id="L125">  protected final AtomicLong globalok = new AtomicLong(0);</span>
<span class="fc" id="L126">  protected final AtomicLong globalerror = new AtomicLong(0);</span>
<span class="fc" id="L127">  protected final AtomicLong todayok = new AtomicLong(0);</span>
<span class="fc" id="L128">  protected final AtomicLong todayerror = new AtomicLong(0);</span>
  protected Date nextDay;

  /**
   * @param name name of this daemon
   * @param statusFile the file where the current status is saved
   *     (current
   *     files)
   * @param stopFile the file when created (.exists()) will stop the
   *     daemon
   * @param directory the directory where files will be monitored
   * @param digest the digest to use (default if null is MD5)
   * @param elapseTime the time to wait in ms for between 2 checks
   *     (default
   *     is 1000ms, minimum is
   *     100ms)
   * @param filter the filter to be applied on selected files (default
   *     is
   *     isFile())
   * @param commandValidFile the commandValidFile to run (may be null,
   *     which
   *     means poll() commandValidFile
   *     has to be used)
   * @param commandRemovedFile the commandRemovedFile to run (may be
   *     null)
   * @param commandCheckIteration the commandCheckIteration to run
   *     (may be
   *     null), runs after each check
   *     (elapseTime)
   */
  public FileMonitor(String name, File statusFile, File stopFile,
                     File directory, DigestAlgo digest, long elapseTime,
                     FileFilter filter, boolean scanSubdir,
                     FileMonitorCommandRunnableFuture commandValidFile,
                     FileMonitorCommandRunnableFuture commandRemovedFile,
<span class="fc" id="L163">                     FileMonitorCommandRunnableFuture commandCheckIteration) {</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (logger == null) {</span>
<span class="fc" id="L165">      logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
    }
<span class="fc" id="L167">    this.name = name;</span>
<span class="fc" id="L168">    this.statusFile = statusFile;</span>
<span class="fc" id="L169">    this.stopFile = stopFile;</span>
<span class="fc" id="L170">    directories.add(directory);</span>
<span class="fc" id="L171">    scanSubDir = scanSubdir;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (digest == null) {</span>
<span class="fc" id="L173">      this.digest = defaultDigestAlgo;</span>
    } else {
<span class="nc" id="L175">      this.digest = digest;</span>
    }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (elapseTime &gt;= MINIMAL_DELAY) {</span>
<span class="fc" id="L178">      this.elapseTime = (elapseTime / 10) * 10;</span>
    }
<span class="fc bfc" id="L180" title="All 2 branches covered.">    if (filter != null) {</span>
<span class="fc" id="L181">      this.filter = filter;</span>
    }
<span class="fc" id="L183">    this.commandValidFile = commandValidFile;</span>
<span class="fc" id="L184">    this.commandRemovedFile = commandRemovedFile;</span>
<span class="fc" id="L185">    this.commandCheckIteration = commandCheckIteration;</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">    if (statusFile != null) {</span>
<span class="fc" id="L187">      checkFile = new File(statusFile.getAbsolutePath() + &quot;.chk&quot;);</span>
    }
<span class="fc" id="L189">    reloadStatus();</span>
<span class="fc" id="L190">    setNextDay();</span>
<span class="fc" id="L191">  }</span>

  protected void setNextDay() {
<span class="fc" id="L194">    final Calendar c = new GregorianCalendar();</span>
<span class="fc" id="L195">    c.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L196">    c.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L197">    c.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L198">    c.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L199">    c.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="fc" id="L200">    nextDay = c.getTime();</span>
<span class="fc" id="L201">  }</span>

  /**
   * @param commandCheckIteration the commandCheckIteration to run
   *     (may be
   *     null), runs after each check
   *     (elapseTime)
   */
  public void setCommandCheckIteration(
      FileMonitorCommandRunnableFuture commandCheckIteration) {
<span class="nc" id="L211">    this.commandCheckIteration = commandCheckIteration;</span>
<span class="nc" id="L212">  }</span>

  /**
   * @param factory the factory to used instead of simple instance
   *     (enables
   *     parallelism)
   * @param fixedPool if &gt; 0, set the number of parallel threads
   *     allowed
   */
  public void setCommandValidFileFactory(FileMonitorCommandFactory factory,
                                         int fixedPool) {
<span class="nc" id="L223">    commandValidFileFactory = factory;</span>
<span class="nc" id="L224">    fixedThreadPool = fixedPool;</span>
<span class="nc" id="L225">  }</span>

  /**
   * @return the elapseWaarpTime
   */
  public long getElapseWaarpTime() {
<span class="nc" id="L231">    return elapseWaarpTime;</span>
  }

  /**
   * if set greater than 1000 ms, will be parallel, else will be sequential
   * after each check and ignoring this
   * timer
   *
   * @param elapseWaarpTime the elapseWaarpTime to set
   */
  public void setElapseWaarpTime(long elapseWaarpTime) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">    if (elapseWaarpTime &gt;= DEFAULT_DELAY) {</span>
<span class="nc" id="L243">      this.elapseWaarpTime = (elapseWaarpTime / 10) * 10;</span>
    }
<span class="nc" id="L245">  }</span>

  /**
   * @return True if Already used files will be ignored
   */
  public boolean isIgnoreAlreadyUsed() {
<span class="nc" id="L251">    return ignoreAlreadyUsed;</span>
  }

  /**
   * @param ignoreAlreadyUsed if True, already used files will be ignored.
   *     Else if False, if an already used file is modified, then it will be reused.
   */
  public void setIgnoreAlreadyUsed(final boolean ignoreAlreadyUsed) {
<span class="fc" id="L259">    this.ignoreAlreadyUsed = ignoreAlreadyUsed;</span>
<span class="fc" id="L260">  }</span>

  /**
   * @param checkDelay the delay before checking if action was
   *     correctly taken
   */
  public void setCheckDelay(long checkDelay) {
<span class="fc" id="L267">    this.checkDelay = checkDelay;</span>
<span class="fc" id="L268">  }</span>

  /**
   * Add a directory to scan
   *
   * @param directory
   */
  public void addDirectory(File directory) {
<span class="fc" id="L276">    synchronized (directories) {</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">      if (!directories.contains(directory)) {</span>
<span class="fc" id="L278">        directories.add(directory);</span>
      }
<span class="fc" id="L280">    }</span>
<span class="fc" id="L281">  }</span>

  /**
   * Add a directory to scan
   *
   * @param directory
   */
  public void removeDirectory(File directory) {
<span class="fc" id="L289">    synchronized (directories) {</span>
<span class="fc" id="L290">      directories.remove(directory);</span>
<span class="fc" id="L291">    }</span>
<span class="fc" id="L292">  }</span>

  protected void setThreadName() {
<span class="fc" id="L295">    Thread.currentThread().setName(&quot;FileMonitor_&quot; + name);</span>
<span class="fc" id="L296">  }</span>

  private boolean testChkFile() {
<span class="nc bnc" id="L299" title="All 2 branches missed.">    if (checkFile.exists()) {</span>
<span class="nc" id="L300">      deleteChkFile();</span>
<span class="nc" id="L301">      final long time = elapseTime * 10;</span>
<span class="nc" id="L302">      logger.warn(</span>
          &quot;Waiting to check if another Monitor is running with the same configuration: &quot; +
          time / 1000 + 's');
      try {
<span class="nc" id="L306">        Thread.sleep(time);</span>
<span class="nc" id="L307">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L308">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L309">      }</span>
<span class="nc" id="L310">      return checkFile.exists();</span>
    }
<span class="nc" id="L312">    return false;</span>
  }

  private void createChkFile() {
    try {
<span class="fc" id="L317">      checkFile.createNewFile();</span>
<span class="nc" id="L318">    } catch (final IOException ignored) {</span>
<span class="nc" id="L319">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="fc" id="L320">    }</span>
<span class="fc" id="L321">  }</span>

  private void deleteChkFile() {
<span class="fc" id="L324">    checkFile.delete();</span>
<span class="fc" id="L325">  }</span>

  protected void reloadStatus() {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">    if (statusFile == null) {</span>
<span class="nc" id="L329">      return;</span>
    }
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    if (!statusFile.exists()) {</span>
<span class="fc" id="L332">      initialized = true;</span>
<span class="fc" id="L333">      return;</span>
    }
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (testChkFile()) {</span>
      // error ! one other monitor is running using the same status file
<span class="nc" id="L337">      logger.warn(</span>
          &quot;Error: One other monitor is probably running using the same status file: &quot; +
          statusFile);
<span class="nc" id="L340">      return;</span>
    }
    try {
<span class="nc" id="L343">      final HashMap&lt;String, FileItem&gt; newHashMap = JsonHandler.mapper</span>
<span class="nc" id="L344">          .readValue(statusFile,</span>
<span class="nc" id="L345">                     new TypeReference&lt;HashMap&lt;String, FileItem&gt;&gt;() {</span>
                     });
<span class="nc" id="L347">      fileItems.putAll(newHashMap);</span>
<span class="nc" id="L348">      initialized = true;</span>
<span class="nc" id="L349">    } catch (final JsonParseException ignored) {</span>
<span class="nc" id="L350">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L351">    } catch (final JsonMappingException ignored) {</span>
<span class="nc" id="L352">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L353">    } catch (final IOException ignored) {</span>
<span class="nc" id="L354">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L355">    }</span>
<span class="nc" id="L356">  }</span>

  /**
   * @return True if the FileMonitor is correctly initialized
   */
  public boolean initialized() {
<span class="nc" id="L362">    return initialized;</span>
  }

  protected void saveStatus() {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">    if (statusFile == null) {</span>
<span class="nc" id="L367">      return;</span>
    }
    try {
<span class="fc" id="L370">      JsonHandler.mapper.writeValue(statusFile, fileItems);</span>
<span class="fc" id="L371">      createChkFile();</span>
<span class="nc" id="L372">    } catch (final JsonGenerationException ignored) {</span>
<span class="nc" id="L373">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L374">    } catch (final JsonMappingException ignored) {</span>
<span class="nc" id="L375">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L376">    } catch (final IOException ignored) {</span>
<span class="nc" id="L377">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="pc" id="L378">    }</span>
<span class="fc" id="L379">  }</span>

  /**
   * @return the number of fileItems in the current history (active, in error
   *     or
   *     past)
   */
  public long getCurrentHistoryNb() {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">    if (fileItems != null) {</span>
<span class="fc" id="L388">      return fileItems.size();</span>
    }
<span class="nc" id="L390">    return -1;</span>
  }

  /**
   * Reset such that next status will be full (not partial)
   */
  public void setNextAsFullStatus() {
<span class="fc" id="L397">    lastFileItems.clear();</span>
<span class="fc" id="L398">  }</span>

  /**
   * @return the status (updated only) in JSON format
   */
  public String getStatus() {
<span class="fc" id="L404">    Set&lt;String&gt; removedFileItems = null;</span>
<span class="fc" id="L405">    final ConcurrentHashMap&lt;String, FileItem&gt; newFileItems =</span>
        new ConcurrentHashMap&lt;String, FileItem&gt;();
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    if (!lastFileItems.isEmpty()) {</span>
<span class="nc" id="L408">      removedFileItems = ((Map&lt;String, FileItem&gt;) lastFileItems).keySet();</span>
<span class="nc" id="L409">      removedFileItems.removeAll(((Map&lt;String, FileItem&gt;) fileItems).keySet());</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">      for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (!key.getValue().isStrictlySame(lastFileItems.get(key.getKey()))) {</span>
<span class="nc" id="L412">          newFileItems.put(key.getKey(), key.getValue());</span>
        }
<span class="nc" id="L414">      }</span>
    } else {
<span class="fc bfc" id="L416" title="All 2 branches covered.">      for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="fc" id="L417">        newFileItems.put(key.getKey(), key.getValue());</span>
<span class="fc" id="L418">      }</span>
    }
<span class="fc" id="L420">    final FileMonitorInformation fileMonitorInformation =</span>
        new FileMonitorInformation(name, newFileItems, removedFileItems,
                                   directories, stopFile, statusFile,
                                   elapseTime, scanSubDir, globalok,
                                   globalerror, todayok, todayerror);
<span class="fc bfc" id="L425" title="All 2 branches covered.">    for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="fc" id="L426">      final FileItem clone = key.getValue().clone();</span>
<span class="fc" id="L427">      lastFileItems.put(key.getKey(), clone);</span>
<span class="fc" id="L428">    }</span>
<span class="fc" id="L429">    createChkFile();</span>
<span class="fc" id="L430">    final String status = JsonHandler.writeAsString(fileMonitorInformation);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">    if (removedFileItems != null) {</span>
<span class="nc" id="L432">      removedFileItems.clear();</span>
    }
<span class="fc" id="L434">    newFileItems.clear();</span>
<span class="fc" id="L435">    return status;</span>
  }

  /**
   * @return the elapseTime
   */
  public long getElapseTime() {
<span class="nc" id="L442">    return elapseTime;</span>
  }

  /**
   * @param elapseTime the elapseTime to set
   */
  public void setElapseTime(long elapseTime) {
<span class="nc" id="L449">    this.elapseTime = elapseTime;</span>
<span class="nc" id="L450">  }</span>

  /**
   * @param filter the filter to set
   */
  public void setFilter(FileFilter filter) {
<span class="nc" id="L456">    this.filter = filter;</span>
<span class="nc" id="L457">  }</span>

  public void start() {
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">    if (timer == null) {</span>
<span class="fc" id="L461">      timer = new HashedWheelTimer(</span>
          new WaarpThreadFactory(&quot;TimerFileMonitor_&quot; + name), 100,
          TimeUnit.MILLISECONDS, 8);
<span class="fc" id="L464">      future = new WaarpFuture(true);</span>
<span class="fc" id="L465">      internalfuture = new WaarpFuture(true);</span>
<span class="pc bpc" id="L466" title="3 of 4 branches missed.">      if (commandValidFileFactory != null &amp;&amp; executor == null) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (fixedThreadPool &gt; 1) {</span>
<span class="nc" id="L468">          executor = Executors.newFixedThreadPool(fixedThreadPool,</span>
                                                  new WaarpThreadFactory(
                                                      &quot;FileMonitorRunner_&quot; +
                                                      name));
<span class="nc bnc" id="L472" title="All 2 branches missed.">        } else if (fixedThreadPool == 0) {</span>
<span class="nc" id="L473">          executor = Executors.newCachedThreadPool(</span>
              new WaarpThreadFactory(&quot;FileMonitorRunner_&quot; + name));
        }
      }
<span class="fc" id="L477">      timer.newTimeout(new FileMonitorTimerTask(this), elapseTime,</span>
                       TimeUnit.MILLISECONDS);
    } // else already started
<span class="pc bpc" id="L480" title="5 of 6 branches missed.">    if (elapseWaarpTime &gt;= DEFAULT_DELAY &amp;&amp; timerWaarp == null &amp;&amp;</span>
        commandCheckIteration != null) {
<span class="nc" id="L482">      timerWaarp = new HashedWheelTimer(</span>
          new WaarpThreadFactory(&quot;TimerFileMonitorWaarp_&quot; + name), 100,
          TimeUnit.MILLISECONDS, 8);
<span class="nc" id="L485">      timerWaarp.newTimeout(</span>
          new FileMonitorTimerInformationTask(commandCheckIteration),
          elapseWaarpTime, TimeUnit.MILLISECONDS);
    }
<span class="fc" id="L489">  }</span>

  public void stop() {
<span class="fc" id="L492">    initialized = false;</span>
<span class="fc" id="L493">    stopped = true;</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">    if (timerWaarp != null) {</span>
<span class="nc" id="L495">      timerWaarp.stop();</span>
    }
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">    if (internalfuture != null) {</span>
<span class="fc" id="L498">      internalfuture.awaitOrInterruptible(elapseTime * 2);</span>
<span class="fc" id="L499">      internalfuture.setSuccess();</span>
    }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    if (timer != null) {</span>
<span class="fc" id="L502">      timer.stop();</span>
    }
<span class="fc" id="L504">    timer = null;</span>
<span class="fc" id="L505">    timerWaarp = null;</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">    if (executor != null) {</span>
<span class="nc" id="L507">      executor.shutdown();</span>
<span class="nc" id="L508">      executor = null;</span>
    }
<span class="fc" id="L510">    deleteChkFile();</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (future != null) {</span>
<span class="fc" id="L512">      future.setSuccess();</span>
    }
<span class="fc" id="L514">  }</span>

  /**
   * @return the head of the File queue but does not remove it
   */
  public File peek() {
<span class="nc" id="L520">    final FileItem item = toUse.peek();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (item == null) {</span>
<span class="nc" id="L522">      return null;</span>
    }
<span class="nc" id="L524">    return item.file;</span>
  }

  /**
   * @return the head of the File queue and removes it
   */
  public File poll() {
<span class="nc" id="L531">    final FileItem item = toUse.poll();</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">    if (item == null) {</span>
<span class="nc" id="L533">      return null;</span>
    }
<span class="nc" id="L535">    return item.file;</span>
  }

  /**
   * Wait until the Stop file is created
   */
  public void waitForStopFile() {
<span class="fc" id="L542">    internalfuture.awaitOrInterruptible();</span>
<span class="fc" id="L543">    stop();</span>
<span class="fc" id="L544">  }</span>

  private boolean checkStop() {
<span class="pc bpc" id="L547" title="1 of 4 branches missed.">    if (stopped || stopFile.exists()) {</span>
<span class="fc" id="L548">      logger.warn(</span>
          &quot;STOPPING the FileMonitor {} since condition is fullfilled: stop file found ({}): &quot; +
<span class="fc" id="L550">          stopFile.exists(), name, stopFile);</span>
<span class="fc" id="L551">      internalfuture.setSuccess();</span>
<span class="fc" id="L552">      return true;</span>
    }
<span class="fc" id="L554">    return false;</span>
  }

  /**
   * Check Files
   *
   * @return False to stop
   */
  protected boolean checkFiles() {
<span class="fc" id="L563">    setThreadName();</span>
<span class="fc" id="L564">    boolean fileItemsChanged = false;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">    if (checkStop()) {</span>
<span class="fc" id="L566">      return false;</span>
    }
<span class="fc" id="L568">    synchronized (directories) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">      for (final File directory : directories) {</span>
<span class="fc" id="L570">        logger.info(&quot;Scan: &quot; + directory);</span>
<span class="fc" id="L571">        fileItemsChanged = checkOneDir(fileItemsChanged, directory);</span>
<span class="fc" id="L572">      }</span>
<span class="fc" id="L573">    }</span>
<span class="fc" id="L574">    setThreadName();</span>
<span class="fc" id="L575">    boolean error = false;</span>
    // Wait for all commands to finish before continuing
<span class="pc bpc" id="L577" title="1 of 2 branches missed.">    for (final Future&lt;?&gt; futureResult : results) {</span>
<span class="nc" id="L578">      createChkFile();</span>
      try {
<span class="nc" id="L580">        futureResult.get();</span>
<span class="nc" id="L581">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L582">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L583">        logger.info(&quot;Interruption so exit&quot;);</span>
<span class="nc" id="L584">        error = true;</span>
<span class="nc" id="L585">      } catch (final ExecutionException e) {</span>
<span class="nc" id="L586">        logger.error(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L587">        error = true;</span>
<span class="nc" id="L588">      } catch (final Throwable e) {</span>
<span class="nc" id="L589">        logger.error(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L590">        error = true;</span>
<span class="nc" id="L591">      }</span>
<span class="nc" id="L592">    }</span>
<span class="fc" id="L593">    logger.debug(&quot;Scan over&quot;);</span>
<span class="fc" id="L594">    results.clear();</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">    if (error) {</span>
      // do not save ?
      // this.saveStatus()
<span class="nc" id="L598">      return false;</span>
    }
    // now check that all existing items are still valid
<span class="fc" id="L601">    final List&lt;FileItem&gt; todel = new LinkedList&lt;FileItem&gt;();</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">    for (final FileItem item : fileItems.values()) {</span>
<span class="pc bpc" id="L603" title="1 of 4 branches missed.">      if (item.file != null &amp;&amp; item.file.isFile()) {</span>
<span class="fc" id="L604">        continue;</span>
      }
<span class="fc" id="L606">      todel.add(item);</span>
<span class="fc" id="L607">    }</span>
    // remove invalid files
<span class="fc bfc" id="L609" title="All 2 branches covered.">    for (FileItem fileItem : todel) {</span>
<span class="fc" id="L610">      final String newName =</span>
<span class="fc" id="L611">          AbstractDir.normalizePath(fileItem.file.getAbsolutePath());</span>
<span class="fc" id="L612">      fileItems.remove(newName);</span>
<span class="fc" id="L613">      toUse.remove(fileItem);</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">      if (commandRemovedFile != null) {</span>
<span class="fc" id="L615">        commandRemovedFile.run(fileItem);</span>
      }
<span class="fc" id="L617">      fileItem.file = null;</span>
<span class="fc" id="L618">      fileItem.hash = null;</span>
<span class="fc" id="L619">      fileItemsChanged = true;</span>
<span class="fc" id="L620">    }</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">    if (fileItemsChanged) {</span>
<span class="fc" id="L622">      saveStatus();</span>
    } else {
<span class="fc" id="L624">      createChkFile();</span>
    }
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">    if (checkStop()) {</span>
<span class="nc" id="L627">      return false;</span>
    }
<span class="fc" id="L629">    logger.debug(&quot;Finishing step&quot;);</span>

<span class="pc bpc" id="L631" title="2 of 4 branches missed.">    if (commandCheckIteration != null &amp;&amp; timerWaarp == null) {</span>
<span class="fc" id="L632">      commandCheckIteration.run(null);</span>
    }
<span class="fc" id="L634">    return true;</span>
  }

  private void setIfAlreadyUsed(FileItem fileItem, boolean valid) {
<span class="fc bfc" id="L638" title="All 6 branches covered.">    if (!ignoreAlreadyUsed &amp;&amp; fileItem.specialId != DbConstant.ILLEGALVALUE &amp;&amp;</span>
        fileItem.used) {
<span class="pc bpc" id="L640" title="2 of 5 branches missed.">      switch (fileItem.status) {</span>
        case START:
<span class="nc" id="L642">          fileItem.status = Status.CHANGING;</span>
<span class="nc" id="L643">          break;</span>
        case CHANGING:
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L646">            fileItem.status = Status.VALID;</span>
          }
          break;
        case VALID:
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L651">            fileItem.status = Status.RESTART;</span>
          }
          break;
        case DONE:
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="nc" id="L656">            fileItem.status = Status.START;</span>
          }
          break;
        case RESTART:
<span class="fc" id="L660">          break;</span>
      }
    } else {
<span class="pc bpc" id="L663" title="1 of 3 branches missed.">      switch (fileItem.status) {</span>
        case START:
<span class="nc" id="L665">          fileItem.status = Status.CHANGING;</span>
<span class="nc" id="L666">          break;</span>
        case CHANGING:
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L669">            fileItem.status = Status.VALID;</span>
          }
          break;
        case VALID:
        case DONE:
        case RESTART:
          break;
      }
    }
<span class="fc" id="L678">  }</span>

  /**
   * @param fileItemsChanged
   * @param directory
   *
   * @return True if one file at least has changed
   */
  protected boolean checkOneDir(boolean fileItemsChanged, File directory) {
    try {
<span class="fc" id="L688">      File[] files = directory.listFiles(filter);</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">      for (final File file : files) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">        if (checkStop()) {</span>
<span class="nc" id="L691">          return false;</span>
        }
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (file.isDirectory()) {</span>
<span class="nc" id="L694">          continue;</span>
        }
<span class="fc" id="L696">        final String newName =</span>
<span class="fc" id="L697">            AbstractDir.normalizePath(file.getAbsolutePath());</span>
<span class="fc" id="L698">        final FileItem fileItem = fileItems.get(newName);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if (fileItem == null) {</span>
          // never seen until now
<span class="fc" id="L701">          fileItems.put(newName, new FileItem(file));</span>
<span class="fc" id="L702">          fileItemsChanged = true;</span>
<span class="fc" id="L703">          continue;</span>
        }
<span class="fc bfc" id="L705" title="All 4 branches covered.">        if (fileItem.used &amp;&amp; ignoreAlreadyUsed) {</span>
          // already used so ignore
<span class="fc" id="L707">          continue;</span>
        }
<span class="fc" id="L709">        logger.debug(&quot;File check: &quot; + fileItem);</span>
<span class="fc" id="L710">        final long size = fileItem.file.length();</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (size != fileItem.size) {</span>
          // changed or second size check
<span class="fc" id="L713">          fileItem.size = size;</span>
<span class="fc" id="L714">          fileItemsChanged = true;</span>
<span class="fc" id="L715">          fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L716">          logger.debug(&quot;File Size check: &quot; + fileItem + &quot;(&quot; + size + &quot;)&quot;);</span>
<span class="fc" id="L717">          continue;</span>
        }
<span class="fc" id="L719">        final long lastTimeModified = fileItem.file.lastModified();</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (lastTimeModified != fileItem.lastTime) {</span>
          // changed or second time check
<span class="fc" id="L722">          fileItem.lastTime = lastTimeModified;</span>
<span class="fc bfc" id="L723" title="All 4 branches covered.">          if (!ignoreAlreadyUsed &amp;&amp; fileItem.used) {</span>
<span class="fc" id="L724">            fileItem.hash = null;</span>
          }
<span class="fc" id="L726">          fileItemsChanged = true;</span>
<span class="fc" id="L727">          fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L728">          logger.debug(</span>
              &quot;File Change check: &quot; + fileItem + &quot;(&quot; + lastTimeModified + &quot;)&quot;);
<span class="fc" id="L730">          continue;</span>
        }
        // now check Hash or third time
        try {
<span class="fc" id="L734">          final byte[] hash =</span>
<span class="fc" id="L735">              FilesystemBasedDigest.getHash(fileItem.file, true, digest);</span>
<span class="pc bpc" id="L736" title="1 of 4 branches missed.">          if (hash == null || fileItem.hash == null) {</span>
<span class="fc" id="L737">            fileItem.hash = hash;</span>
<span class="fc" id="L738">            fileItemsChanged = true;</span>
<span class="fc" id="L739">            fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L740">            logger.debug(&quot;File Hash0 check: &quot; + fileItem);</span>
<span class="fc" id="L741">            continue;</span>
          }
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">          if (!Arrays.equals(hash, fileItem.hash)) {</span>
<span class="nc" id="L744">            fileItem.hash = hash;</span>
<span class="nc" id="L745">            fileItemsChanged = true;</span>
<span class="nc" id="L746">            fileItem.status = Status.CHANGING;</span>
<span class="nc" id="L747">            logger.debug(&quot;File Hash1 check: &quot; + fileItem);</span>
<span class="nc" id="L748">            continue;</span>
          } else {
<span class="fc bfc" id="L750" title="All 2 branches covered.">            setIfAlreadyUsed(fileItem, fileItem.status != Status.DONE);</span>
          }
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">          if (checkStop()) {</span>
<span class="nc" id="L753">            return false;</span>
          }
<span class="fc" id="L755">          boolean toIgnore = false;</span>
<span class="pc bpc" id="L756" title="1 of 6 branches missed.">          if (!ignoreAlreadyUsed &amp;&amp; fileItem.used &amp;&amp;</span>
              fileItem.specialId != DbConstant.ILLEGALVALUE) {
<span class="fc bfc" id="L758" title="All 2 branches covered.">            if (fileItem.status != Status.RESTART) {</span>
<span class="fc" id="L759">              logger.debug(&quot;File Ignore check: &quot; + fileItem);</span>
<span class="fc" id="L760">              toIgnore = true;</span>
            }
          }
<span class="fc" id="L763">          logger.debug(&quot;File Run check: &quot; + fileItem);</span>
          // now time and hash are the same so act on it
<span class="fc" id="L765">          fileItem.timeUsed = System.currentTimeMillis();</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">          if (commandValidFileFactory != null) {</span>
<span class="nc" id="L767">            final FileMonitorCommandRunnableFuture torun =</span>
<span class="nc" id="L768">                commandValidFileFactory.create(fileItem);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (!torun.checkFileItemBusiness(fileItem)) {</span>
<span class="nc" id="L770">              logger.debug(&quot;File Ignore Business check: &quot; + fileItem);</span>
<span class="nc" id="L771">              continue;</span>
            }
<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (toIgnore) {</span>
<span class="nc" id="L774">              continue;</span>
            }
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (executor != null) {</span>
<span class="nc" id="L777">              final Future&lt;?&gt; torunFuture = executor.submit(torun);</span>
<span class="nc" id="L778">              results.add(torunFuture);</span>
<span class="nc" id="L779">            } else {</span>
<span class="nc" id="L780">              torun.run(fileItem);</span>
            }
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">          } else if (commandValidFile != null) {</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            if (!commandValidFile.checkFileItemBusiness(fileItem)) {</span>
<span class="fc" id="L784">              logger.debug(&quot;File Ignore Business check: &quot; + fileItem);</span>
<span class="fc" id="L785">              continue;</span>
            }
<span class="fc bfc" id="L787" title="All 2 branches covered.">            if (toIgnore) {</span>
<span class="fc" id="L788">              continue;</span>
            }
<span class="fc" id="L790">            commandValidFile.run(fileItem);</span>
          } else {
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (toIgnore) {</span>
<span class="nc" id="L793">              continue;</span>
            }
<span class="nc" id="L795">            toUse.add(fileItem);</span>
          }
<span class="fc" id="L797">          fileItemsChanged = true;</span>
<span class="nc" id="L798">        } catch (final Throwable e) {</span>
<span class="nc" id="L799">          setThreadName();</span>
<span class="nc" id="L800">          logger.error(&quot;Error during final file check&quot;, e);</span>
<span class="nc" id="L801">          continue;</span>
<span class="fc" id="L802">        }</span>
      }
<span class="fc bfc" id="L804" title="All 2 branches covered.">      if (scanSubDir) {</span>
<span class="fc" id="L805">        files = directory.listFiles();</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">        for (final File file : files) {</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">          if (checkStop()) {</span>
<span class="nc" id="L808">            return false;</span>
          }
<span class="fc bfc" id="L810" title="All 2 branches covered.">          if (file.isDirectory()) {</span>
<span class="fc" id="L811">            fileItemsChanged = checkOneDir(fileItemsChanged, file);</span>
          }
        }
      }
<span class="nc" id="L815">    } catch (final Throwable e) {</span>
<span class="nc" id="L816">      setThreadName();</span>
<span class="nc" id="L817">      logger.error(&quot;Issue during Directory and File Checking&quot;, e);</span>
      // ignore
<span class="fc" id="L819">    }</span>
<span class="fc" id="L820">    return fileItemsChanged;</span>
  }

  /**
   * Timer task
   */
  protected static class FileMonitorTimerTask implements TimerTask {
    protected final FileMonitor fileMonitor;

    /**
     * @param fileMonitor
     */
<span class="fc" id="L832">    protected FileMonitorTimerTask(FileMonitor fileMonitor) {</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">      if (logger == null) {</span>
<span class="nc" id="L834">        logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
      }
<span class="fc" id="L836">      this.fileMonitor = fileMonitor;</span>
<span class="fc" id="L837">    }</span>

    @Override
    public void run(Timeout timeout) throws Exception {
      try {
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (fileMonitor.checkFiles()) {</span>
<span class="fc" id="L843">          fileMonitor.setThreadName();</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">          if (fileMonitor.timer != null) {</span>
            try {
<span class="fc" id="L846">              fileMonitor.timer.newTimeout(this, fileMonitor.elapseTime,</span>
                                           TimeUnit.MILLISECONDS);
<span class="nc" id="L848">            } catch (final Throwable e) {</span>
<span class="nc" id="L849">              logger.error(&quot;Error while pushing next filemonitor step&quot;, e);</span>
              // ignore and stop
<span class="nc" id="L851">              fileMonitor.internalfuture.setSuccess();</span>
<span class="pc" id="L852">            }</span>
          } else {
<span class="nc" id="L854">            logger.warn(&quot;No Timer found&quot;);</span>
<span class="nc" id="L855">            fileMonitor.internalfuture.setSuccess();</span>
          }
        } else {
<span class="fc" id="L858">          fileMonitor.setThreadName();</span>
<span class="fc" id="L859">          logger.warn(&quot;Stop file found&quot;);</span>
<span class="fc" id="L860">          fileMonitor.deleteChkFile();</span>
<span class="fc" id="L861">          fileMonitor.internalfuture.setSuccess();</span>
        }
<span class="nc" id="L863">      } catch (final Throwable e) {</span>
<span class="nc" id="L864">        fileMonitor.setThreadName();</span>
<span class="nc" id="L865">        logger.error(&quot;Issue during Directory and File Checking&quot;, e);</span>
<span class="nc" id="L866">        fileMonitor.internalfuture.setSuccess();</span>
<span class="fc" id="L867">      }</span>
<span class="fc" id="L868">    }</span>

  }

  /**
   * Class to run Waarp Business information in fixed delay rather than after
   * each check
   */
  protected class FileMonitorTimerInformationTask implements TimerTask {
    protected final FileMonitorCommandRunnableFuture informationMonitorCommand;

    /**
     * @param informationMonitorCommand
     */
    protected FileMonitorTimerInformationTask(
<span class="nc" id="L883">        FileMonitorCommandRunnableFuture informationMonitorCommand) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">      if (logger == null) {</span>
<span class="nc" id="L885">        logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
      }
<span class="nc" id="L887">      this.informationMonitorCommand = informationMonitorCommand;</span>
<span class="nc" id="L888">    }</span>

    @Override
    public void run(Timeout timeout) throws Exception {
      try {
<span class="nc" id="L893">        Thread.currentThread().setName(&quot;FileMonitorInformation_&quot; + name);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (!checkStop()) {</span>
<span class="nc" id="L895">          informationMonitorCommand.run(null);</span>
<span class="nc bnc" id="L896" title="All 4 branches missed.">          if (timerWaarp != null &amp;&amp; !checkStop()) {</span>
            try {
<span class="nc" id="L898">              timerWaarp</span>
<span class="nc" id="L899">                  .newTimeout(this, elapseWaarpTime, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L900">            } catch (final Throwable e) {</span>
              // stop and ignore
<span class="nc" id="L902">              logger.error(&quot;Error during nex filemonitor information step&quot;, e);</span>
<span class="nc" id="L903">              internalfuture.setSuccess();</span>
<span class="nc" id="L904">            }</span>
          } else {
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (timerWaarp != null) {</span>
<span class="nc" id="L907">              logger.warn(&quot;Stop file found&quot;);</span>
            } else {
<span class="nc" id="L909">              logger.warn(&quot;No Timer found&quot;);</span>
            }
<span class="nc" id="L911">            internalfuture.setSuccess();</span>
          }
        } else {
<span class="nc" id="L914">          logger.warn(&quot;Stop file found&quot;);</span>
<span class="nc" id="L915">          internalfuture.setSuccess();</span>
        }
<span class="nc" id="L917">      } catch (final Throwable e) {</span>
        // stop and ignore
<span class="nc" id="L919">        Thread.currentThread().setName(&quot;FileMonitorInformation_&quot; + name);</span>
<span class="nc" id="L920">        logger.error(&quot;Error during nex filemonitor information step&quot;, e);</span>
<span class="nc" id="L921">        internalfuture.setSuccess();</span>
<span class="nc" id="L922">      }</span>
<span class="nc" id="L923">    }</span>
  }

  /**
   * Used by Waarp Business information
   */
  @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)
  public static class FileMonitorInformation {
    public String name;
    public ConcurrentHashMap&lt;String, FileItem&gt; fileItems;
    public Set&lt;String&gt; removedFileItems;
    public List&lt;File&gt; directories;
    public File stopFile;
    public File statusFile;
    public long elapseTime;
    public boolean scanSubDir;
    public AtomicLong globalok;
    public AtomicLong globalerror;
    public AtomicLong todayok;
    public AtomicLong todayerror;

<span class="nc" id="L944">    public FileMonitorInformation() {</span>
      // empty constructor for JSON
<span class="nc" id="L946">    }</span>

    protected FileMonitorInformation(String name,
                                     ConcurrentHashMap&lt;String, FileItem&gt; fileItems,
                                     Set&lt;String&gt; removedFileItems,
                                     List&lt;File&gt; directories, File stopFile,
                                     File statusFile, long elapseTime,
                                     boolean scanSubDir, AtomicLong globalok,
                                     AtomicLong globalerror, AtomicLong todayok,
<span class="fc" id="L955">                                     AtomicLong todayerror) {</span>
<span class="fc" id="L956">      this.name = name;</span>
<span class="fc" id="L957">      this.fileItems = fileItems;</span>
<span class="fc" id="L958">      this.removedFileItems = removedFileItems;</span>
<span class="fc" id="L959">      this.directories = directories;</span>
<span class="fc" id="L960">      this.stopFile = stopFile;</span>
<span class="fc" id="L961">      this.statusFile = statusFile;</span>
<span class="fc" id="L962">      this.elapseTime = elapseTime;</span>
<span class="fc" id="L963">      this.scanSubDir = scanSubDir;</span>
<span class="fc" id="L964">      this.globalok = globalok;</span>
<span class="fc" id="L965">      this.globalerror = globalerror;</span>
<span class="fc" id="L966">      this.todayok = todayok;</span>
<span class="fc" id="L967">      this.todayerror = todayerror;</span>
<span class="fc" id="L968">    }</span>

  }

<span class="fc" id="L972">  public static enum Status {</span>
<span class="fc" id="L973">    START, CHANGING, VALID, DONE, RESTART</span>
  }

  /**
   * One element in the directory
   */
  public static class FileItem implements Cloneable {
    public File file;
    public long size;
    public byte[] hash;
<span class="pc" id="L983">    public long lastTime = Long.MIN_VALUE;</span>
<span class="pc" id="L984">    public long timeUsed = Long.MIN_VALUE;</span>
    public boolean used;
<span class="pc" id="L986">    public Status status = Status.START;</span>
<span class="pc" id="L987">    public long specialId = DbConstant.ILLEGALVALUE;</span>

<span class="nc" id="L989">    public FileItem() {</span>
      // empty constructor for JSON
<span class="nc" id="L991">    }</span>

    /**
     * @param file
     */
<span class="fc" id="L996">    protected FileItem(File file) {</span>
<span class="fc" id="L997">      this.file = file;</span>
<span class="fc" id="L998">    }</span>

    @Override
    public int hashCode() {
<span class="nc" id="L1002">      return file.hashCode();</span>
    }

    @Override
    public boolean equals(Object obj) {
      // equality is based on file itself
<span class="nc bnc" id="L1008" title="All 4 branches missed.">      return obj instanceof FileItem &amp;&amp; file.equals(((FileItem) obj).file);</span>
    }

    /**
     * @param item
     *
     * @return True if the fileItem is strictly the same (and not only the
     *     file as in equals)
     */
    public boolean isStrictlySame(FileItem item) {
<span class="nc bnc" id="L1018" title="All 2 branches missed.">      return item != null &amp;&amp;</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">             file.getAbsolutePath().equals(item.file.getAbsolutePath()) &amp;&amp;</span>
<span class="nc bnc" id="L1020" title="All 8 branches missed.">             file.length() == item.size &amp;&amp; lastTime == item.lastTime &amp;&amp;</span>
             timeUsed == item.timeUsed &amp;&amp; used == item.used &amp;&amp;
<span class="nc bnc" id="L1022" title="All 4 branches missed.">             status.equals(item.status) &amp;&amp;</span>
<span class="nc bnc" id="L1023" title="All 4 branches missed.">             (hash != null? Arrays.equals(hash, item.hash) : item.hash == null);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L1028">      return file.getAbsolutePath() + &quot; : &quot; + size + &quot; : &quot; + specialId + &quot; : &quot; +</span>
             used + &quot; : &quot; + status + &quot; : &quot; + lastTime + &quot; : &quot; + timeUsed;
    }

    @Override
    public FileItem clone() { //NOSONAR
<span class="fc" id="L1034">      final FileItem clone = new FileItem(file);</span>
<span class="fc" id="L1035">      clone.hash = hash;</span>
<span class="fc" id="L1036">      clone.lastTime = lastTime;</span>
<span class="fc" id="L1037">      clone.timeUsed = timeUsed;</span>
<span class="fc" id="L1038">      clone.used = used;</span>
<span class="fc" id="L1039">      clone.specialId = specialId;</span>
<span class="fc" id="L1040">      clone.status = status;</span>
<span class="fc" id="L1041">      clone.size = size;</span>
<span class="fc" id="L1042">      return clone;</span>
    }
  }

  public static void main(String[] args) {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L1048">      logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
    }
<span class="nc bnc" id="L1050" title="All 2 branches missed.">    if (args.length &lt; 3) {</span>
<span class="nc" id="L1051">      SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1052">          .syserr(&quot;Need a statusfile, a stopfile and a directory to test&quot;);</span>
<span class="nc" id="L1053">      return;</span>
    }
<span class="nc" id="L1055">    final File file = new File(args[0]);</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">    if (file.exists() &amp;&amp; !file.isFile()) {</span>
<span class="nc" id="L1057">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a correct status file&quot;);</span>
<span class="nc" id="L1058">      return;</span>
    }
<span class="nc" id="L1060">    final File stopfile = new File(args[1]);</span>
<span class="nc bnc" id="L1061" title="All 4 branches missed.">    if (file.exists() &amp;&amp; !file.isFile()) {</span>
<span class="nc" id="L1062">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a correct stop file&quot;);</span>
<span class="nc" id="L1063">      return;</span>
    }
<span class="nc" id="L1065">    final File dir = new File(args[2]);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">    if (!dir.isDirectory()) {</span>
<span class="nc" id="L1067">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a directory&quot;);</span>
<span class="nc" id="L1068">      return;</span>
    }
<span class="nc" id="L1070">    final FileMonitorCommandRunnableFuture filemonitor =</span>
<span class="nc" id="L1071">        new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(FileItem file) {
<span class="nc" id="L1074">            SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1075">                .syserr(&quot;File New: &quot; + file.file.getAbsolutePath());</span>
<span class="nc" id="L1076">            finalizeValidFile(true, 0);</span>
<span class="nc" id="L1077">          }</span>
        };
<span class="nc" id="L1079">    final FileMonitor monitor =</span>
        new FileMonitor(&quot;test&quot;, file, stopfile, dir, null, 0,
                        new RegexFileFilter(
                            RegexFileFilter.REGEX_XML_EXTENSION), false,
<span class="nc" id="L1083">                        filemonitor, new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(FileItem file) {
<span class="nc" id="L1086">            SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1087">                .syserr(&quot;File Del: &quot; + file.file.getAbsolutePath());</span>
<span class="nc" id="L1088">          }</span>
<span class="nc" id="L1089">        }, new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(FileItem unused) {
<span class="nc" id="L1092">            SysErrLogger.FAKE_LOGGER.syserr(&quot;Check done&quot;);</span>
<span class="nc" id="L1093">          }</span>
        });
<span class="nc" id="L1095">    filemonitor.setMonitor(monitor);</span>
<span class="nc" id="L1096">    monitor.start();</span>
<span class="nc" id="L1097">    monitor.waitForStopFile();</span>
<span class="nc" id="L1098">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>