<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClientRunner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.commander</a> &gt; <span class="el_source">ClientRunner.java</span></div><h1>ClientRunner.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.commander;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.RecvThroughHandler;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.DbConstantR66;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.database.data.DbTaskRunner.TASKSTEP;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotAuthenticatedException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.TransferUtils;

import java.io.File;
import java.net.SocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Client Runner from a TaskRunner
 */
public class ClientRunner extends Thread {
  private static final String CANNOT_CONNECT_TO_SERVER =
      &quot;Cannot connect to server &quot;;

  private static final String REQUEST_INFORMATION_FAILURE =
      &quot;RequestInformation.Failure&quot;;

  private static final String REQUEST_INFORMATION_SUCCESS =
      &quot;RequestInformation.Success&quot;;

  private static final String TRANSFER_STATUS = &quot;Transfer.Status&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L76">  private static final WaarpLogger logger =</span>
<span class="fc" id="L77">      WaarpLoggerFactory.getLogger(ClientRunner.class);</span>

  private static final ConcurrentHashMap&lt;String, Integer&gt;
<span class="fc" id="L80">      taskRunnerRetryHashMap = new ConcurrentHashMap&lt;String, Integer&gt;();</span>

  public static ConcurrentLinkedQueue&lt;ClientRunner&gt; activeRunners;

  private final NetworkTransaction networkTransaction;

  private final DbTaskRunner taskRunner;

  private final R66Future futureRequest;

  private RecvThroughHandler handler;

  private boolean isSendThroughMode;

  private LocalChannelReference localChannelReference;

  private final String nameTask;

<span class="fc" id="L98">  private boolean limitRetryConnection = true;</span>

  public ClientRunner(final NetworkTransaction networkTransaction,
                      final DbTaskRunner taskRunner,
<span class="fc" id="L102">                      final R66Future futureRequest) {</span>
<span class="fc" id="L103">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L104">    this.taskRunner = taskRunner;</span>
<span class="fc" id="L105">    this.futureRequest = futureRequest;</span>
<span class="fc" id="L106">    setDaemon(true);</span>
<span class="fc" id="L107">    nameTask = &quot;Client_Runner_&quot; + taskRunner.getKey();</span>
<span class="fc" id="L108">    setName(nameTask);</span>
<span class="fc" id="L109">  }</span>

  public static String hashStatus() {
<span class="nc" id="L112">    return &quot;ClientRunner: [taskRunnerRetryHashMap: &quot; +</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">           taskRunnerRetryHashMap.size() + &quot; activeRunners: &quot; +</span>
<span class="nc" id="L114">           (activeRunners != null? activeRunners.size() :</span>
<span class="nc" id="L115">               Configuration.configuration.getInternalRunner()</span>
<span class="nc" id="L116">                                          .nbInternalRunner()) + &quot;] &quot;;</span>
  }

  /**
   * @return the networkTransaction
   */
  public NetworkTransaction getNetworkTransaction() {
<span class="nc" id="L123">    return networkTransaction;</span>
  }

  /**
   * @return the taskRunner
   */
  public DbTaskRunner getTaskRunner() {
<span class="nc" id="L130">    return taskRunner;</span>
  }

  /**
   * @return the localChannelReference
   */
  public LocalChannelReference getLocalChannelReference() {
<span class="nc" id="L137">    return localChannelReference;</span>
  }

  @Override
  public void run() {
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">    if (Configuration.configuration.isShutdown() || Thread.interrupted()) {</span>
<span class="nc" id="L143">      taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L144">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L145">      return;</span>
    }
    try {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L149">        activeRunners.add(this);</span>
      }
      // fix for SelfRequest
<span class="fc bfc" id="L152" title="All 2 branches covered.">      if (taskRunner.isSelfRequest()) {</span>
<span class="fc" id="L153">        taskRunner.setSenderByRequestToValidate(false);</span>
      }
      // Try to check if file still exists in send not self not through mode
<span class="fc bfc" id="L156" title="All 4 branches covered.">      if (taskRunner.isSender() &amp;&amp; !taskRunner.isSelfRequest() &amp;&amp;</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">          !taskRunner.isSendThrough()) {</span>
        try {
<span class="fc" id="L159">          final R66Session session = new R66Session();</span>
<span class="fc" id="L160">          session.setReady(true);</span>
<span class="fc" id="L161">          final boolean ssl = Configuration.configuration.isUseSSL();</span>
<span class="fc" id="L162">          session.getAuth().specialNoSessionAuth(ssl,</span>
                                                 Configuration.configuration
<span class="fc" id="L164">                                                     .getHostId(ssl));</span>
<span class="fc" id="L165">          final DbTaskRunner reloaded =</span>
<span class="fc" id="L166">              new DbTaskRunner(session, taskRunner.getRule(),</span>
<span class="fc" id="L167">                               taskRunner.getSpecialId(),</span>
<span class="fc" id="L168">                               taskRunner.getRequester(),</span>
<span class="fc" id="L169">                               taskRunner.getRequested());</span>
<span class="fc" id="L170">          session.setRunner(reloaded);</span>
<span class="fc" id="L171">          final File file = new File(reloaded.getFullFilePath());</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">          if (!file.isFile()) {</span>
<span class="nc" id="L173">            logger.warn(&quot;File not found: {}&quot;, file.getAbsolutePath());</span>
            // File does no more exist =&gt; error
<span class="nc" id="L175">            reloaded.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L176">            reloaded.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="nc" id="L177">            logger</span>
<span class="nc" id="L178">                .error(&quot;Runner Error: {} {}&quot;, ErrorCode.FileNotFound.getMesg(),</span>
<span class="nc" id="L179">                       taskRunner.toShortString());</span>
<span class="nc" id="L180">            reloaded.setErrorTask();</span>
<span class="nc" id="L181">            reloaded.update();</span>
<span class="nc" id="L182">            return;</span>
          }
<span class="nc" id="L184">        } catch (final CommandAbstractException e) {</span>
          // Wrong path? Ignore
<span class="nc" id="L186">          logger.warn(e);</span>
<span class="nc" id="L187">        } catch (final OpenR66RunnerErrorException e) {</span>
          // Wrong run error? Ignore
<span class="nc" id="L189">          logger.warn(e);</span>
<span class="nc" id="L190">        } catch (final WaarpDatabaseException e) {</span>
          // Wrong dbtask? Ignore
<span class="nc" id="L192">          logger.warn(e);</span>
<span class="nc" id="L193">        } catch (final OpenR66ProtocolNoSslException e) {</span>
          // Wrong ssl? Ignore
<span class="nc" id="L195">          logger.warn(e);</span>
<span class="pc" id="L196">        }</span>
      }
      final R66Future transfer;
      try {
<span class="fc" id="L200">        transfer = runTransfer();</span>
<span class="nc" id="L201">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L202">        logger.error(&quot;Runner Error: {} {}&quot;, e.getMessage(),</span>
<span class="nc" id="L203">                     taskRunner.toShortString());</span>
<span class="nc" id="L204">        return;</span>
<span class="nc" id="L205">      } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="nc" id="L206">        logger.error(&quot;No connection Error {}&quot;, e.getMessage());</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L208">          localChannelReference</span>
<span class="nc" id="L209">              .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                               ErrorCode.ConnectionImpossible);
        }
<span class="nc" id="L212">        taskRunner.setErrorTask();</span>
        try {
<span class="nc" id="L214">          taskRunner.forceSaveStatus();</span>
<span class="nc" id="L215">          taskRunner.run();</span>
<span class="nc" id="L216">        } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L217">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="nc" id="L219">        }</span>
<span class="nc" id="L220">        return;</span>
<span class="nc" id="L221">      } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L222">        logger.error(&quot;Protocol Error&quot;, e);</span>
<span class="nc" id="L223">        return;</span>
<span class="nc" id="L224">      } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="nc" id="L225">        logger.warn(&quot;No connection warning {}&quot;, e.getMessage());</span>
<span class="nc" id="L226">        return;</span>
<span class="fc" id="L227">      }</span>
<span class="fc" id="L228">      final R66Result result = transfer.getResult();</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">      if (result != null) {</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (result.getCode() == ErrorCode.QueryAlreadyFinished) {</span>
<span class="nc" id="L231">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                      (transfer.isSuccess()?</span>
<span class="nc" id="L233">                          Messages.getString(REQUEST_INFORMATION_SUCCESS) :</span>
<span class="nc" id="L234">                          Messages.getString(REQUEST_INFORMATION_FAILURE)) +</span>
<span class="nc" id="L235">                      &quot;     &quot; + ErrorCode.QueryAlreadyFinished.getMesg() + ':' +</span>
<span class="nc" id="L236">                      result.toString());</span>
        } else {
<span class="fc bfc" id="L238" title="All 2 branches covered.">          if (transfer.isSuccess()) {</span>
<span class="fc" id="L239">            logger.info(Messages.getString(TRANSFER_STATUS) +</span>
<span class="fc" id="L240">                        Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
<span class="fc" id="L241">                        &quot;     &quot; + result.toString());</span>
          } else {
<span class="fc" id="L243">            logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="fc" id="L244">                         Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
<span class="fc" id="L245">                         &quot;     &quot; + result.toString());</span>
          }
        }
      } else {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (transfer.isSuccess()) {</span>
<span class="nc" id="L250">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L251">                      Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
                      &quot;     no result&quot;);
        } else {
<span class="nc" id="L254">          logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L255">                       Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                       &quot;     no result&quot;);
        }
      }
    } finally {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L261">        activeRunners.remove(this);</span>
      }
<span class="fc" id="L263">      setName(&quot;Finished_&quot; + nameTask);</span>
    }
<span class="fc" id="L265">  }</span>

  /**
   * @param runner
   * @param limit
   *
   * @return True if the task was run less than limit, else False
   */
  public boolean incrementTaskRunnerTry(final DbTaskRunner runner,
                                        final int limit) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">    if (!isLimitRetryConnection()) {</span>
<span class="nc" id="L276">      return true;</span>
    }
<span class="nc" id="L278">    final String key = runner.getKey();</span>
<span class="nc" id="L279">    Integer tries = taskRunnerRetryHashMap.get(key);</span>
<span class="nc" id="L280">    logger.debug(&quot;try to find integer: &quot; + tries);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (tries == null) {</span>
<span class="nc" id="L282">      tries = 1;</span>
    } else {
<span class="nc" id="L284">      tries += 1;</span>
    }
<span class="nc bnc" id="L286" title="All 2 branches missed.">    logger.debug(&quot;Check: {} vs {}: {}&quot;, tries, limit, limit &lt;= tries);</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">    if (limit &lt;= tries || Thread.interrupted()) {</span>
<span class="nc" id="L288">      taskRunnerRetryHashMap.remove(key);</span>
<span class="nc" id="L289">      return false;</span>
    } else {
<span class="nc" id="L291">      taskRunnerRetryHashMap.put(key, tries);</span>
<span class="nc" id="L292">      return true;</span>
    }
  }

  /**
   * True transfer run (can be called directly to enable exception outside any
   * executors)
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future runTransfer()
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L311">    logger.debug(&quot;Start attempt Transfer&quot;);</span>
<span class="fc" id="L312">    localChannelReference = initRequest();</span>
<span class="fc" id="L313">    localChannelReference.getFutureValidRequest().awaitOrInterruptible(</span>
<span class="fc" id="L314">        Configuration.configuration.getTimeoutCon());</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">    if (localChannelReference.getFutureValidRequest().isSuccess()) {</span>
<span class="fc" id="L316">      return finishTransfer(localChannelReference);</span>
<span class="nc" id="L317">    } else if (</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult() != null &amp;&amp;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult().getCode() ==</span>
        ErrorCode.ServerOverloaded) {
<span class="nc" id="L321">      return tryAgainTransferOnOverloaded(true, localChannelReference);</span>
    } else {
<span class="nc" id="L323">      return finishTransfer(localChannelReference);</span>
    }
  }

  /**
   * In case an overloaded signal is returned by the requested
   *
   * @param retry if True, it will retry in case of overloaded remote
   *     server, else it just stops
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future tryAgainTransferOnOverloaded(final boolean retry,
                                                final LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="nc bnc" id="L346" title="All 2 branches missed.">    if (this.localChannelReference == null) {</span>
<span class="nc" id="L347">      this.localChannelReference = localChannelReference;</span>
    }
<span class="nc" id="L349">    final boolean incRetry =</span>
<span class="nc" id="L350">        incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB);</span>
<span class="nc" id="L351">    logger.debug(&quot;tryAgainTransferOnOverloaded: &quot; + retry + ':' + incRetry);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    switch (taskRunner.getUpdatedInfo()) {</span>
      case DONE:
      case INERROR:
      case INTERRUPTED:
<span class="nc" id="L356">        break;</span>
      default:
<span class="nc" id="L358">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ServerOverloaded,</span>
                          true);
    }
    // redo if possible
<span class="nc bnc" id="L362" title="All 4 branches missed.">    if (retry &amp;&amp; incRetry) {</span>
      try {
<span class="nc" id="L364">        Thread.sleep(Configuration.configuration.getConstraintLimitHandler()</span>
<span class="nc" id="L365">                                                .getSleepTime());</span>
<span class="nc" id="L366">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L367">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L368">      }</span>
<span class="nc" id="L369">      return runTransfer();</span>
    } else {
<span class="nc bnc" id="L371" title="All 2 branches missed.">      if (localChannelReference == null) {</span>
<span class="nc" id="L372">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
      }
<span class="nc" id="L374">      taskRunner.getLocalChannelReference()</span>
<span class="nc" id="L375">                .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                                 ErrorCode.ConnectionImpossible);
<span class="nc" id="L377">      taskRunner.setErrorTask();</span>
<span class="nc" id="L378">      taskRunner.run();</span>
<span class="nc" id="L379">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;End of retry on ServerOverloaded&quot;);
    }
  }

  /**
   * Finish the transfer (called at the end of runTransfer)
   *
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66ProtocolNotYetConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66RunnerErrorException
   */
  public R66Future finishTransfer(
      final LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException {
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">    if (this.localChannelReference == null) {</span>
<span class="nc" id="L400">      this.localChannelReference = localChannelReference;</span>
    }
<span class="fc" id="L402">    final R66Future transfer = localChannelReference.getFutureRequest();</span>
<span class="fc" id="L403">    transfer.awaitOrInterruptible();</span>
<span class="fc" id="L404">    taskRunnerRetryHashMap.remove(taskRunner.getKey());</span>
<span class="fc" id="L405">    logger.info(&quot;Request done with {}&quot;,</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                transfer.isSuccess()? &quot;success&quot; : &quot;error&quot;);</span>
<span class="fc" id="L407">    localChannelReference.close();</span>
    // now reload TaskRunner if it still exists (light client can forget it)
<span class="fc" id="L409">    final boolean isSender = taskRunner.isSender();</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">    if (transfer.isSuccess()) {</span>
      try {
<span class="fc" id="L412">        taskRunner.select();</span>
<span class="nc" id="L413">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L414">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;, e);</span>
<span class="nc" id="L415">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L416">      }</span>
<span class="fc" id="L417">      taskRunner.setSender(isSender);</span>
<span class="fc" id="L418">      changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
    } else {
      try {
<span class="fc" id="L421">        taskRunner.select();</span>
<span class="nc" id="L422">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L423">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;);</span>
<span class="nc" id="L424">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L425">      }</span>
<span class="fc" id="L426">      taskRunner.setSender(isSender);</span>
      // Case when we were interrupted
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">      if (transfer.getResult() == null) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
<span class="nc" id="L431">            final R66Result ok =</span>
                new R66Result(null, true, ErrorCode.CompleteOk, taskRunner);
<span class="nc" id="L433">            transfer.setResult(ok);</span>
<span class="nc" id="L434">            transfer.setSuccess();</span>
<span class="nc" id="L435">            changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
<span class="nc" id="L436">            break;</span>
          case INERROR:
          case INTERRUPTED:
          default:
<span class="nc" id="L440">            final R66Result error =</span>
                new R66Result(null, true, ErrorCode.Internal, taskRunner);
<span class="nc" id="L442">            transfer.setResult(error);</span>
<span class="nc" id="L443">            transfer.cancel();</span>
<span class="nc" id="L444">            changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.Internal, false);</span>
        }
<span class="nc" id="L446">        return transfer;</span>
      }
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">      if (transfer.getResult().getCode() == ErrorCode.QueryAlreadyFinished) {</span>
        // check if post task to execute
<span class="nc" id="L450">        logger.warn(&quot;WARN QueryAlreadyFinished:     &quot; + transfer + &quot;     &quot; +</span>
<span class="nc" id="L451">                    taskRunner.toShortString());</span>
        try {
<span class="nc" id="L453">          TransferUtils</span>
<span class="nc" id="L454">              .finalizeTaskWithNoSession(taskRunner, localChannelReference);</span>
<span class="nc" id="L455">        } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L456">          taskRunner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L457">          taskRunner.forceSaveStatus();</span>
<span class="nc" id="L458">        }</span>
      } else {
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
          case INERROR:
          case INTERRUPTED:
          case TOSUBMIT:
<span class="fc" id="L465">            break;</span>
          default:
<span class="nc" id="L467">            changeUpdatedInfo(UpdatedInfo.INERROR,</span>
<span class="nc" id="L468">                              transfer.getResult().getCode(), false);</span>
        }
      }
    }
<span class="fc" id="L472">    return transfer;</span>
  }

  /**
   * Initialize the request
   *
   * @return the localChannelReference holding the transfer request
   *
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public LocalChannelReference initRequest()
      throws OpenR66ProtocolNoConnectionException, OpenR66RunnerErrorException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L489">    changeUpdatedInfo(UpdatedInfo.RUNNING, ErrorCode.Running, true);</span>
<span class="fc" id="L490">    final long id = taskRunner.getSpecialId();</span>
    final String tid;
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">    if (id == DbConstantR66.ILLEGALVALUE) {</span>
<span class="nc" id="L493">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            &quot;_NEWTRANSFER&quot;;
    } else {
<span class="fc" id="L496">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            '_' + id;
    }
<span class="fc" id="L499">    setName(tid);</span>
<span class="fc" id="L500">    logger.debug(&quot;Will run {}&quot;, taskRunner);</span>
<span class="fc" id="L501">    boolean restartPost = false;</span>
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">    if (taskRunner.getGloballaststep() == TASKSTEP.POSTTASK.ordinal()) {</span>
      // Send a validation to requested
<span class="nc bnc" id="L504" title="All 2 branches missed.">      if (!taskRunner.isSelfRequested()) {</span>
        // restart
<span class="nc" id="L506">        restartPost = true;</span>
      }
    }
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">    if (taskRunner.isSelfRequested()) {</span>
      // Don't have to restart a task for itself (or should use requester)
<span class="nc" id="L511">      logger.warn(&quot;Requested host cannot initiate itself the request&quot;);</span>
<span class="nc" id="L512">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.LoopSelfRequestedHost,</span>
                        true);
<span class="nc" id="L514">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Requested host cannot initiate itself the request&quot;);
    }
    final DbHostAuth host;
    try {
<span class="fc" id="L519">      host = new DbHostAuth(taskRunner.getRequested());</span>
<span class="nc" id="L520">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L521">      logger.error(</span>
<span class="nc" id="L522">          &quot;Requested host cannot be found: &quot; + taskRunner.getRequested());</span>
<span class="nc" id="L523">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.NotKnownHost, true);</span>
<span class="nc" id="L524">      throw new OpenR66ProtocolNoConnectionException(</span>
<span class="nc" id="L525">          &quot;Requested host cannot be found &quot; + taskRunner.getRequested());</span>
<span class="fc" id="L526">    }</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">    if (host.isClient()) {</span>
<span class="nc" id="L528">      logger.warn(&quot;Cannot initiate a connection with a client: {}&quot;, host);</span>
<span class="nc" id="L529">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                        true);
<span class="nc" id="L531">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Cannot connect to client &quot; + host);
    }
<span class="fc" id="L534">    final SocketAddress socketAddress = host.getSocketAddress();</span>
<span class="fc" id="L535">    final boolean isSSL = host.isSsl();</span>

    final LocalChannelReference localChannelReferenceTemp;
    try {
<span class="fc" id="L539">      localChannelReferenceTemp = networkTransaction</span>
<span class="fc" id="L540">          .createConnectionWithRetryWithAuthenticationException(socketAddress,</span>
                                                                isSSL,
                                                                futureRequest);
<span class="nc" id="L543">    } catch (final OpenR66ProtocolNotAuthenticatedException e1) {</span>
<span class="nc" id="L544">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.BadAuthent, true);</span>
<span class="nc" id="L545">      taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L546">      throw new OpenR66ProtocolNoConnectionException(</span>
          CANNOT_CONNECT_TO_SERVER + host +
          &quot; cannot be authenticated so stop retry here&quot;, e1);
<span class="fc" id="L549">    }</span>
<span class="fc" id="L550">    taskRunner.setLocalChannelReference(localChannelReferenceTemp);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">    if (localChannelReferenceTemp == null) {</span>
      // propose to redo
      String retry;
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB)) {</span>

<span class="nc" id="L556">        logger.debug(&quot;Will retry since Cannot connect to {}&quot;, host);</span>
<span class="nc" id="L557">        retry = &quot; but will retry&quot;;</span>
        // now wait
        try {
<span class="nc" id="L560">          Thread.sleep(Configuration.configuration.getDelayRetry());</span>
<span class="nc" id="L561">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L562">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L563">          logger.debug(</span>
              &quot;Will not retry since an interruption occurs while connection &quot; +
              &quot;to {}&quot;, host);
<span class="nc" id="L566">          retry = &quot; and retries gets an interruption so stop here&quot;;</span>
<span class="nc" id="L567">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="nc" id="L569">          taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L570">          throw new OpenR66ProtocolNoConnectionException(</span>
              CANNOT_CONNECT_TO_SERVER + host + retry);
<span class="nc" id="L572">        }</span>
<span class="nc" id="L573">        changeUpdatedInfo(UpdatedInfo.TOSUBMIT, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="nc" id="L575">        throw new OpenR66ProtocolNotYetConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      } else {
<span class="nc" id="L578">        logger.debug(</span>
            &quot;Will not retry since limit of connection attemtps is reached for {}&quot;,
            host);
<span class="nc" id="L581">        retry = &quot; and retries reach step limit so stop here&quot;;</span>
<span class="nc" id="L582">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="nc" id="L584">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L585">        throw new OpenR66ProtocolNoConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      }
    }
<span class="fc bfc" id="L589" title="All 2 branches covered.">    if (handler != null) {</span>
<span class="fc" id="L590">      localChannelReferenceTemp.setRecvThroughHandler(handler);</span>
    }
<span class="fc" id="L592">    localChannelReferenceTemp.setSendThroughMode(isSendThroughMode);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">    if (restartPost) {</span>
<span class="nc" id="L594">      final RequestPacket request = taskRunner.getRequest();</span>
<span class="nc" id="L595">      logger.debug(&quot;Will send request {} &quot;, request);</span>
<span class="nc" id="L596">      localChannelReferenceTemp.setClientRunner(this);</span>
<span class="nc" id="L597">      localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
      try {
<span class="nc" id="L599">        ChannelUtils</span>
<span class="nc" id="L600">            .writeAbstractLocalPacket(localChannelReferenceTemp, request, true);</span>
<span class="nc" id="L601">      } catch (final OpenR66ProtocolPacketException e) {</span>
        // propose to redo
<span class="nc" id="L603">        logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L604">        changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L605">        localChannelReferenceTemp.close();</span>
<span class="nc" id="L606">        throw e;</span>
<span class="nc" id="L607">      }</span>
<span class="nc" id="L608">      logger.debug(&quot;Wait for request to {}&quot;, host);</span>
<span class="nc" id="L609">      return localChannelReferenceTemp;</span>
    }
    // If Requester is NOT Sender, and if TransferTask then decrease now if
    // possible the rank
<span class="fc bfc" id="L613" title="All 2 branches covered.">    if (!taskRunner.isSender() &amp;&amp;</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        taskRunner.getGloballaststep() == TASKSTEP.TRANSFERTASK.ordinal()) {</span>
<span class="nc" id="L615">      logger</span>
<span class="nc" id="L616">          .debug(&quot;Requester is not Sender so decrease if possible the rank {}&quot;,</span>
                 taskRunner);
<span class="nc" id="L618">      taskRunner.restartRank();</span>
<span class="nc" id="L619">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L620">      logger.debug(</span>
<span class="nc" id="L621">          &quot;Requester is not Sender so new rank is &quot; + taskRunner.getRank() +</span>
          &quot; {}&quot;, taskRunner);
    }
<span class="fc" id="L624">    final RequestPacket request = taskRunner.getRequest();</span>
<span class="fc" id="L625">    request.setLimit(</span>
<span class="fc" id="L626">        localChannelReferenceTemp.getChannelLimit(taskRunner.isSender()));</span>
<span class="fc" id="L627">    localChannelReferenceTemp.setClientRunner(this);</span>
<span class="fc" id="L628">    logger.debug(&quot;Will send request {} {}&quot;, request, localChannelReferenceTemp);</span>
<span class="fc" id="L629">    localChannelReferenceTemp.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
    try {
<span class="fc" id="L631">      ChannelUtils</span>
<span class="fc" id="L632">          .writeAbstractLocalPacket(localChannelReferenceTemp, request, true);</span>
<span class="nc" id="L633">    } catch (final OpenR66ProtocolPacketException e) {</span>
      // propose to redo
<span class="nc" id="L635">      logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L636">      changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L637">      localChannelReferenceTemp.close();</span>
<span class="nc" id="L638">      throw e;</span>
<span class="fc" id="L639">    }</span>
<span class="fc" id="L640">    logger</span>
<span class="fc" id="L641">        .debug(&quot;Wait for request to {} {} {}&quot;, host, localChannelReferenceTemp,</span>
               request);
<span class="fc" id="L643">    return localChannelReferenceTemp;</span>
  }

  /**
   * Change the UpdatedInfo of the current runner
   *
   * @param info
   */
  public void changeUpdatedInfo(final AbstractDbData.UpdatedInfo info,
                                final ErrorCode code, final boolean force) {
<span class="fc" id="L653">    taskRunner.changeUpdatedInfo(info);</span>
<span class="fc" id="L654">    taskRunner.setErrorExecutionStatus(code);</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">    if (force) {</span>
<span class="fc" id="L656">      taskRunner.forceSaveStatus();</span>
    } else {
      try {
<span class="fc" id="L659">        taskRunner.saveStatus();</span>
<span class="nc" id="L660">      } catch (final OpenR66RunnerErrorException ignored) {</span>
        // nothing
<span class="fc" id="L662">      }</span>
    }
<span class="fc" id="L664">  }</span>

  /**
   * @param handler the handler to set
   */
  public void setRecvThroughHandler(final RecvThroughHandler handler) {
<span class="fc" id="L670">    this.handler = handler;</span>
<span class="fc" id="L671">  }</span>

  public void setSendThroughMode() {
<span class="nc" id="L674">    isSendThroughMode = true;</span>
<span class="nc" id="L675">  }</span>

  public boolean getSendThroughMode() {
<span class="nc" id="L678">    return isSendThroughMode;</span>
  }

  public boolean isLimitRetryConnection() {
<span class="nc" id="L682">    return limitRetryConnection;</span>
  }

  public void setLimitRetryConnection(final boolean limitRetryConnection) {
<span class="fc" id="L686">    this.limitRetryConnection = limitRetryConnection;</span>
<span class="fc" id="L687">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>