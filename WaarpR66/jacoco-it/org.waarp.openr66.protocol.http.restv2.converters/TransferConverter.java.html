<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransferConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.http.restv2.converters</a> &gt; <span class="el_source">TransferConverter.java</span></div><h1>TransferConverter.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.openr66.protocol.http.restv2.converters;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.joda.time.DateTime;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.utility.ParametersChecker;
import org.waarp.openr66.dao.DAOFactory;
import org.waarp.openr66.dao.HostDAO;
import org.waarp.openr66.dao.RuleDAO;
import org.waarp.openr66.dao.exception.DAOConnectionException;
import org.waarp.openr66.dao.exception.DAONoDataException;
import org.waarp.openr66.pojo.Rule;
import org.waarp.openr66.pojo.Transfer;
import org.waarp.openr66.pojo.UpdatedInfo;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.http.restv2.converters.RuleConverter.ModeTrans;
import org.waarp.openr66.protocol.http.restv2.errors.RestError;
import org.waarp.openr66.protocol.http.restv2.errors.RestErrorException;

import javax.ws.rs.InternalServerErrorException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import static org.waarp.common.file.FileUtils.*;
import static org.waarp.openr66.dao.database.DBTransferDAO.*;
import static org.waarp.openr66.protocol.http.restv2.RestConstants.*;
import static org.waarp.openr66.protocol.http.restv2.RestConstants.TransferFields.*;
import static org.waarp.openr66.protocol.http.restv2.errors.RestErrors.*;

/**
 * A collection of utility methods to convert {@link Transfer} objects to their
 * corresponding
 * {@link ObjectNode} and vice-versa.
 */
public final class TransferConverter {

  /**
   * Makes the default constructor of this utility class inaccessible.
   */
<span class="nc" id="L67">  private TransferConverter() throws InstantiationException {</span>
<span class="nc" id="L68">    throw new InstantiationException(</span>
<span class="nc" id="L69">        getClass().getName() + &quot; cannot be instantiated.&quot;);</span>
  }

  // ########################### INNER CLASSES ################################

  /**
   * All the possible ways to order a list of transfer objects.
   */
<span class="fc" id="L77">  public enum Order {</span>
    /**
     * By transferId, in ascending order.
     */
<span class="fc" id="L81">    ascId(ID_FIELD, true),</span>
    /**
     * By transferId, in descending order.
     */
<span class="fc" id="L85">    descId(ID_FIELD, false),</span>
    /**
     * By fileName, in ascending order.
     */
<span class="fc" id="L89">    ascFile(ORIGINAL_NAME_FIELD, true),</span>
    /**
     * By fileName, in descending order.
     */
<span class="fc" id="L93">    descFile(ORIGINAL_NAME_FIELD, false),</span>
    /**
     * By starting date, in ascending order.
     */
<span class="fc" id="L97">    ascStart(TRANSFER_START_FIELD, true),</span>
    /**
     * By starting date, in descending order.
     */
<span class="fc" id="L101">    descStart(TRANSFER_START_FIELD, false),</span>
    /**
     * By end date, in ascending order.
     */
<span class="fc" id="L105">    ascStop(TRANSFER_STOP_FIELD, true),</span>
    /**
     * By end date, in descending order.
     */
<span class="fc" id="L109">    descStop(TRANSFER_STOP_FIELD, false);</span>

    /**
     * The name of the database column used for sorting.
     */
    public final String column;
    /**
     * If the order is ascending or descending.
     */
    public final boolean ascend;

<span class="fc" id="L120">    Order(final String column, final boolean ascend) {</span>
<span class="fc" id="L121">      this.column = column;</span>
<span class="fc" id="L122">      this.ascend = ascend;</span>
<span class="fc" id="L123">    }</span>
  }

  // ########################## PUBLIC METHODS ################################

  /**
   * Returns an {@link ObjectNode} representing the {@link Transfer} object
   * given as parameter.
   *
   * @param transfer the Transfer object to serialize
   *
   * @return the corresponding ObjectNode
   */
  public static ObjectNode transferToNode(final Transfer transfer) {
<span class="fc" id="L137">    final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="fc" id="L138">    node.put(TRANSFER_ID, transfer.getId());</span>
<span class="fc" id="L139">    node.put(GLOBAL_STEP, transfer.getGlobalStep().toString());</span>
<span class="fc" id="L140">    node.put(GLOBAL_LAST_STEP, transfer.getLastGlobalStep().toString());</span>
<span class="fc" id="L141">    node.put(STEP, transfer.getStep());</span>
<span class="fc" id="L142">    node.put(RANK, transfer.getRank());</span>
<span class="fc" id="L143">    node.put(UPDATED_INFO, transfer.getUpdatedInfo().toString());</span>
<span class="fc" id="L144">    node.put(STEP_STATUS, transfer.getStepStatus().toString());</span>
<span class="fc" id="L145">    node.put(ERROR_CODE, transfer.getInfoStatus().code);</span>
<span class="fc" id="L146">    node.put(ERROR_MESSAGE, transfer.getInfoStatus().getMesg());</span>
<span class="fc" id="L147">    node.put(ORIGINAL_FILENAME, transfer.getOriginalName());</span>
<span class="fc" id="L148">    node.put(FILENAME, transfer.getFilename());</span>
<span class="fc" id="L149">    node.put(RULE, transfer.getRule());</span>
<span class="fc" id="L150">    node.put(BLOCK_SIZE, transfer.getBlockSize());</span>
<span class="fc" id="L151">    node.put(FILE_INFO, transfer.getFileInfo());</span>
<span class="fc" id="L152">    node.put(TRANSFER_INFO, transfer.getTransferInfo());</span>
<span class="fc" id="L153">    node.put(START, new DateTime(transfer.getStart()).toString());</span>
<span class="fc" id="L154">    node.put(STOP, new DateTime(transfer.getStop()).toString());</span>
<span class="fc" id="L155">    node.put(REQUESTED, transfer.getRequested());</span>
<span class="fc" id="L156">    node.put(REQUESTER, transfer.getRequester());</span>
<span class="fc" id="L157">    node.put(RETRIEVE, transfer.getRetrieveMode());</span>

<span class="fc" id="L159">    return node;</span>
  }

  /**
   * Initialize a {@link Transfer} object using the values of the given {@link
   * ObjectNode}.
   *
   * @param object the ObjectNode to convert
   *
   * @return the new Transfer object
   *
   * @throws RestErrorException if the given ObjectNode does not
   *     represent a Transfer object
   * @throws InternalServerErrorException if an unexpected error
   *     occurred
   */
  public static Transfer nodeToNewTransfer(final ObjectNode object) {
<span class="nc" id="L176">    Transfer defaultTransfer = null;</span>
    try {
<span class="nc" id="L178">      defaultTransfer =</span>
          new Transfer(null, null, -1, false, null, null, ZERO_COPY_CHUNK_SIZE);
<span class="nc" id="L180">    } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L181">      SysErrLogger.FAKE_LOGGER.syserr(e);</span>
<span class="nc" id="L182">      throw new IllegalArgumentException(e);</span>
<span class="nc" id="L183">    }</span>
<span class="nc" id="L184">    defaultTransfer.setRequester(serverName());</span>
<span class="nc" id="L185">    defaultTransfer.setOwnerRequest(serverName());</span>
<span class="nc" id="L186">    defaultTransfer.setBlockSize(Configuration.configuration.getBlockSize());</span>
<span class="nc" id="L187">    defaultTransfer.setTransferInfo(&quot;{}&quot;);</span>
<span class="nc" id="L188">    defaultTransfer.setStart(new Timestamp(DateTime.now().getMillis()));</span>
<span class="nc" id="L189">    final Transfer transfer = parseNode(object, defaultTransfer);</span>

    ModeTrans mode;
<span class="nc" id="L192">    RuleDAO ruleDAO = null;</span>
    try {
<span class="nc" id="L194">      ruleDAO = DAO_FACTORY.getRuleDAO(true);</span>
<span class="nc" id="L195">      final Rule rule = ruleDAO.select(transfer.getRule());</span>
<span class="nc" id="L196">      mode = ModeTrans.fromCode(rule.getMode());</span>
<span class="nc" id="L197">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L198">      throw new InternalServerErrorException(e);</span>
<span class="nc" id="L199">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L200">      throw new InternalServerErrorException(e);</span>
    } finally {
<span class="nc" id="L202">      DAOFactory.closeDAO(ruleDAO);</span>
    }

<span class="nc bnc" id="L205" title="All 4 branches missed.">    transfer.setRetrieveMode(</span>
        mode == ModeTrans.receive || mode == ModeTrans.receiveMD5);
<span class="nc" id="L207">    transfer.setTransferMode(mode.code);</span>
<span class="nc" id="L208">    transfer.setStop(transfer.getStart());</span>
<span class="nc" id="L209">    transfer.setUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>

<span class="nc" id="L211">    return transfer;</span>
  }

  // ######################### PRIVATE METHODS ################################

  /**
   * Tells if the given rule exists in the database.
   *
   * @param rule the name of the rule
   *
   * @return {@code true} if the rule exists, {@code false} otherwise.
   */
  private static boolean ruleExists(final String rule) {
<span class="nc" id="L224">    RuleDAO ruleDAO = null;</span>
    try {
<span class="nc" id="L226">      ruleDAO = DAO_FACTORY.getRuleDAO(true);</span>
<span class="nc" id="L227">      return ruleDAO.exist(rule);</span>
<span class="nc" id="L228">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L229">      throw new InternalServerErrorException(e);</span>
    } finally {
<span class="nc" id="L231">      DAOFactory.closeDAO(ruleDAO);</span>
    }
  }

  /**
   * Tells if the given host exists in the database.
   *
   * @param host the name of the host
   *
   * @return {@code true} if the host exists, {@code false} otherwise.
   */
  private static boolean hostExists(final String host) {
<span class="nc" id="L243">    HostDAO hostDAO = null;</span>
    try {
<span class="nc" id="L245">      hostDAO = DAO_FACTORY.getHostDAO(true);</span>
<span class="nc" id="L246">      return hostDAO.exist(host);</span>
<span class="nc" id="L247">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L248">      throw new InternalServerErrorException(e);</span>
    } finally {
<span class="nc" id="L250">      DAOFactory.closeDAO(hostDAO);</span>
    }
  }

  /**
   * Tells if the given host is allowed to use given rule.
   *
   * @param host the name of the host
   * @param rule the name of the rule
   *
   * @return {@code true} if the host is allowed to use the rule, {@code
   *     false} otherwise
   */
  private static boolean canUseRule(final String host, final String rule) {
<span class="nc" id="L264">    RuleDAO ruleDAO = null;</span>
    try {
<span class="nc" id="L266">      ruleDAO = DAO_FACTORY.getRuleDAO(true);</span>
<span class="nc" id="L267">      final List&lt;String&gt; hostIds = ruleDAO.select(rule).getHostids();</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">      return !hostIds.isEmpty() &amp;&amp; !hostIds.contains(host);</span>
<span class="nc" id="L269">    } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L270">      throw new InternalServerErrorException(e);</span>
<span class="nc" id="L271">    } catch (final DAONoDataException e) {</span>
<span class="nc" id="L272">      throw new InternalServerErrorException(e);</span>
    } finally {
<span class="nc" id="L274">      DAOFactory.closeDAO(ruleDAO);</span>
    }
  }

  /**
   * Returns a list of {@link RestError} corresponding to all the fields
   * required to initialize a transfer that
   * are missing from the given {@link Transfer} object. If no fields are
   * missing, an empty list is returned.
   *
   * @param transfer the Transfer object to check.
   *
   * @return the list of all missing fields
   */
  private static List&lt;RestError&gt; checkRequiredFields(final Transfer transfer) {
<span class="nc" id="L289">    final List&lt;RestError&gt; errors = new ArrayList&lt;RestError&gt;();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (ParametersChecker.isEmpty(transfer.getRule())) {</span>
<span class="nc" id="L291">      errors.add(MISSING_FIELD(RULE));</span>
    }
<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (ParametersChecker.isEmpty(transfer.getOriginalName())) {</span>
<span class="nc" id="L294">      errors.add(MISSING_FIELD(FILENAME));</span>
    }
<span class="nc bnc" id="L296" title="All 2 branches missed.">    if (ParametersChecker.isEmpty(transfer.getRequested())) {</span>
<span class="nc" id="L297">      errors.add(MISSING_FIELD(REQUESTED));</span>
    }

<span class="nc" id="L300">    return errors;</span>
  }

  /**
   * Fills the fields of the given {@link Transfer} object with the values
   * extracted from the {@link ObjectNode}
   * parameter, and returns the result.
   *
   * @param object the ObjectNode from which the values should be
   *     extracted
   * @param transfer the Transfer object whose fields will be filled
   *
   * @return the filled Transfer object
   *
   * @throws RestErrorException if the given ObjectNode does not
   *     represent a Transfer object.
   */
  private static Transfer parseNode(final ObjectNode object,
                                    final Transfer transfer) {
<span class="nc" id="L319">    final List&lt;RestError&gt; errors = new ArrayList&lt;RestError&gt;();</span>

<span class="nc" id="L321">    final Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = object.fields();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">    while (fields.hasNext()) {</span>
<span class="nc" id="L323">      final Map.Entry&lt;String, JsonNode&gt; field = fields.next();</span>
<span class="nc" id="L324">      final String name = field.getKey();</span>
<span class="nc" id="L325">      final JsonNode value = field.getValue();</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">      if (name.equalsIgnoreCase(RULE)) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (value.isTextual()) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">          if (ruleExists(value.asText())) {</span>
<span class="nc" id="L330">            transfer.setRule(value.asText());</span>
          } else {
<span class="nc" id="L332">            errors.add(UNKNOWN_RULE(value.asText()));</span>
          }
        } else {
<span class="nc" id="L335">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L337" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(FILENAME)) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (value.isTextual()) {</span>
<span class="nc" id="L339">          transfer.setOriginalName(value.asText());</span>
<span class="nc" id="L340">          transfer.setFilename(value.asText());</span>
        } else {
<span class="nc" id="L342">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(REQUESTED)) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (value.isTextual()) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">          if (hostExists(value.asText())) {</span>
<span class="nc" id="L347">            transfer.setRequested(value.asText());</span>
            try {
<span class="nc" id="L349">              transfer.setRequester(</span>
<span class="nc" id="L350">                  Configuration.configuration.getHostId(value.asText()));</span>
<span class="nc" id="L351">            } catch (final WaarpDatabaseException e) {</span>
              // Ignore !!
<span class="nc" id="L353">            }</span>
          } else {
<span class="nc" id="L355">            errors.add(UNKNOWN_HOST(value.asText()));</span>
          }
        } else {
<span class="nc" id="L358">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L360" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(BLOCK_SIZE)) {</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (value.canConvertToInt() &amp;&amp; value.asInt() &gt; 0) {</span>
<span class="nc" id="L362">          transfer.setBlockSize(value.asInt());</span>
        } else {
<span class="nc" id="L364">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L366" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(FILE_INFO)) {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (value.isTextual()) {</span>
<span class="nc" id="L368">          transfer.setFileInfo(value.asText());</span>
        } else {
<span class="nc" id="L370">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L372" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(TRANSFER_INFO)) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (value.isTextual()) {</span>
<span class="nc" id="L374">          transfer.setTransferInfo(value.asText());</span>
        } else {
<span class="nc" id="L376">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
<span class="nc bnc" id="L378" title="All 2 branches missed.">      } else if (name.equalsIgnoreCase(START)) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (value.isTextual()) {</span>
          try {
<span class="nc" id="L381">            final DateTime start = DateTime.parse(value.asText());</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (start.isBeforeNow()) {</span>
<span class="nc" id="L383">              errors.add(ILLEGAL_FIELD_VALUE(name, value.asText()));</span>
            } else {
<span class="nc" id="L385">              transfer.setStart(new Timestamp(start.getMillis()));</span>
            }
<span class="nc" id="L387">          } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L388">            errors.add(ILLEGAL_FIELD_VALUE(name, value.asText()));</span>
<span class="nc" id="L389">          }</span>
        } else {
<span class="nc" id="L391">          errors.add(ILLEGAL_FIELD_VALUE(name, value.toString()));</span>
        }
      }
<span class="nc" id="L394">    }</span>

    // check that both hosts are allowed to use the transfer rule
<span class="nc" id="L397">    final String rule = transfer.getRule();</span>
<span class="nc" id="L398">    final String requested = transfer.getRequested();</span>
<span class="nc" id="L399">    final String requester = transfer.getRequester();</span>
<span class="nc bnc" id="L400" title="All 6 branches missed.">    if (rule != null &amp;&amp; !requested.isEmpty() &amp;&amp; canUseRule(requested, rule)) {</span>
<span class="nc" id="L401">      errors.add(RULE_NOT_ALLOWED(requested, rule));</span>
    }
<span class="nc bnc" id="L403" title="All 6 branches missed.">    if (rule != null &amp;&amp; !requester.isEmpty() &amp;&amp; canUseRule(requester, rule)) {</span>
<span class="nc" id="L404">      errors.add(RULE_NOT_ALLOWED(requester, rule));</span>
    }

<span class="nc" id="L407">    errors.addAll(checkRequiredFields(transfer));</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">    if (errors.isEmpty()) {</span>
<span class="nc" id="L410">      return transfer;</span>
    } else {
<span class="nc" id="L412">      throw new RestErrorException(errors);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>