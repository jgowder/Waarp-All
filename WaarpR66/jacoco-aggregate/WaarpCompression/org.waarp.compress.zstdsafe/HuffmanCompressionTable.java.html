<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HuffmanCompressionTable.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdsafe</a> &gt; <span class="el_source">HuffmanCompressionTable.java</span></div><h1>HuffmanCompressionTable.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdsafe;

import java.util.Arrays;

import static org.waarp.compress.zstdsafe.Huffman.*;
import static org.waarp.compress.zstdsafe.Util.*;

final class HuffmanCompressionTable {
  private final short[] values;
  private final byte[] numberOfBits;

  private int maxSymbol;
  private int maxNumberOfBits;

<span class="fc" id="L48">  public HuffmanCompressionTable(final int capacity) {</span>
<span class="fc" id="L49">    this.values = new short[capacity];</span>
<span class="fc" id="L50">    this.numberOfBits = new byte[capacity];</span>
<span class="fc" id="L51">  }</span>

  public static int optimalNumberOfBits(final int maxNumberOfBits,
                                        final int inputSize,
                                        final int maxSymbol) {
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">    if (inputSize &lt;= 1) {</span>
<span class="nc" id="L57">      throw new IllegalArgumentException(); // not supported. Use RLE instead</span>
    }

<span class="fc" id="L60">    int result = maxNumberOfBits;</span>

<span class="fc" id="L62">    result = Math.min(result, Util.highestBit((inputSize - 1)) -</span>
                              1); // we may be able to reduce accuracy if input is small

    // Need a minimum to safely represent all symbol values
<span class="fc" id="L66">    result = Math.max(result, minTableLog(inputSize, maxSymbol));</span>

<span class="fc" id="L68">    result = Math.max(result, MIN_TABLE_LOG); // absolute minimum for Huffman</span>
<span class="fc" id="L69">    result = Math.min(result, MAX_TABLE_LOG); // absolute maximum for Huffman</span>

<span class="fc" id="L71">    return result;</span>
  }

  public void initialize(final int[] counts, final int maxSymbol,
                         int maxNumberOfBits,
                         final HuffmanCompressionTableWorkspace workspace) {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">    checkArgument(maxSymbol &lt;= MAX_SYMBOL, &quot;Max symbol value too large&quot;);</span>

<span class="fc" id="L79">    workspace.reset();</span>

<span class="fc" id="L81">    final NodeTable nodeTable = workspace.nodeTable;</span>
<span class="fc" id="L82">    nodeTable.reset();</span>

<span class="fc" id="L84">    final int lastNonZero = buildTree(counts, maxSymbol, nodeTable);</span>

    // enforce max table log
<span class="fc" id="L87">    maxNumberOfBits =</span>
<span class="fc" id="L88">        setMaxHeight(nodeTable, lastNonZero, maxNumberOfBits, workspace);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    checkArgument(maxNumberOfBits &lt;= MAX_TABLE_LOG,</span>
                  &quot;Max number of bits larger than max table size&quot;);

    // populate table
<span class="fc" id="L93">    final int symbolCount = maxSymbol + 1;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">    for (int node = 0; node &lt; symbolCount; node++) {</span>
<span class="fc" id="L95">      final int symbol = nodeTable.symbols[node];</span>
<span class="fc" id="L96">      numberOfBits[symbol] = nodeTable.numberOfBits[node];</span>
    }

<span class="fc" id="L99">    final short[] entriesPerRank = workspace.entriesPerRank;</span>
<span class="fc" id="L100">    final short[] valuesPerRank = workspace.valuesPerRank;</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">    for (int n = 0; n &lt;= lastNonZero; n++) {</span>
<span class="fc" id="L103">      entriesPerRank[nodeTable.numberOfBits[n]]++;</span>
    }

    // determine starting value per rank
<span class="fc" id="L107">    short startingValue = 0;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">    for (int rank = maxNumberOfBits; rank &gt; 0; rank--) {</span>
<span class="fc" id="L109">      valuesPerRank[rank] =</span>
          startingValue; // get starting value within each rank
<span class="fc" id="L111">      startingValue += entriesPerRank[rank];</span>
<span class="fc" id="L112">      startingValue &gt;&gt;&gt;= 1;</span>
    }

<span class="fc bfc" id="L115" title="All 2 branches covered.">    for (int n = 0; n &lt;= maxSymbol; n++) {</span>
<span class="fc" id="L116">      values[n] =</span>
          valuesPerRank[numberOfBits[n]]++; // assign value within rank, symbol order
    }

<span class="fc" id="L120">    this.maxSymbol = maxSymbol;</span>
<span class="fc" id="L121">    this.maxNumberOfBits = maxNumberOfBits;</span>
<span class="fc" id="L122">  }</span>

  private int buildTree(final int[] counts, final int maxSymbol,
                        final NodeTable nodeTable) {
    // populate the leaves of the node table from the histogram of counts
    // in descending order by count, ascending by symbol value.
<span class="fc" id="L128">    short current = 0;</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">    for (int symbol = 0; symbol &lt;= maxSymbol; symbol++) {</span>
<span class="fc" id="L131">      final int count = counts[symbol];</span>

      // simple insertion sort
<span class="fc" id="L134">      int position = current;</span>
<span class="fc bfc" id="L135" title="All 4 branches covered.">      while (position &gt; 1 &amp;&amp; count &gt; nodeTable.count[position - 1]) {</span>
<span class="fc" id="L136">        nodeTable.copyNode(position - 1, position);</span>
<span class="fc" id="L137">        position--;</span>
      }

<span class="fc" id="L140">      nodeTable.count[position] = count;</span>
<span class="fc" id="L141">      nodeTable.symbols[position] = symbol;</span>

<span class="fc" id="L143">      current++;</span>
    }

<span class="fc" id="L146">    int lastNonZero = maxSymbol;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">    while (nodeTable.count[lastNonZero] == 0) {</span>
<span class="fc" id="L148">      lastNonZero--;</span>
    }

    // populate the non-leaf nodes
<span class="fc" id="L152">    final short nonLeafStart = MAX_SYMBOL_COUNT;</span>
<span class="fc" id="L153">    current = nonLeafStart;</span>

<span class="fc" id="L155">    int currentLeaf = lastNonZero;</span>

    // combine the two smallest leaves to create the first intermediate node
<span class="fc" id="L158">    int currentNonLeaf = current;</span>
<span class="fc" id="L159">    nodeTable.count[current] =</span>
        nodeTable.count[currentLeaf] + nodeTable.count[currentLeaf - 1];
<span class="fc" id="L161">    nodeTable.parents[currentLeaf] = current;</span>
<span class="fc" id="L162">    nodeTable.parents[currentLeaf - 1] = current;</span>
<span class="fc" id="L163">    current++;</span>
<span class="fc" id="L164">    currentLeaf -= 2;</span>

<span class="fc" id="L166">    final int root = MAX_SYMBOL_COUNT + lastNonZero - 1;</span>

    // fill in sentinels
<span class="fc bfc" id="L169" title="All 2 branches covered.">    for (int n = current; n &lt;= root; n++) {</span>
<span class="fc" id="L170">      nodeTable.count[n] = 1 &lt;&lt; 30;</span>
    }

    // create parents
<span class="fc bfc" id="L174" title="All 2 branches covered.">    while (current &lt;= root) {</span>
      final int child1;
<span class="fc bfc" id="L176" title="All 4 branches covered.">      if (currentLeaf &gt;= 0 &amp;&amp;</span>
          nodeTable.count[currentLeaf] &lt; nodeTable.count[currentNonLeaf]) {
<span class="fc" id="L178">        child1 = currentLeaf--;</span>
      } else {
<span class="fc" id="L180">        child1 = currentNonLeaf++;</span>
      }

      final int child2;
<span class="fc bfc" id="L184" title="All 4 branches covered.">      if (currentLeaf &gt;= 0 &amp;&amp;</span>
          nodeTable.count[currentLeaf] &lt; nodeTable.count[currentNonLeaf]) {
<span class="fc" id="L186">        child2 = currentLeaf--;</span>
      } else {
<span class="fc" id="L188">        child2 = currentNonLeaf++;</span>
      }

<span class="fc" id="L191">      nodeTable.count[current] =</span>
          nodeTable.count[child1] + nodeTable.count[child2];
<span class="fc" id="L193">      nodeTable.parents[child1] = current;</span>
<span class="fc" id="L194">      nodeTable.parents[child2] = current;</span>
<span class="fc" id="L195">      current++;</span>
<span class="fc" id="L196">    }</span>

    // distribute weights
<span class="fc" id="L199">    nodeTable.numberOfBits[root] = 0;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">    for (int n = root - 1; n &gt;= nonLeafStart; n--) {</span>
<span class="fc" id="L201">      final short parent = nodeTable.parents[n];</span>
<span class="fc" id="L202">      nodeTable.numberOfBits[n] = (byte) (nodeTable.numberOfBits[parent] + 1);</span>
    }

<span class="fc bfc" id="L205" title="All 2 branches covered.">    for (int n = 0; n &lt;= lastNonZero; n++) {</span>
<span class="fc" id="L206">      final short parent = nodeTable.parents[n];</span>
<span class="fc" id="L207">      nodeTable.numberOfBits[n] = (byte) (nodeTable.numberOfBits[parent] + 1);</span>
    }

<span class="fc" id="L210">    return lastNonZero;</span>
  }

  // TODO: consider encoding 2 symbols at a time
  //   - need a table with 256x256 entries with
  //      - the concatenated bits for the corresponding pair of symbols
  //      - the sum of bits for the corresponding pair of symbols
  //   - read 2 symbols at a time from the input
  public void encodeSymbol(final BitOutputStream output, final int symbol) {
<span class="fc" id="L219">    output.addBitsFast(values[symbol], numberOfBits[symbol]);</span>
<span class="fc" id="L220">  }</span>

  public int write(final byte[] outputBase, final int outputAddress,
                   final int outputSize,
                   final HuffmanTableWriterWorkspace workspace) {
<span class="fc" id="L225">    final byte[] weights = workspace.weights;</span>

<span class="fc" id="L227">    int output = outputAddress;</span>

<span class="fc" id="L229">    final int maxNumberOfBits1 = this.maxNumberOfBits;</span>
<span class="fc" id="L230">    final int maxSymbol1 = this.maxSymbol;</span>

    // convert to weights per RFC 8478 section 4.2.1
<span class="fc bfc" id="L233" title="All 2 branches covered.">    for (int symbol = 0; symbol &lt; maxSymbol1; symbol++) {</span>
<span class="fc" id="L234">      final int bits = numberOfBits[symbol];</span>

<span class="fc bfc" id="L236" title="All 2 branches covered.">      if (bits == 0) {</span>
<span class="fc" id="L237">        weights[symbol] = 0;</span>
      } else {
<span class="fc" id="L239">        weights[symbol] = (byte) (maxNumberOfBits1 + 1 - bits);</span>
      }
    }

    // attempt weights compression by FSE
<span class="fc" id="L244">    int size = compressWeights(outputBase, output + 1, outputSize - 1, weights,</span>
                               maxSymbol1, workspace);

<span class="pc bpc" id="L247" title="1 of 4 branches missed.">    if (maxSymbol1 &gt; 127 &amp;&amp; size &gt; 127) {</span>
      // This should never happen. Since weights are in the range [0, 12], they can be compressed optimally to ~3.7 bits per symbol for a uniform distribution.
      // Since maxSymbol has to be &lt;= MAX_SYMBOL (255), this is 119 bytes + FSE headers.
<span class="nc" id="L250">      throw new AssertionError();</span>
    }

<span class="pc bpc" id="L253" title="2 of 6 branches missed.">    if (size != 0 &amp;&amp; size != 1 &amp;&amp; size &lt; maxSymbol1 / 2) {</span>
      // Go with FSE only if:
      //   - the weights are compressible
      //   - the compressed size is better than what we'd get with the raw encoding below
      //   - the compressed size is &lt;= 127 bytes, which is the most that the encoding can hold for FSE-compressed weights (see RFC 8478 section 4.2.1.1). This is implied
      //     by the maxSymbol / 2 check, since maxSymbol must be &lt;= 255
<span class="fc" id="L259">      outputBase[output] = (byte) size;</span>
<span class="fc" id="L260">      return size + 1; // header + size</span>
    } else {
      // Use raw encoding (4 bits per entry)

      // #entries = #symbols - 1 since last symbol is implicit. Thus, #entries = (maxSymbol + 1) - 1 = maxSymbol

<span class="fc" id="L266">      size = (maxSymbol1 + 1) / 2;  // ceil(#entries / 2)</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">      checkArgument(size + 1 /* header */ &lt;= outputSize,</span>
                    &quot;Output size too small&quot;); // 2 entries per byte

      // encode number of symbols
      // header = #entries + 127 per RFC
<span class="fc" id="L272">      outputBase[output] = (byte) (127 + maxSymbol1);</span>
<span class="fc" id="L273">      output++;</span>

<span class="fc" id="L275">      weights[maxSymbol1] =</span>
          0; // last weight is implicit, so set to 0 so that it doesn't get encoded below
<span class="fc bfc" id="L277" title="All 2 branches covered.">      for (int i = 0; i &lt; maxSymbol1; i += 2) {</span>
<span class="fc" id="L278">        outputBase[output] = (byte) ((weights[i] &lt;&lt; 4) + weights[i + 1]);</span>
<span class="fc" id="L279">        output++;</span>
      }

<span class="fc" id="L282">      return output - outputAddress;</span>
    }
  }

  /**
   * Can this table encode all symbols with non-zero count?
   */
  public boolean isValid(final int[] counts, final int maxSymbol) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">    if (maxSymbol &gt; this.maxSymbol) {</span>
      // some non-zero count symbols cannot be encoded by the current table
<span class="fc" id="L292">      return false;</span>
    }

<span class="fc bfc" id="L295" title="All 2 branches covered.">    for (int symbol = 0; symbol &lt;= maxSymbol; ++symbol) {</span>
<span class="fc bfc" id="L296" title="All 4 branches covered.">      if (counts[symbol] != 0 &amp;&amp; numberOfBits[symbol] == 0) {</span>
<span class="fc" id="L297">        return false;</span>
      }
    }
<span class="fc" id="L300">    return true;</span>
  }

  public int estimateCompressedSize(final int[] counts, final int maxSymbol) {
<span class="fc" id="L304">    int numberOfBits = 0;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (int symbol = 0; symbol &lt;= Math.min(maxSymbol, this.maxSymbol);</span>
<span class="fc" id="L306">         symbol++) {</span>
<span class="fc" id="L307">      numberOfBits += this.numberOfBits[symbol] * counts[symbol];</span>
    }

<span class="fc" id="L310">    return numberOfBits &gt;&gt;&gt; 3; // convert to bytes</span>
  }

  // http://fastcompression.blogspot.com/2015/07/huffman-revisited-part-3-depth-limited.html
  private static int setMaxHeight(final NodeTable nodeTable,
                                  final int lastNonZero,
                                  final int maxNumberOfBits,
                                  final HuffmanCompressionTableWorkspace workspace) {
<span class="fc" id="L318">    final int largestBits = nodeTable.numberOfBits[lastNonZero];</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (largestBits &lt;= maxNumberOfBits) {</span>
<span class="fc" id="L321">      return largestBits;   // early exit: no elements &gt; maxNumberOfBits</span>
    }

    // there are several too large elements (at least &gt;= 2)
<span class="fc" id="L325">    int totalCost = 0;</span>
<span class="fc" id="L326">    final int baseCost = 1 &lt;&lt; (largestBits - maxNumberOfBits);</span>
<span class="fc" id="L327">    int n = lastNonZero;</span>

<span class="fc bfc" id="L329" title="All 2 branches covered.">    while (nodeTable.numberOfBits[n] &gt; maxNumberOfBits) {</span>
<span class="fc" id="L330">      totalCost += baseCost - (1 &lt;&lt; (largestBits - nodeTable.numberOfBits[n]));</span>
<span class="fc" id="L331">      nodeTable.numberOfBits[n] = (byte) maxNumberOfBits;</span>
<span class="fc" id="L332">      n--;</span>
    }  // n stops at nodeTable.numberOfBits[n + offset] &lt;= maxNumberOfBits

<span class="fc bfc" id="L335" title="All 2 branches covered.">    while (nodeTable.numberOfBits[n] == maxNumberOfBits) {</span>
<span class="fc" id="L336">      n--;   // n ends at index of smallest symbol using &lt; maxNumberOfBits</span>
    }

    // renormalize totalCost
<span class="fc" id="L340">    totalCost &gt;&gt;&gt;= (largestBits -</span>
                    maxNumberOfBits);  // note: totalCost is necessarily a multiple of baseCost

    // repay normalized cost
<span class="fc" id="L344">    final int noSymbol = 0xF0F0F0F0;</span>
<span class="fc" id="L345">    final int[] rankLast = workspace.rankLast;</span>
<span class="fc" id="L346">    Arrays.fill(rankLast, noSymbol);</span>

    // Get pos of last (smallest) symbol per rank
<span class="fc" id="L349">    int currentNbBits = maxNumberOfBits;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">    for (int pos = n; pos &gt;= 0; pos--) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">      if (nodeTable.numberOfBits[pos] &gt;= currentNbBits) {</span>
<span class="fc" id="L352">        continue;</span>
      }
<span class="fc" id="L354">      currentNbBits = nodeTable.numberOfBits[pos];   // &lt; maxNumberOfBits</span>
<span class="fc" id="L355">      rankLast[maxNumberOfBits - currentNbBits] = pos;</span>
    }

<span class="fc bfc" id="L358" title="All 2 branches covered.">    while (totalCost &gt; 0) {</span>
<span class="fc" id="L359">      int numberOfBitsToDecrease = Util.highestBit(totalCost) + 1;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">      for (; numberOfBitsToDecrease &gt; 1; numberOfBitsToDecrease--) {</span>
<span class="fc" id="L361">        final int highPosition = rankLast[numberOfBitsToDecrease];</span>
<span class="fc" id="L362">        final int lowPosition = rankLast[numberOfBitsToDecrease - 1];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (highPosition == noSymbol) {</span>
<span class="fc" id="L364">          continue;</span>
        }
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (lowPosition == noSymbol) {</span>
<span class="fc" id="L367">          break;</span>
        }
<span class="fc" id="L369">        final int highTotal = nodeTable.count[highPosition];</span>
<span class="fc" id="L370">        final int lowTotal = 2 * nodeTable.count[lowPosition];</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (highTotal &lt;= lowTotal) {</span>
<span class="fc" id="L372">          break;</span>
        }
      }

      // only triggered when no more rank 1 symbol left =&gt; find closest one (note : there is necessarily at least one !)
      // HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary
<span class="pc bpc" id="L378" title="2 of 4 branches missed.">      while ((numberOfBitsToDecrease &lt;= MAX_TABLE_LOG) &amp;&amp;</span>
             (rankLast[numberOfBitsToDecrease] == noSymbol)) {
<span class="nc" id="L380">        numberOfBitsToDecrease++;</span>
      }
<span class="fc" id="L382">      totalCost -= 1 &lt;&lt; (numberOfBitsToDecrease - 1);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">      if (rankLast[numberOfBitsToDecrease - 1] == noSymbol) {</span>
<span class="fc" id="L384">        rankLast[numberOfBitsToDecrease - 1] =</span>
            rankLast[numberOfBitsToDecrease];   // this rank is no longer empty
      }
<span class="fc" id="L387">      nodeTable.numberOfBits[rankLast[numberOfBitsToDecrease]]++;</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">      if (rankLast[numberOfBitsToDecrease] ==</span>
          0) {   /* special case, reached largest symbol */
<span class="nc" id="L390">        rankLast[numberOfBitsToDecrease] = noSymbol;</span>
      } else {
<span class="fc" id="L392">        rankLast[numberOfBitsToDecrease]--;</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (nodeTable.numberOfBits[rankLast[numberOfBitsToDecrease]] !=</span>
            maxNumberOfBits - numberOfBitsToDecrease) {
<span class="fc" id="L395">          rankLast[numberOfBitsToDecrease] =</span>
              noSymbol;   // this rank is now empty
        }
      }
<span class="fc" id="L399">    }</span>

<span class="pc bpc" id="L401" title="1 of 2 branches missed.">    while (totalCost &lt; 0) {  // Sometimes, cost correction overshoot</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">      if (rankLast[1] ==</span>
          noSymbol) {  /* special case : no rank 1 symbol (using maxNumberOfBits-1); let's create one from largest rank 0 (using maxNumberOfBits) */
<span class="nc bnc" id="L404" title="All 2 branches missed.">        while (nodeTable.numberOfBits[n] == maxNumberOfBits) {</span>
<span class="nc" id="L405">          n--;</span>
        }
<span class="nc" id="L407">        nodeTable.numberOfBits[n + 1]--;</span>
<span class="nc" id="L408">        rankLast[1] = n + 1;</span>
<span class="nc" id="L409">        totalCost++;</span>
<span class="nc" id="L410">        continue;</span>
      }
<span class="nc" id="L412">      nodeTable.numberOfBits[rankLast[1] + 1]--;</span>
<span class="nc" id="L413">      rankLast[1]++;</span>
<span class="nc" id="L414">      totalCost++;</span>
    }

<span class="fc" id="L417">    return maxNumberOfBits;</span>
  }

  /**
   * All elements within weightTable must be &lt;= Huffman.MAX_TABLE_LOG
   */
  private static int compressWeights(final byte[] outputBase,
                                     final int outputAddress,
                                     final int outputSize, final byte[] weights,
                                     final int weightsLength,
                                     final HuffmanTableWriterWorkspace workspace) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    if (weightsLength &lt;= 1) {</span>
<span class="nc" id="L429">      return 0; // Not compressible</span>
    }

    // Scan input and build symbol stats
<span class="fc" id="L433">    final int[] counts = workspace.counts;</span>
<span class="fc" id="L434">    Histogram.count(weights, weightsLength, counts);</span>
<span class="fc" id="L435">    final int maxSymbol = Histogram.findMaxSymbol(counts, MAX_TABLE_LOG);</span>
<span class="fc" id="L436">    final int maxCount = Histogram.findLargestCount(counts, maxSymbol);</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">    if (maxCount == weightsLength) {</span>
<span class="fc" id="L439">      return 1; // only a single symbol in source</span>
    }
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">    if (maxCount == 1) {</span>
<span class="nc" id="L442">      return 0; // each symbol present maximum once =&gt; not compressible</span>
    }

<span class="fc" id="L445">    final short[] normalizedCounts = workspace.normalizedCounts;</span>

<span class="fc" id="L447">    final int tableLog =</span>
<span class="fc" id="L448">        FiniteStateEntropy.optimalTableLog(MAX_FSE_TABLE_LOG, weightsLength,</span>
                                           maxSymbol);
<span class="fc" id="L450">    FiniteStateEntropy.normalizeCounts(normalizedCounts, tableLog, counts,</span>
                                       weightsLength, maxSymbol);

<span class="fc" id="L453">    int output = outputAddress;</span>
<span class="fc" id="L454">    final int outputLimit = outputAddress + outputSize;</span>

    // Write table description header
<span class="fc" id="L457">    final int headerSize =</span>
<span class="fc" id="L458">        FiniteStateEntropy.writeNormalizedCounts(outputBase, output, outputSize,</span>
                                                 normalizedCounts, maxSymbol,
                                                 tableLog);
<span class="fc" id="L461">    output += headerSize;</span>

    // Compress
<span class="fc" id="L464">    final FseCompressionTable compressionTable = workspace.fseTable;</span>
<span class="fc" id="L465">    compressionTable.initialize(normalizedCounts, maxSymbol, tableLog);</span>
<span class="fc" id="L466">    final int compressedSize =</span>
<span class="fc" id="L467">        FiniteStateEntropy.compress(outputBase, output, outputLimit - output,</span>
                                    weights, weightsLength, compressionTable);
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">    if (compressedSize == 0) {</span>
<span class="nc" id="L470">      return 0;</span>
    }
<span class="fc" id="L472">    output += compressedSize;</span>

<span class="fc" id="L474">    return output - outputAddress;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>