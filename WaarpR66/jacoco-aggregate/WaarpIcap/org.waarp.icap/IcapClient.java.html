<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>IcapClient.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp OpenR66</a> &gt; <a href="../index.html" class="el_bundle">WaarpIcap</a> &gt; <a href="index.source.html" class="el_package">org.waarp.icap</a> &gt; <span class="el_source">IcapClient.java</span></div><h1>IcapClient.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.icap;

import com.google.common.io.Files;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;

import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ConnectException;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.net.URLEncoder;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import static org.waarp.common.file.filesystembased.FilesystemBasedFileImpl.*;

/**
 * The IcapClient allows to do 3 actions:&lt;/br&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;connect(): which allows to initialize the connection with the ICAP
 *   server&lt;/li&gt;
 *   &lt;li&gt;close(): forces the client to disconnect from the ICAP server&lt;/li&gt;
 *   &lt;li&gt;scanFile(path): send a file for a scan by the ICAP server&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/br&gt;
 * This code is inspired from 2 sources:&lt;/br&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;https://github.com/Baekalfen/ICAP-avscan&lt;/li&gt;
 *   &lt;li&gt;https://github.com/claudineyns/icap-client&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/br&gt;
 * This reflects the RFC 3507 and errata as of 2010/04/17.
 */
public class IcapClient implements Closeable {
  /**
   * Default ICAP port
   */
  public static final int DEFAULT_ICAP_PORT = 1344;
<span class="fc" id="L69">  private static final WaarpLogger logger =</span>
<span class="fc" id="L70">      WaarpLoggerFactory.getLogger(IcapClient.class);</span>

  static final int STD_RECEIVE_LENGTH = 64 * 1024;
  static final int STD_SEND_LENGTH = 8192;
  static final int DEFAULT_TIMEOUT = 10 * 60 * 60000;// 10 min
  public static final String VERSION = &quot;ICAP/1.0&quot;;
  private static final String USER_AGENT = &quot;Waarp ICAP Client/1.0&quot;;
  public static final String TERMINATOR = &quot;\r\n&quot;;
  public static final String ICAP_TERMINATOR = TERMINATOR + TERMINATOR;
  public static final String HTTP_TERMINATOR = &quot;0&quot; + TERMINATOR + TERMINATOR;
  private static final String STATUS_CODE = &quot;StatusCode&quot;;
  private static final String PREVIEW = &quot;Preview&quot;;
  private static final String OPTIONS = &quot;OPTIONS&quot;;
  private static final String HOST_HEADER = &quot;Host: &quot;;
  private static final String USER_AGENT_HEADER = &quot;User-Agent: &quot;;
  private static final String RESPMOD = &quot;RESPMOD&quot;;
  private static final String ENCAPSULATED_NULL_BODY =
      &quot;Encapsulated: null-body=0&quot;;
  static final int MINIMAL_SIZE = 100;
  private static final String GET_REQUEST = &quot;GET /&quot;;
  private static final String INCOMPATIBLE_ARGUMENT = &quot;Incompatible argument&quot;;
  private static final String TIMEOUT_OCCURS_WITH_THE_SERVER =
      &quot;Timeout occurs with the Server&quot;;
  private static final String TIMEOUT_OCCURS_WITH_THE_SERVER_SINCE =
      &quot;Timeout occurs with the Server {}:{} since {}&quot;;
  public static final String EICARTEST = &quot;EICARTEST&quot;;

  // Standard configuration
  private final String serverIP;
  private final int port;
  private final String icapService;
  private final int setPreviewSize;

  // Extra configuration
<span class="fc" id="L104">  private int receiveLength = STD_RECEIVE_LENGTH;</span>
<span class="fc" id="L105">  private int sendLength = STD_SEND_LENGTH;</span>
<span class="fc" id="L106">  private String keyIcapPreview = null;</span>
<span class="fc" id="L107">  private String subStringFromKeyIcapPreview = null;</span>
<span class="fc" id="L108">  private String substringHttpStatus200 = null;</span>
<span class="fc" id="L109">  private String keyIcap200 = null;</span>
<span class="fc" id="L110">  private String subStringFromKeyIcap200 = null;</span>
<span class="fc" id="L111">  private String keyIcap204 = null;</span>
<span class="fc" id="L112">  private String subStringFromKeyIcap204 = null;</span>
<span class="fc" id="L113">  private long maxSize = Integer.MAX_VALUE;</span>
<span class="fc" id="L114">  private int timeout = DEFAULT_TIMEOUT;</span>
<span class="fc" id="L115">  private int stdPreviewSize = -1;</span>

  // Accessibe data
<span class="fc" id="L118">  private Map&lt;String, String&gt; finalResult = null;</span>

  // Internal data
  private Socket client;
  private OutputStream out;
  InputStream in;
  private int offset;

  /**
   * This creates the ICAP client without connecting immediately to the ICAP
   * server. When the ICAP client will connect, it will ask for the preview
   * size to the ICAP Server.
   *
   * @param serverIP The IP address to connect to.
   * @param port The port in the host to use.
   * @param icapService The service to use (fx &quot;avscan&quot;).
   */
  public IcapClient(final String serverIP, final int port,
                    final String icapService) {
<span class="fc" id="L137">    this(serverIP, port, icapService, -1);</span>
<span class="fc" id="L138">  }</span>

  /**
   * This creates the ICAP client without connecting immediately to the ICAP
   * server. When the ICAP client will connect, it will not ask for the preview
   * size to the ICAP Server but uses the default specified value.
   *
   * @param serverIP The IP address to connect to.
   * @param port The port in the host to use.
   * @param icapService The service to use (fx &quot;avscan&quot;).
   * @param previewSize Amount of bytes to  send as preview.
   */
  public IcapClient(final String serverIP, final int port,
<span class="fc" id="L151">                    final String icapService, final int previewSize) {</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">    if (icapService == null || icapService.trim().isEmpty()) {</span>
<span class="fc" id="L153">      throw new IllegalArgumentException(&quot;IcapService must not be empty&quot;);</span>
    }
<span class="fc" id="L155">    this.icapService = icapService;</span>
<span class="fc bfc" id="L156" title="All 4 branches covered.">    if (serverIP == null || serverIP.trim().isEmpty()) {</span>
<span class="fc" id="L157">      throw new IllegalArgumentException(&quot;Server IP must not be empty&quot;);</span>
    }
<span class="fc" id="L159">    this.serverIP = serverIP;</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (port &lt;= 0) {</span>
<span class="fc" id="L161">      this.port = DEFAULT_ICAP_PORT;</span>
    } else {
<span class="fc" id="L163">      this.port = port;</span>
    }
<span class="fc" id="L165">    this.setPreviewSize = previewSize;</span>
<span class="fc" id="L166">    this.stdPreviewSize = Math.max(0, previewSize);</span>
<span class="fc" id="L167">  }</span>

  /**
   * Try to connect to the server and if the preview size is not specified,
   * it will also resolve the options of the ICAP server.&lt;/br&gt;
   *
   * If the client is still connected, it will first disconnect before
   * reconnecting to the ICAP Server.&lt;/br&gt;
   *
   * Note that every attempts of connection will retry to issue an OPTIONS
   * request if necessary (if preview size is not set to a fixed value already).
   *
   * @throws IcapException if an issue occurs during the connection or
   *     response (the connection is already closed)
   */
  public IcapClient connect() throws IcapException {
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (finalResult != null) {</span>
<span class="fc" id="L184">      finalResult.clear();</span>
<span class="fc" id="L185">      finalResult = null;</span>
    }
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (client != null) {</span>
<span class="fc" id="L188">      close();</span>
    }
<span class="fc" id="L190">    logger</span>
<span class="fc" id="L191">        .debug(&quot;Try connect to {}:{} service {}&quot;, serverIP, port, icapService);</span>
    try {
      // Initialize connection
<span class="fc" id="L194">      client = new Socket(serverIP, port);</span>
<span class="fc" id="L195">      client.setReuseAddress(true);</span>
<span class="fc" id="L196">      client.setKeepAlive(true);</span>
<span class="fc" id="L197">      client.setSoTimeout(timeout);</span>
<span class="fc" id="L198">      client.setTcpNoDelay(false);</span>
      // Opening out stream
<span class="fc" id="L200">      out = client.getOutputStream();</span>
      // Opening in stream
<span class="fc" id="L202">      in = client.getInputStream();</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">      if (setPreviewSize &lt; 0) {</span>
<span class="fc" id="L204">        getFromServerPreviewSize();</span>
      }
<span class="fc" id="L206">      logger.debug(&quot;Connected with Preview Size = {}&quot;, stdPreviewSize);</span>
<span class="fc" id="L207">      return this;</span>
<span class="nc" id="L208">    } catch (final SocketTimeoutException e) {</span>
<span class="nc" id="L209">      close();</span>
<span class="nc" id="L210">      logger.error(TIMEOUT_OCCURS_WITH_THE_SERVER_SINCE, serverIP, port,</span>
<span class="nc" id="L211">                   e.getMessage());</span>
<span class="nc" id="L212">      throw new IcapException(TIMEOUT_OCCURS_WITH_THE_SERVER, e,</span>
                              IcapError.ICAP_TIMEOUT_ERROR);
<span class="fc" id="L214">    } catch (final ConnectException e) {</span>
<span class="fc" id="L215">      close();</span>
<span class="fc" id="L216">      logger.error(&quot;Could not connect to server {}:{} since {}&quot;, serverIP, port,</span>
<span class="fc" id="L217">                   e.getMessage());</span>
<span class="fc" id="L218">      throw new IcapException(&quot;Could not connect with the server&quot;, e,</span>
                              IcapError.ICAP_CANT_CONNECT);
<span class="nc" id="L220">    } catch (final IOException e) {</span>
<span class="nc" id="L221">      close();</span>
<span class="nc" id="L222">      logger.error(&quot;Could not connect to server {}:{} since {}&quot;, serverIP, port,</span>
<span class="nc" id="L223">                   e.getMessage());</span>
<span class="nc" id="L224">      throw new IcapException(&quot;Could not connect with the server&quot;, e,</span>
                              IcapError.ICAP_NETWORK_ERROR);
<span class="fc" id="L226">    } catch (final IcapException e) {</span>
<span class="fc" id="L227">      close();</span>
<span class="fc" id="L228">      throw e;</span>
    }
  }

  /**
   * Get the Preview Size from the SERVER using ICAP OPTIONS command
   *
   * @throws IcapException
   */
  private void getFromServerPreviewSize() throws IcapException {
    // Check the preview size from the ICAP Server response to OPTIONS
<span class="fc" id="L239">    final String parseMe = getOptions();</span>
<span class="fc" id="L240">    finalResult = parseHeader(parseMe);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    if (checkAgainstIcapHeader(finalResult, STATUS_CODE, &quot;200&quot;, false)) {</span>
<span class="fc" id="L242">      final String tempString = finalResult.get(PREVIEW);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">      if (tempString != null) {</span>
<span class="fc" id="L244">        stdPreviewSize = Integer.parseInt(tempString);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (stdPreviewSize &lt; 0) {</span>
<span class="nc" id="L246">          stdPreviewSize = 0;</span>
        }
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (!checkAgainstIcapHeader(finalResult, keyIcapPreview,</span>
                                    subStringFromKeyIcapPreview, true)) {
<span class="fc" id="L250">          close();</span>
<span class="fc" id="L251">          logger.error(&quot;Could not validate preview from server&quot;);</span>
<span class="fc" id="L252">          throw new IcapException(&quot;Could not validate preview from server&quot;,</span>
                                  IcapError.ICAP_SERVER_MISSING_INFO);
        }
      } else {
<span class="fc" id="L256">        close();</span>
<span class="fc" id="L257">        logger.error(&quot;Could not get preview size from server&quot;);</span>
<span class="fc" id="L258">        throw new IcapException(&quot;Could not get preview size from server&quot;,</span>
                                IcapError.ICAP_SERVER_MISSING_INFO);
      }
<span class="fc" id="L261">    } else {</span>
<span class="fc" id="L262">      close();</span>
<span class="fc" id="L263">      logger</span>
<span class="fc" id="L264">          .error(&quot;Could not get options from server {}:{} service {}&quot;, serverIP,</span>
<span class="fc" id="L265">                 port, icapService);</span>
<span class="fc" id="L266">      throw new IcapException(&quot;Could not get options from server&quot;,</span>
                              IcapError.ICAP_SERVER_MISSING_INFO);
    }
<span class="fc" id="L269">  }</span>

  @Override
  public void close() {
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (client != null) {</span>
      try {
<span class="fc" id="L275">        client.close();</span>
<span class="nc" id="L276">      } catch (final IOException ignored) {</span>
        // Nothing
<span class="fc" id="L278">      }</span>
<span class="fc" id="L279">      client = null;</span>
    }
<span class="fc bfc" id="L281" title="All 2 branches covered.">    if (in != null) {</span>
      try {
<span class="fc" id="L283">        in.close();</span>
<span class="nc" id="L284">      } catch (final IOException ignored) {</span>
        // Nothing
<span class="fc" id="L286">      }</span>
<span class="fc" id="L287">      in = null;</span>
    }
<span class="fc bfc" id="L289" title="All 2 branches covered.">    if (out != null) {</span>
      try {
<span class="fc" id="L291">        out.close();</span>
<span class="nc" id="L292">      } catch (final IOException ignored) {</span>
        // Nothing
<span class="fc" id="L294">      }</span>
<span class="fc" id="L295">      out = null;</span>
    }
<span class="fc" id="L297">  }</span>

  /**
   * Given a file path, it will send the file to the server and return true,
   * if the server accepts the file. Visa-versa, false if the server rejects
   * it.&lt;/br&gt;
   *
   * Note that if the client is not connected, it will first call connect().
   *
   * @param filename Relative or absolute file path to a file. If filename is
   *     EICARTEST, then a build on the fly EICAR test file is sent.
   *
   * @return Returns true when no infection is found.
   *
   * @throws IcapException if an error occurs (network, file reading,
   *     bad headers)
   */
  public boolean scanFile(final String filename) throws IcapException {
<span class="pc bpc" id="L315" title="1 of 4 branches missed.">    if (filename == null || filename.trim().isEmpty()) {</span>
<span class="fc" id="L316">      throw new IllegalArgumentException(&quot;Filename must not be empty&quot;);</span>
    }
<span class="fc bfc" id="L318" title="All 2 branches covered.">    if (client == null) {</span>
<span class="fc" id="L319">      connect();</span>
    }
<span class="fc bfc" id="L321" title="All 2 branches covered.">    if (finalResult != null) {</span>
<span class="fc" id="L322">      finalResult.clear();</span>
<span class="fc" id="L323">      finalResult = null;</span>
    }
<span class="fc" id="L325">    InputStream inputStream = null;</span>
    final long length;
<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (EICARTEST.equals(filename)) {</span>
      // Special file to test from EICAR Test file
<span class="fc" id="L329">      final ClassLoader classLoader = IcapClient.class.getClassLoader();</span>
<span class="fc" id="L330">      final File fileSrc1 =</span>
<span class="fc" id="L331">          new File(classLoader.getResource(&quot;eicar.com-part1.txt&quot;).getFile());</span>
<span class="fc" id="L332">      final File fileSrc2 =</span>
<span class="fc" id="L333">          new File(classLoader.getResource(&quot;eicar.com-part2.txt&quot;).getFile());</span>
<span class="pc bpc" id="L334" title="2 of 4 branches missed.">      if (fileSrc1.exists() &amp;&amp; fileSrc2.exists()) {</span>
        try {
<span class="fc" id="L336">          final byte[] array1 = Files.toByteArray(fileSrc1);</span>
<span class="fc" id="L337">          final byte[] array2 = Files.toByteArray(fileSrc2);</span>
<span class="fc" id="L338">          final byte[] array =</span>
<span class="fc" id="L339">              Arrays.copyOf(array1, array1.length + array2.length);</span>
<span class="fc" id="L340">          System.arraycopy(array2, 0, array, array1.length, array2.length);</span>
<span class="fc" id="L341">          inputStream = new ByteArrayInputStream(array);</span>
<span class="fc" id="L342">          length = array.length;</span>
<span class="nc" id="L343">        } catch (final IOException e) {</span>
<span class="nc" id="L344">          logger.error(&quot;File EICAR TEST does not exist&quot;, e);</span>
<span class="nc" id="L345">          throw new IcapException(&quot;File EICAR TEST cannot be found&quot;,</span>
                                  IcapError.ICAP_ARGUMENT_ERROR);
<span class="fc" id="L347">        }</span>
      } else {
<span class="nc" id="L349">        logger.error(&quot;File EICAR TEST does not exist&quot;);</span>
<span class="nc" id="L350">        throw new IcapException(&quot;File EICAR TEST cannot be found&quot;,</span>
                                IcapError.ICAP_ARGUMENT_ERROR);
      }
<span class="fc" id="L353">    } else {</span>
<span class="fc" id="L354">      final File file = new File(filename);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">      if (!canRead(file)) {</span>
<span class="fc" id="L356">        logger.error(&quot;File does not exist: {}&quot;, file.getAbsolutePath());</span>
<span class="fc" id="L357">        throw new IcapException(</span>
<span class="fc" id="L358">            &quot;File cannot be found: &quot; + file.getAbsolutePath(),</span>
            IcapError.ICAP_ARGUMENT_ERROR);
      }
<span class="fc" id="L361">      length = file.length();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (length &gt; maxSize) {</span>
<span class="fc" id="L363">        logger.error(&quot;File size {} exceed limit of {}: {}&quot;, length, maxSize,</span>
<span class="fc" id="L364">                     file.getAbsolutePath());</span>
<span class="fc" id="L365">        throw new IcapException(</span>
<span class="fc" id="L366">            &quot;File exceed limit size: &quot; + file.getAbsolutePath(),</span>
            IcapError.ICAP_FILE_LENGTH_ERROR);
      }
      try {
<span class="fc" id="L370">        inputStream = new FileInputStream(file);</span>
<span class="nc" id="L371">      } catch (final FileNotFoundException e) {</span>
<span class="nc" id="L372">        logger</span>
<span class="nc" id="L373">            .error(&quot;Could not find file {} since {}&quot;, filename, e.getMessage());</span>
<span class="nc" id="L374">        throw new IcapException(&quot;File cannot be found: &quot; + filename, e,</span>
                                IcapError.ICAP_ARGUMENT_ERROR);
<span class="fc" id="L376">      }</span>
    }
    try {
<span class="fc" id="L379">      return scanFile(filename, inputStream, length);</span>
    } finally {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">      if (inputStream != null) {</span>
        try {
<span class="fc" id="L383">          inputStream.close();</span>
<span class="nc" id="L384">        } catch (final IOException ignored) {</span>
          // Nothing
<span class="fc" id="L386">        }</span>
      }
<span class="fc" id="L388">      close();</span>
    }
  }

  /**
   * @return the Server IP
   */
  public String getServerIP() {
<span class="fc" id="L396">    return serverIP;</span>
  }

  /**
   * @return the port
   */
  public int getPort() {
<span class="fc" id="L403">    return port;</span>
  }

  /**
   * @return the ICAP service
   */
  public String getIcapService() {
<span class="fc" id="L410">    return icapService;</span>
  }

  /**
   * @return the current Preview size
   */
  public int getPreviewSize() {
<span class="fc" id="L417">    return stdPreviewSize;</span>
  }

  /**
   * @param previewSize the receive length to set
   *
   * @return This
   */
  public IcapClient setPreviewSize(final int previewSize) {
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (previewSize &lt; 0) {</span>
<span class="fc" id="L427">      logger.error(INCOMPATIBLE_ARGUMENT);</span>
<span class="fc" id="L428">      throw new IllegalArgumentException(&quot;Preview cannot be 0 or positive&quot;);</span>
    }
<span class="fc" id="L430">    this.stdPreviewSize = previewSize;</span>
<span class="fc" id="L431">    return this;</span>
  }

  /**
   * @return the current Receive length
   */
  public int getReceiveLength() {
<span class="fc" id="L438">    return receiveLength;</span>
  }

  /**
   * @param receiveLength the receive length to set
   *
   * @return This
   */
  public IcapClient setReceiveLength(final int receiveLength) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">    if (receiveLength &lt; MINIMAL_SIZE) {</span>
<span class="fc" id="L448">      logger.error(INCOMPATIBLE_ARGUMENT);</span>
<span class="fc" id="L449">      throw new IllegalArgumentException(</span>
          &quot;Receive length cannot be less than &quot; + MINIMAL_SIZE);
    }
<span class="fc" id="L452">    this.receiveLength = receiveLength;</span>
<span class="fc" id="L453">    return this;</span>
  }

  /**
   * @return the current Send length
   */
  public int getSendLength() {
<span class="fc" id="L460">    return sendLength;</span>
  }

  /**
   * @param sendLength the send length to set
   *
   * @return This
   */
  public IcapClient setSendLength(final int sendLength) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">    if (sendLength &lt; MINIMAL_SIZE) {</span>
<span class="fc" id="L470">      logger.error(INCOMPATIBLE_ARGUMENT);</span>
<span class="fc" id="L471">      throw new IllegalArgumentException(</span>
          &quot;Send length cannot be less than &quot; + MINIMAL_SIZE);
    }
<span class="fc" id="L474">    this.sendLength = sendLength;</span>
<span class="fc" id="L475">    return this;</span>
  }

  /**
   * @return the current max file size (default being Integer.MAX_VALUE)
   */
  public long getMaxSize() {
<span class="fc" id="L482">    return maxSize;</span>
  }

  /**
   * @param maxSize the maximum file size to set
   *
   * @return This
   */
  public IcapClient setMaxSize(final long maxSize) {
<span class="fc bfc" id="L491" title="All 2 branches covered.">    if (maxSize &lt; MINIMAL_SIZE) {</span>
<span class="fc" id="L492">      logger.error(INCOMPATIBLE_ARGUMENT);</span>
<span class="fc" id="L493">      throw new IllegalArgumentException(</span>
          &quot;Maximum file size length cannot be less than &quot; + MINIMAL_SIZE);
    }
<span class="fc" id="L496">    this.maxSize = maxSize;</span>
<span class="fc" id="L497">    return this;</span>
  }

  /**
   * @return the current time out for connection
   */
  public long getTimeout() {
<span class="fc" id="L504">    return timeout;</span>
  }

  /**
   * @param timeout the timeout to use on connection
   *
   * @return This
   */
  public IcapClient setTimeout(final int timeout) {
<span class="fc" id="L513">    this.timeout = timeout;</span>
<span class="fc" id="L514">    return this;</span>
  }

  /**
   * @return the current key in ICAP headers to find with 200 status in PREVIEW
   *     (or null if none)
   */
  public String getKeyIcapPreview() {
<span class="fc" id="L522">    return keyIcapPreview;</span>
  }

  /**
   * @param keyIcapPreview the key in ICAP headers to find with 200 status in
   *     PREVIEW (or null if none)
   *
   * @return This
   */
  public IcapClient setKeyIcapPreview(final String keyIcapPreview) {
<span class="fc bfc" id="L532" title="All 4 branches covered.">    if (keyIcapPreview != null &amp;&amp; keyIcapPreview.isEmpty()) {</span>
<span class="fc" id="L533">      this.keyIcapPreview = null;</span>
    } else {
<span class="fc" id="L535">      this.keyIcapPreview = keyIcapPreview;</span>
    }
<span class="fc" id="L537">    return this;</span>
  }

  /**
   * @return the current subString to find in key ICAP header with 200 status
   *     in PREVIEW (or null if none)
   */
  public String getSubStringFromKeyIcapPreview() {
<span class="fc" id="L545">    return subStringFromKeyIcapPreview;</span>
  }

  /**
   * @param subStringFromKeyIcapPreview the subString to find in key ICAP header
   *     with 200 status in PREVIEW (or null if none)
   *
   * @return This
   */
  public IcapClient setSubStringFromKeyIcapPreview(
      final String subStringFromKeyIcapPreview) {
<span class="fc bfc" id="L556" title="All 2 branches covered.">    if (subStringFromKeyIcapPreview != null &amp;&amp;</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">        subStringFromKeyIcapPreview.isEmpty()) {</span>
<span class="fc" id="L558">      this.subStringFromKeyIcapPreview = null;</span>
    } else {
<span class="fc" id="L560">      this.subStringFromKeyIcapPreview = subStringFromKeyIcapPreview;</span>
    }
<span class="fc" id="L562">    return this;</span>
  }

  /**
   * @return the current subString to find in Http with 200 status
   *     (or null if none)
   */
  public String getSubstringHttpStatus200() {
<span class="fc" id="L570">    return substringHttpStatus200;</span>
  }

  /**
   * @param substringHttpStatus200 the subString to find in Http with 200 status
   *     (or null if none)
   *
   * @return This
   */
  public IcapClient setSubstringHttpStatus200(
      final String substringHttpStatus200) {
<span class="fc bfc" id="L581" title="All 4 branches covered.">    if (substringHttpStatus200 != null &amp;&amp; substringHttpStatus200.isEmpty()) {</span>
<span class="fc" id="L582">      this.substringHttpStatus200 = null;</span>
    } else {
<span class="fc" id="L584">      this.substringHttpStatus200 = substringHttpStatus200;</span>
    }
<span class="fc" id="L586">    return this;</span>
  }

  /**
   * @return the current key in ICAP headers to find with 200 status
   *     (or null if none)
   */
  public String getKeyIcap200() {
<span class="fc" id="L594">    return keyIcap200;</span>
  }

  /**
   * @param keyIcap200 the key in ICAP headers to find with 200 status
   *     (or null if none)
   *
   * @return This
   */
  public IcapClient setKeyIcap200(final String keyIcap200) {
<span class="fc bfc" id="L604" title="All 4 branches covered.">    if (keyIcap200 != null &amp;&amp; keyIcap200.isEmpty()) {</span>
<span class="fc" id="L605">      this.keyIcap200 = null;</span>
    } else {
<span class="fc" id="L607">      this.keyIcap200 = keyIcap200;</span>
    }
<span class="fc" id="L609">    return this;</span>
  }

  /**
   * @return the current subString to find in key ICAP header with 200 status
   *     (or null if none)
   */
  public String getSubStringFromKeyIcap200() {
<span class="fc" id="L617">    return subStringFromKeyIcap200;</span>
  }

  /**
   * @param subStringFromKeyIcap200 the subString to find in key ICAP header with 200 status
   *     (or null if none)
   *
   * @return This
   */
  public IcapClient setSubStringFromKeyIcap200(
      final String subStringFromKeyIcap200) {
<span class="fc bfc" id="L628" title="All 4 branches covered.">    if (subStringFromKeyIcap200 != null &amp;&amp; subStringFromKeyIcap200.isEmpty()) {</span>
<span class="fc" id="L629">      this.subStringFromKeyIcap200 = null;</span>
    } else {
<span class="fc" id="L631">      this.subStringFromKeyIcap200 = subStringFromKeyIcap200;</span>
    }
<span class="fc" id="L633">    return this;</span>
  }

  /**
   * @return the current key in ICAP headers to find with 204 status
   *     (or null if none)
   */
  public String getKeyIcap204() {
<span class="fc" id="L641">    return keyIcap204;</span>
  }

  /**
   * @param keyIcap204 the key in ICAP headers to find with 204 status
   *     (or null if none)
   *
   * @return This
   */
  public IcapClient setKeyIcap204(final String keyIcap204) {
<span class="fc bfc" id="L651" title="All 4 branches covered.">    if (keyIcap204 != null &amp;&amp; keyIcap204.isEmpty()) {</span>
<span class="fc" id="L652">      this.keyIcap204 = null;</span>
    } else {
<span class="fc" id="L654">      this.keyIcap204 = keyIcap204;</span>
    }
<span class="fc" id="L656">    return this;</span>
  }

  /**
   * @return the current subString to find in key ICAP header with 204 status
   *     (or null if none)
   */
  public String getSubStringFromKeyIcap204() {
<span class="fc" id="L664">    return subStringFromKeyIcap204;</span>
  }

  /**
   * @param subStringFromKeyIcap204 the subString to find in key ICAP header with 204 status
   *     (or null if none)
   *
   * @return This
   */
  public IcapClient setSubStringFromKeyIcap204(
      final String subStringFromKeyIcap204) {
<span class="fc bfc" id="L675" title="All 4 branches covered.">    if (subStringFromKeyIcap204 != null &amp;&amp; subStringFromKeyIcap204.isEmpty()) {</span>
<span class="fc" id="L676">      this.subStringFromKeyIcap204 = null;</span>
    } else {
<span class="fc" id="L678">      this.subStringFromKeyIcap204 = subStringFromKeyIcap204;</span>
    }
<span class="fc" id="L680">    return this;</span>
  }

  /**
   * @return the current map of result (null if none)
   */
  public Map&lt;String, String&gt; getFinalResult() {
<span class="fc" id="L687">    return finalResult;</span>
  }

  /**
   * Automatically asks for the servers available options and returns the raw
   * response as a String.
   *
   * @return String of the servers response
   *
   * @throws IcapException if an error occurs (network, bad headers)
   */
  private String getOptions() throws IcapException {
    // Send OPTIONS header and receive response
    // Sending
<span class="fc" id="L701">    final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L702">    addIcapUri(builder, OPTIONS);</span>
<span class="fc" id="L703">    final String requestHeader =</span>
<span class="fc" id="L704">        builder.append(ENCAPSULATED_NULL_BODY).append(ICAP_TERMINATOR)</span>
<span class="fc" id="L705">               .toString();</span>

<span class="fc" id="L707">    sendString(requestHeader, true);</span>
    // Receiving
<span class="fc" id="L709">    return getHeaderIcap();</span>
  }

  /**
   * Real method to send file for scanning through RESPMOD request
   *
   * @param originalFilename the original filename
   * @param fileInStream the file inputStream
   * @param fileSize the file size
   *
   * @return True if the scan is OK, else False if the scan is KO
   *
   * @throws IcapException if an error occurs (network, file reading,
   *     bad headers)
   */
  private boolean scanFile(final String originalFilename,
                           final InputStream fileInStream, final long fileSize)
      throws IcapException {
<span class="fc" id="L727">    final int previewSize = sendIcapHttpScanRequest(originalFilename, fileSize);</span>

    // Sending preview or, if smaller than previewSize, the whole file.
<span class="fc bfc" id="L730" title="All 2 branches covered.">    if (previewSize == 0) {</span>
      // Send an empty preview
<span class="fc" id="L732">      logger.debug(&quot;Empty PREVIEW&quot;);</span>
<span class="fc" id="L733">      final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L734">      builder.append(Integer.toHexString(previewSize)).append(TERMINATOR);</span>
<span class="fc" id="L735">      builder.append(HTTP_TERMINATOR);</span>
<span class="fc" id="L736">      sendString(builder.toString(), true);</span>
<span class="fc" id="L737">    } else {</span>
<span class="fc" id="L738">      logger.debug(&quot;PREVIEW of {}&quot;, previewSize);</span>
<span class="fc" id="L739">      final byte[] chunk = new byte[previewSize];</span>
<span class="fc" id="L740">      final int read = readChunk(fileInStream, chunk, previewSize);</span>
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">      if (read != previewSize) {</span>
<span class="nc" id="L742">        logger.warn(&quot;Read file size {} is less than preview size {}&quot;, read,</span>
<span class="nc" id="L743">                    previewSize);</span>
      }
      // Send the preview
<span class="fc" id="L746">      final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L747">      builder.append(Integer.toHexString(read)).append(TERMINATOR);</span>
<span class="fc" id="L748">      sendString(builder.toString());</span>
<span class="fc" id="L749">      sendBytes(chunk, read);</span>
<span class="fc" id="L750">      sendString(TERMINATOR);</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">      if (fileSize &lt;= previewSize) {</span>
<span class="fc" id="L752">        logger.debug(&quot;PREVIEW and COMPLETE&quot;);</span>
<span class="fc" id="L753">        sendString(&quot;0; ieof&quot; + ICAP_TERMINATOR, true);</span>
      } else {
<span class="fc" id="L755">        logger.debug(&quot;PREVIEW but could send more&quot;);</span>
<span class="fc" id="L756">        sendString(HTTP_TERMINATOR, true);</span>
      }
    }
    // Parse the response: It might be &quot;100 continue&quot; as
    // a &quot;go&quot; for the rest of the file or a stop there already.
<span class="fc bfc" id="L761" title="All 2 branches covered.">    if (fileSize &gt; previewSize) {</span>
<span class="fc" id="L762">      final int preview = checkPreview();</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">      if (preview != 0) {</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">        logger.debug(&quot;PREVIEW is enough and status {}&quot;, preview == 1);</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        return preview == 1;</span>
      }
<span class="fc" id="L767">      logger.debug(&quot;PREVIEW is not enough&quot;);</span>
<span class="fc" id="L768">      sendNextFileChunks(fileInStream);</span>
    }
<span class="fc" id="L770">    return checkFinalResponse();</span>
  }

  /**
   * Send the Icap Http Scan Reaquest
   *
   * @param originalFilename
   * @param fileSize
   *
   * @return the preview size
   *
   * @throws IcapException
   */
  private int sendIcapHttpScanRequest(final String originalFilename,
                                      final long fileSize)
      throws IcapException {
    // HTTP part of header
    final String resHeader;
<span class="fc" id="L788">    final StringBuilder builder = new StringBuilder(GET_REQUEST);</span>
    try {
<span class="fc" id="L790">      builder</span>
<span class="fc" id="L791">          .append(URLEncoder.encode(originalFilename, WaarpStringUtils.UTF_8))</span>
<span class="fc" id="L792">          .append(&quot; HTTP/1.1&quot;).append(TERMINATOR);</span>
<span class="fc" id="L793">      builder.append(HOST_HEADER).append(serverIP).append(&quot;:&quot;).append(port)</span>
<span class="fc" id="L794">             .append(ICAP_TERMINATOR);</span>
<span class="fc" id="L795">      resHeader = builder.toString();</span>
<span class="nc" id="L796">    } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L797">      logger.error(&quot;Unsupported Encoding: {}&quot;, e.getMessage());</span>
<span class="nc" id="L798">      throw new IcapException(e.getMessage(), e, IcapError.ICAP_INTERNAL_ERROR);</span>
<span class="fc" id="L799">    }</span>
<span class="fc" id="L800">    builder.append(&quot;HTTP/1.1 200 OK&quot;).append(TERMINATOR);</span>
<span class="fc" id="L801">    builder.append(&quot;Transfer-Encoding: chunked&quot;).append(TERMINATOR);</span>
<span class="fc" id="L802">    builder.append(&quot;Content-Length: &quot;).append(fileSize).append(ICAP_TERMINATOR);</span>
<span class="fc" id="L803">    final String resBody = builder.toString();</span>

<span class="fc" id="L805">    int previewSize = stdPreviewSize;</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">    if (fileSize &lt; stdPreviewSize) {</span>
<span class="fc" id="L807">      previewSize = (int) fileSize;</span>
    }

    // ICAP part of header
<span class="fc" id="L811">    builder.setLength(0);</span>
<span class="fc" id="L812">    addIcapUri(builder, RESPMOD);</span>
<span class="fc" id="L813">    builder.append(PREVIEW).append(&quot;: &quot;).append(previewSize).append(TERMINATOR);</span>
<span class="fc" id="L814">    builder.append(&quot;Encapsulated: req-hdr=0, res-hdr=&quot;)</span>
<span class="fc" id="L815">           .append(resHeader.length()).append(&quot;, res-body=&quot;)</span>
<span class="fc" id="L816">           .append(resBody.length()).append(ICAP_TERMINATOR);</span>
<span class="fc" id="L817">    builder.append(resBody);</span>
<span class="fc" id="L818">    final String requestBuffer = builder.toString();</span>

<span class="fc" id="L820">    sendString(requestBuffer);</span>
<span class="fc" id="L821">    return previewSize;</span>
  }

  /**
   * Common part of ICAP URI between OPTIONS and RESPMOD
   *
   * @param builder the empty StringBuilder
   * @param method the method to associate with this ICAP URI
   */
  private void addIcapUri(final StringBuilder builder, final String method) {
<span class="fc" id="L831">    builder.append(method).append(&quot; icap://&quot;).append(serverIP).append(&quot;/&quot;)</span>
<span class="fc" id="L832">           .append(icapService).append(&quot; &quot;).append(VERSION).append(TERMINATOR);</span>
<span class="fc" id="L833">    builder.append(HOST_HEADER).append(serverIP).append(TERMINATOR);</span>
<span class="fc" id="L834">    builder.append(USER_AGENT_HEADER).append(USER_AGENT).append(TERMINATOR);</span>
<span class="fc" id="L835">    builder.append(&quot;Allow: 204&quot;).append(TERMINATOR);</span>
<span class="fc" id="L836">  }</span>

  /**
   * Check the preview for the file scanning request
   *
   * @return 1 or -1 if the antivirus already validated/invalidated
   *     the file, or 0 if the next chunks are needed
   *
   * @throws IcapException if any error occurs (network, file reading,
   *     bad headers)
   */
  private int checkPreview() throws IcapException {
    final int status;
<span class="fc" id="L849">    final String parseMe = getHeaderIcap();</span>
<span class="fc" id="L850">    finalResult = parseHeader(parseMe);</span>

<span class="fc" id="L852">    final String tempString = finalResult.get(STATUS_CODE);</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">    if (tempString != null) {</span>
<span class="fc" id="L854">      status = Integer.parseInt(tempString);</span>
<span class="fc bfc" id="L855" title="All 5 branches covered.">      switch (status) {</span>
        case 100:
<span class="fc" id="L857">          logger.debug(&quot;Recv ICAP Preview Status Continue&quot;);</span>
<span class="fc" id="L858">          return 0; //Continue transfer</span>
        case 200:
<span class="fc" id="L860">          logger.info(&quot;Recv ICAP Preview Status Abort&quot;);</span>
<span class="fc" id="L861">          return -1;</span>
        case 204:
<span class="fc" id="L863">          logger.debug(&quot;Recv ICAP Preview Status Accepted&quot;);</span>
<span class="fc" id="L864">          return 1;</span>
        case 404:
<span class="fc" id="L866">          logger.error(&quot;404: ICAP Service not found&quot;);</span>
<span class="fc" id="L867">          throw new IcapException(&quot;404: ICAP Service not found&quot;,</span>
                                  IcapError.ICAP_SERVER_SERVICE_UNKNOWN);
        default:
<span class="fc" id="L870">          logger.error(&quot;Server returned unknown status code: {}&quot;, status);</span>
<span class="fc" id="L871">          throw new IcapException(</span>
              &quot;Server returned unknown status code: &quot; + status,
              IcapError.ICAP_SERVER_UNKNOWN_CODE);
      }
    }
<span class="nc" id="L876">    logger.error(&quot;Server returned unknown status code&quot;);</span>
<span class="nc" id="L877">    throw new IcapException(&quot;Server returned unknown status code&quot;,</span>
                            IcapError.ICAP_SERVER_UNKNOWN_CODE);
  }

  /**
   * Check the final response for the file scanning request
   *
   * @return True if validated file, False if not
   *
   * @throws IcapException if any error occurs (network, file reading,
   *     bad headers)
   */
  private boolean checkFinalResponse() throws IcapException {
    final int status;
<span class="fc" id="L891">    String parseMe = getHeaderIcap();</span>
<span class="fc" id="L892">    finalResult = parseHeader(parseMe);</span>

<span class="fc" id="L894">    final String tempString = finalResult.get(STATUS_CODE);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">    if (tempString != null) {</span>
<span class="fc" id="L896">      status = Integer.parseInt(tempString);</span>

<span class="fc bfc" id="L898" title="All 2 branches covered.">      if (status == 204) {</span>
        // Unmodified
<span class="fc" id="L900">        logger.debug(&quot;Almost final status is {}&quot;, status);</span>
<span class="fc" id="L901">        return checkAgainstIcapHeader(finalResult, keyIcap204,</span>
                                      subStringFromKeyIcap204, true);
      }

<span class="fc bfc" id="L905" title="All 2 branches covered.">      if (status == 200) {</span>
        // OK - The ICAP status is ok, but the encapsulated HTTP status might
        // likely be different or another key in ICAP status
<span class="fc" id="L908">        logger.debug(&quot;Almost final status is {}&quot;, status);</span>
<span class="fc" id="L909">        boolean finalStatus = checkAgainstIcapHeader(finalResult, keyIcap200,</span>
                                                     subStringFromKeyIcap200,
                                                     false);
<span class="fc bfc" id="L912" title="All 2 branches covered.">        if (substringHttpStatus200 != null &amp;&amp;</span>
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">            !substringHttpStatus200.isEmpty()) {</span>
<span class="fc" id="L914">          parseMe = getHeaderHttp();</span>
<span class="fc" id="L915">          logger.warn(&quot;{} contains {} = {}&quot;, parseMe, substringHttpStatus200,</span>
<span class="fc" id="L916">                      parseMe.contains(substringHttpStatus200));</span>
<span class="fc" id="L917">          finalStatus |= parseMe.contains(substringHttpStatus200);</span>
        } else {
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">          if (logger.isTraceEnabled()) {</span>
<span class="nc" id="L920">            getHeaderHttp();</span>
          }
        }
<span class="fc" id="L923">        logger.info(&quot;Final status with check {}&quot;, finalStatus);</span>
<span class="fc" id="L924">        return finalStatus;</span>
      }
    }
<span class="fc" id="L927">    logger.error(&quot;Unrecognized or no status code in response header&quot;);</span>
<span class="fc" id="L928">    throw new IcapException(&quot;Unrecognized or no status code in response header&quot;,</span>
                            IcapError.ICAP_SERVER_UNKNOWN_CODE);
  }

  /**
   * @param responseMap the header map
   * @param key the key to find out
   * @param subValue the sub value to find in the value associated with the key
   * @param defaultValue the default Value to return if key or subvalue are null
   *
   * @return True if the key exists and its value contains the subValue or
   *     default value if key or subValue are null
   */
  private boolean checkAgainstIcapHeader(final Map&lt;String, String&gt; responseMap,
                                         final String key,
                                         final String subValue,
                                         final boolean defaultValue) {
<span class="pc bpc" id="L945" title="1 of 4 branches missed.">    if (key != null &amp;&amp; subValue != null) {</span>
<span class="fc" id="L946">      final String value = responseMap.get(key);</span>
<span class="pc bpc" id="L947" title="1 of 4 branches missed.">      return value != null &amp;&amp; value.contains(subValue);</span>
    }
<span class="fc" id="L949">    return defaultValue;</span>
  }

  /**
   * Send the next chunks for the file
   *
   * @param fileInStream the file inputStream to read from
   *
   * @throws IcapException if any error occurs (network, file reading,
   *     bad headers)
   */
  private void sendNextFileChunks(final InputStream fileInStream)
      throws IcapException {
    // Sending remaining part of file
<span class="fc" id="L963">    final byte[] buffer = new byte[sendLength];</span>
<span class="fc" id="L964">    int len = readChunk(fileInStream, buffer, sendLength);</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">    while (len != -1) {</span>
<span class="fc" id="L966">      sendString(Integer.toHexString(len) + TERMINATOR);</span>
<span class="fc" id="L967">      sendBytes(buffer, len);</span>
<span class="fc" id="L968">      sendString(TERMINATOR);</span>
<span class="fc" id="L969">      len = readChunk(fileInStream, buffer, sendLength);</span>
    }
    // Ending file transfer
<span class="fc" id="L972">    sendString(HTTP_TERMINATOR, true);</span>
<span class="fc" id="L973">    logger.debug(&quot;End of chunks&quot;);</span>
<span class="fc" id="L974">  }</span>

  /**
   * Read from inputChannel into the buffer the asked length at most
   *
   * @param fileInputStream the file inputStream to read from
   * @param buffer the buffer to write bytes read
   * @param length the maximum length to read
   *
   * @return -1 if no byte are available, else the size in bytes effectively
   *     read
   *
   * @throws IcapException if an error while reading the file occurs
   */
  int readChunk(final InputStream fileInputStream, final byte[] buffer,
                final int length) throws IcapException {
<span class="fc bfc" id="L990" title="All 2 branches covered.">    if (buffer.length &lt; length) {</span>
<span class="fc" id="L991">      logger.error(&quot;Buffer is too small {} for reading file per {}&quot;,</span>
<span class="fc" id="L992">                   buffer.length, length);</span>
<span class="fc" id="L993">      throw new IcapException(&quot;Buffer is too small for reading file&quot;,</span>
                              IcapError.ICAP_INTERNAL_ERROR);
    }
<span class="fc" id="L996">    int sizeOut = 0;</span>
<span class="fc" id="L997">    int toRead = length;</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">    while (sizeOut &lt; length) {</span>
      try {
<span class="fc" id="L1000">        final int read = fileInputStream.read(buffer, sizeOut, toRead);</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (read &lt;= 0) {</span>
<span class="fc" id="L1002">          break;</span>
        }
<span class="fc" id="L1004">        sizeOut += read;</span>
<span class="fc" id="L1005">        toRead -= read;</span>
<span class="nc" id="L1006">      } catch (final IOException e) {</span>
<span class="nc" id="L1007">        logger.error(&quot;File cannot be read: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1008">        throw new IcapException(&quot;File cannot be read&quot;, e,</span>
                                IcapError.ICAP_INTERNAL_ERROR);
<span class="fc" id="L1010">      }</span>
    }
<span class="fc bfc" id="L1012" title="All 2 branches covered.">    if (sizeOut &lt;= 0) {</span>
<span class="fc" id="L1013">      return -1;</span>
    }
<span class="fc" id="L1015">    return sizeOut;</span>
  }

  /**
   * @return the header for Http part of Icap
   *
   * @throws IcapException for network errors
   */
  String getHeaderHttp() throws IcapException {
<span class="fc" id="L1024">    final byte[] buffer = new byte[receiveLength];</span>
    try {
<span class="fc" id="L1026">      return getHeader(HTTP_TERMINATOR, buffer);</span>
<span class="fc" id="L1027">    } catch (final IcapException e) {</span>
<span class="fc" id="L1028">      final String finalHeaders =</span>
          new String(buffer, 0, offset, WaarpStringUtils.UTF8);
<span class="pc bpc" id="L1030" title="1 of 3 branches missed.">      switch (e.getError()) {</span>
        case ICAP_SERVER_HEADER_WITHOUT_TERMINATOR:
          // Returns the buffer as is
<span class="fc" id="L1033">          logger.debug(&quot;RECV HTTP Headers not ended\n{}&quot;, finalHeaders);</span>
<span class="fc" id="L1034">          return finalHeaders;</span>
        case ICAP_SERVER_HEADER_EXCEED_CAPACITY:
          // Returns the buffer as is
<span class="fc" id="L1037">          logger.debug(&quot;RECV HTTP Headers exceed capacity\n{}&quot;, finalHeaders);</span>
<span class="fc" id="L1038">          return finalHeaders;</span>
        default:
          break;
      }
<span class="nc" id="L1042">      throw e;</span>
    }
  }

  /**
   * @return the header for Icap
   *
   * @throws IcapException if the terminator is not found or the buffer is
   *     too small
   */
  String getHeaderIcap() throws IcapException {
<span class="fc" id="L1053">    final byte[] buffer = new byte[receiveLength];</span>
<span class="fc" id="L1054">    return getHeader(ICAP_TERMINATOR, buffer);</span>
  }

  /**
   * Receive an expected ICAP or HTTP header as response of a request. The
   * returned String should be parsed with parseHeader()
   *
   * @param terminator the terminator to use
   *
   * @return String of the raw response
   *
   * @throws IcapException if a network error is raised or if the header
   *     is wrong
   */
  private String getHeader(final String terminator, final byte[] buffer)
      throws IcapException {
<span class="fc" id="L1070">    final byte[] endOfHeader = terminator.getBytes(WaarpStringUtils.UTF8);</span>
<span class="fc" id="L1071">    final int[] endOfHeaderInt = new int[endOfHeader.length];</span>
<span class="fc" id="L1072">    final int[] marks = new int[endOfHeader.length];</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">    for (int i = 0; i &lt; endOfHeader.length; i++) {</span>
<span class="fc" id="L1074">      endOfHeaderInt[i] = endOfHeader[i];</span>
<span class="fc" id="L1075">      marks[i] = -1;</span>
    }

<span class="fc" id="L1078">    int reader = -1;</span>
<span class="fc" id="L1079">    offset = 0;</span>
    // &quot;in&quot; is read 1 by 1 to ensure we read only ICAP headers or HTTP headers
    try {
      // first part is to secure against DOS
<span class="fc bfc" id="L1083" title="All 4 branches covered.">      while ((offset &lt; receiveLength) &amp;&amp; ((reader = in.read()) != -1)) {</span>
<span class="fc" id="L1084">        marks[0] = marks[1];</span>
<span class="fc" id="L1085">        marks[1] = marks[2];</span>
<span class="fc" id="L1086">        marks[2] = marks[3];</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if (endOfHeader.length == 4) {</span>
<span class="fc" id="L1088">          marks[3] = reader;</span>
        } else {
<span class="fc" id="L1090">          marks[3] = marks[4];</span>
<span class="fc" id="L1091">          marks[4] = reader;</span>
        }
<span class="fc" id="L1093">        buffer[offset] = (byte) reader;</span>
<span class="fc" id="L1094">        offset++;</span>
        // 13 is the smallest possible message &quot;ICAP/1.0 xxx &quot;
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        if (offset &gt; endOfHeader.length + 13 &amp;&amp;</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">            Arrays.equals(endOfHeaderInt, marks)) {</span>
<span class="fc" id="L1098">          final String finalHeaders =</span>
              new String(buffer, 0, offset, WaarpStringUtils.UTF8);
<span class="fc" id="L1100">          logger.debug(&quot;RECV {} Headers:{}\n{}&quot;,</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">                       terminator.length() == 4? &quot;ICAP&quot; : &quot;HTTP&quot;, offset,</span>
                       finalHeaders);
<span class="fc" id="L1103">          return finalHeaders;</span>
        }
      }
<span class="nc" id="L1106">    } catch (final SocketTimeoutException e) {</span>
<span class="nc" id="L1107">      logger.error(TIMEOUT_OCCURS_WITH_THE_SERVER_SINCE, serverIP, port,</span>
<span class="nc" id="L1108">                   e.getMessage());</span>
<span class="nc" id="L1109">      throw new IcapException(TIMEOUT_OCCURS_WITH_THE_SERVER, e,</span>
                              IcapError.ICAP_TIMEOUT_ERROR);
<span class="nc" id="L1111">    } catch (final IOException e) {</span>
<span class="nc" id="L1112">      logger.error(&quot;Response cannot be read: {}&quot;, e.getMessage());</span>
<span class="nc" id="L1113">      throw new IcapException(&quot;Response cannot be read&quot;, e,</span>
                              IcapError.ICAP_NETWORK_ERROR);
<span class="fc" id="L1115">    }</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">    if (reader == -1) {</span>
<span class="fc" id="L1117">      logger.warn(&quot;Response is not complete while reading {}&quot;, offset);</span>
<span class="fc" id="L1118">      throw new IcapException(</span>
          &quot;Error in getHeader() method: response is not complete: &quot; + offset,
          IcapError.ICAP_SERVER_HEADER_WITHOUT_TERMINATOR);
    }
<span class="fc" id="L1122">    logger.warn(&quot;Response cannot be read since size exceed maximum {}&quot;,</span>
<span class="fc" id="L1123">                receiveLength);</span>
<span class="fc" id="L1124">    throw new IcapException(</span>
        &quot;Error in getHeader() method: received message too long&quot;,
        IcapError.ICAP_SERVER_HEADER_EXCEED_CAPACITY);
  }

  /**
   * Given a raw response header as a String, it will parse through it and return a HashMap of the result
   */
  private Map&lt;String, String&gt; parseHeader(final String response) {
<span class="fc" id="L1133">    final Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</span>

    /*
     * SAMPLE:
     * ICAP/1.0 204 Unmodified
     * Server: C-ICAP/0.1.6
     * Connection: keep-alive
     * ISTag: CI0001-000-0978-6918203
     */
    // The status code is located between the first 2 whitespaces.
    // Read status code
<span class="fc" id="L1144">    final int x = response.indexOf(' ');</span>
<span class="fc" id="L1145">    final int y = response.indexOf(' ', x + 2);</span>
<span class="fc" id="L1146">    final String statusCode = response.substring(x + 1, y);</span>
<span class="fc" id="L1147">    headers.put(STATUS_CODE, statusCode);</span>

    // Each line in the sample is ended with &quot;\r\n&quot;.
    // When (i+2==response.length()) The end of the header have been reached.
    // The +=2 is added to skip the &quot;\r\n&quot;.
    // Read headers
<span class="fc" id="L1153">    int i = response.indexOf(TERMINATOR, y);</span>
<span class="fc" id="L1154">    i += 2;</span>
<span class="pc bpc" id="L1155" title="1 of 4 branches missed.">    while (i + 2 &lt; response.length() &amp;&amp; response.substring(i).contains(&quot;:&quot;)) {</span>
<span class="fc" id="L1156">      int n = response.indexOf(':', i);</span>
<span class="fc" id="L1157">      final String key = response.substring(i, n).trim();</span>

<span class="fc" id="L1159">      n += 2;</span>
<span class="fc" id="L1160">      i = response.indexOf(TERMINATOR, n);</span>
<span class="fc" id="L1161">      final String value = response.substring(n, i).trim();</span>

<span class="fc" id="L1163">      headers.put(key, value);</span>
<span class="fc" id="L1164">      i += 2;</span>
<span class="fc" id="L1165">    }</span>
<span class="fc" id="L1166">    logger.debug(&quot;RECV ICAP Headers:\n{}&quot;, headers);</span>
<span class="fc" id="L1167">    return headers;</span>
  }

  /**
   * Sends a String through the socket connection. Used for sending ICAP/HTTP headers.
   *
   * @param requestHeader to send
   *
   * @throws IcapException if a network error is raised
   */
  private void sendString(final String requestHeader) throws IcapException {
<span class="fc" id="L1178">    sendString(requestHeader, false);</span>
<span class="fc" id="L1179">  }</span>

  /**
   * Sends a String through the socket connection. Used for sending ICAP/HTTP headers.
   *
   * @param requestHeader to send
   * @param withFlush if flush is necessary
   *
   * @throws IcapException if a network error is raised
   */
  private void sendString(final String requestHeader, final boolean withFlush)
      throws IcapException {
    try {
<span class="fc" id="L1192">      out.write(requestHeader.getBytes(WaarpStringUtils.UTF8));</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">      if (withFlush) {</span>
<span class="fc" id="L1194">        out.flush();</span>
      }
<span class="nc" id="L1196">    } catch (final SocketTimeoutException e) {</span>
<span class="nc" id="L1197">      logger.error(TIMEOUT_OCCURS_WITH_THE_SERVER_SINCE, serverIP, port,</span>
<span class="nc" id="L1198">                   e.getMessage());</span>
<span class="nc" id="L1199">      throw new IcapException(TIMEOUT_OCCURS_WITH_THE_SERVER, e,</span>
                              IcapError.ICAP_TIMEOUT_ERROR);
<span class="nc" id="L1201">    } catch (final IOException e) {</span>
<span class="nc" id="L1202">      logger.error(&quot;Client cannot communicate with ICAP Server: {}&quot;,</span>
<span class="nc" id="L1203">                   e.getMessage());</span>
<span class="nc" id="L1204">      throw new IcapException(&quot;Client cannot communicate with ICAP Server&quot;, e,</span>
                              IcapError.ICAP_NETWORK_ERROR);
<span class="fc" id="L1206">    }</span>
<span class="fc" id="L1207">  }</span>

  /**
   * Sends bytes of data from a byte-array through the socket connection.
   *
   * @param chunk The byte-array to send
   *
   * @throws IcapException if a network error is raised
   */
  private void sendBytes(final byte[] chunk, final int length)
      throws IcapException {
    try {
<span class="fc" id="L1219">      out.write(chunk, 0, length);</span>
<span class="nc" id="L1220">    } catch (final SocketTimeoutException e) {</span>
<span class="nc" id="L1221">      logger.error(TIMEOUT_OCCURS_WITH_THE_SERVER_SINCE, serverIP, port,</span>
<span class="nc" id="L1222">                   e.getMessage());</span>
<span class="nc" id="L1223">      throw new IcapException(TIMEOUT_OCCURS_WITH_THE_SERVER, e,</span>
                              IcapError.ICAP_TIMEOUT_ERROR);
<span class="nc" id="L1225">    } catch (final IOException e) {</span>
<span class="nc" id="L1226">      logger.error(&quot;Client cannot communicate with ICAP Server: {}&quot;,</span>
<span class="nc" id="L1227">                   e.getMessage());</span>
<span class="nc" id="L1228">      throw new IcapException(&quot;Writing to ICAP Server cannot be done&quot;, e,</span>
                              IcapError.ICAP_NETWORK_ERROR);
<span class="fc" id="L1230">    }</span>
<span class="fc" id="L1231">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>