<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DbConnectionPool.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Extensions for JRE 8 and greater</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.database</a> &gt; <span class="el_source">DbConnectionPool.java</span></div><h1>DbConnectionPool.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.database;

import javax.sql.ConnectionEvent;
import javax.sql.ConnectionEventListener;
import javax.sql.ConnectionPoolDataSource;
import javax.sql.PooledConnection;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayDeque;
import java.util.Iterator;
import java.util.Queue;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * A simple standalone JDBC connection pool manager.
 * &lt;p/&gt;
 * The public methods of this class are thread-safe.
 * &lt;p/&gt;
 * Nothe that JDBC4 is needed and isValid() must be implemented (not yet in
 * PostGre in April 2012)
 * &lt;p/&gt;
 *
 * @author Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland&lt;br&gt;
 *     Multi-licensed: EPL/LGPL/MPL.
 *     &lt;br&gt;
 *     Add TimerTask support to close after some &quot;delay&quot; any still connected
 *     sessions
 */
public class DbConnectionPool {
  private ConnectionPoolDataSource dataSource;

  private final int maxConnections;

  private final int timeout;

  private static final long TIME_OUT_FORCE_CLOSE = 300000; // 5 minutes

  private Semaphore semaphore;

  private final Queue&lt;Con&gt; recycledConnections;

  private int activeConnections;

  private final PoolConnectionEventListener poolConnectionEventListener;

  private boolean isDisposed;

  private static class Con {
    final PooledConnection pooledCon;

    final long lastRecyle;

<span class="nc" id="L75">    private Con(final PooledConnection pooledCon) {</span>
<span class="nc" id="L76">      this.pooledCon = pooledCon;</span>
<span class="nc" id="L77">      lastRecyle = System.currentTimeMillis();</span>
<span class="nc" id="L78">    }</span>

    @Override
    public final boolean equals(final Object o) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L83">        return true;</span>
      }
<span class="nc bnc" id="L85" title="All 2 branches missed.">      if (!(o instanceof Con)) {</span>
<span class="nc" id="L86">        return false;</span>
      }

<span class="nc" id="L89">      final Con con = (Con) o;</span>

<span class="nc" id="L91">      return pooledCon.equals(con.pooledCon);</span>
    }

    @Override
    public final int hashCode() {
<span class="nc" id="L96">      return pooledCon.hashCode();</span>
    }
  }

  /**
   * Class to check validity of connections in the pool
   */
  private static class TimerTaskCheckConnections extends TimerTask {
    DbConnectionPool pool;
    Timer timer;
    long delay;

    /**
     * @param timer
     * @param delay
     * @param pool
     */
    private TimerTaskCheckConnections(final Timer timer, final long delay,
<span class="nc" id="L114">                                      final DbConnectionPool pool) {</span>
<span class="nc bnc" id="L115" title="All 6 branches missed.">      if (pool == null || timer == null || delay &lt; 1000) {</span>
<span class="nc" id="L116">        throw new IllegalArgumentException(</span>
            &quot;Invalid values. Need pool, timer and delay &gt;= 1000&quot;);
      }
<span class="nc" id="L119">      this.pool = pool;</span>
<span class="nc" id="L120">      this.timer = timer;</span>
<span class="nc" id="L121">      this.delay = delay;</span>
<span class="nc" id="L122">    }</span>

    @Override
    public void run() {
<span class="nc" id="L126">      final Iterator&lt;Con&gt; conIterator = pool.recycledConnections.iterator();</span>
<span class="nc" id="L127">      final long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">      while (conIterator.hasNext()) {</span>
<span class="nc" id="L129">        final Con c = conIterator.next();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (c.lastRecyle + TIME_OUT_FORCE_CLOSE &lt; now) {</span>
<span class="nc" id="L131">          conIterator.remove();</span>
<span class="nc" id="L132">          pool.closeConnectionNoEx(c.pooledCon);</span>
        } else {
          try {
<span class="nc" id="L135">            if (!c.pooledCon.getConnection()</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                            .isValid(DbConstant.VALIDTESTDURATION)) {</span>
<span class="nc" id="L137">              conIterator.remove();</span>
<span class="nc" id="L138">              pool.closeConnectionNoEx(c.pooledCon);</span>
            }
<span class="nc" id="L140">          } catch (final SQLException e) {</span>
<span class="nc" id="L141">            conIterator.remove();</span>
<span class="nc" id="L142">            pool.closeConnectionNoEx(c.pooledCon);</span>
<span class="nc" id="L143">          }</span>
        }
<span class="nc" id="L145">      }</span>
<span class="nc" id="L146">      timer.schedule(this, delay);</span>
<span class="nc" id="L147">    }</span>

  }

  /**
   * Release all idle connections
   */
  public synchronized void freeIdleConnections() {
<span class="nc" id="L155">    final Iterator&lt;Con&gt; conIterator = recycledConnections.iterator();</span>
<span class="nc" id="L156">    final long now = System.currentTimeMillis();</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">    while (conIterator.hasNext()) {</span>
<span class="nc" id="L158">      final Con c = conIterator.next();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (c.lastRecyle + TIME_OUT_FORCE_CLOSE &lt; now) {</span>
<span class="nc" id="L160">        conIterator.remove();</span>
<span class="nc" id="L161">        closeConnectionNoEx(c.pooledCon);</span>
      }
<span class="nc" id="L163">    }</span>
<span class="nc" id="L164">  }</span>

  /**
   * Thrown in when no free connection becomes available within
   * {@code timeout} seconds.
   */
  private static class TimeoutException extends RuntimeException {
    private static final long serialVersionUID = 1;

    public TimeoutException() {
<span class="nc" id="L174">      super(&quot;Timeout while waiting for a free database connection.&quot;);</span>
<span class="nc" id="L175">    }</span>
  }

  /**
   * Constructs a MiniConnectionPoolManager object with no timeout and no
   * limit.
   *
   * @param dataSource the data source for the connections.
   */
  public DbConnectionPool(final ConnectionPoolDataSource dataSource) {
<span class="fc" id="L185">    this(dataSource, 0, DbConstant.DELAYMAXCONNECTION);</span>
<span class="fc" id="L186">  }</span>

  /**
   * Constructs a MiniConnectionPoolManager object with no timeout and no
   * limit.
   *
   * @param dataSource the data source for the connections.
   * @param timer
   * @param delay in ms period of time to check existing connections
   *     and
   *     limit to get a new connection
   */
  public DbConnectionPool(final ConnectionPoolDataSource dataSource,
                          final Timer timer, final long delay) {
<span class="nc" id="L200">    this(dataSource, 0, (int) (delay / 1000));</span>
<span class="nc" id="L201">    timer.schedule(new TimerTaskCheckConnections(timer, delay, this), delay);</span>
<span class="nc" id="L202">  }</span>

  /**
   * Constructs a MiniConnectionPoolManager object with a timeout of
   * DbConstant.DELAYMAXCONNECTION seconds.
   *
   * @param dataSource the data source for the connections.
   * @param maxConnections the maximum number of connections. 0 means
   *     no
   *     limit
   */
  public DbConnectionPool(final ConnectionPoolDataSource dataSource,
                          final int maxConnections) {
<span class="nc" id="L215">    this(dataSource, maxConnections, DbConstant.DELAYMAXCONNECTION);</span>
<span class="nc" id="L216">  }</span>

  /**
   * Constructs a ConnectionPool object.
   *
   * @param dataSource the data source for the connections.
   * @param maxConnections the maximum number of connections. 0 means
   *     no
   *     limit
   * @param timeout the maximum time in seconds to wait for a free
   *     connection.
   */
  public DbConnectionPool(final ConnectionPoolDataSource dataSource,
<span class="fc" id="L229">                          final int maxConnections, final int timeout) {</span>
<span class="fc" id="L230">    this.dataSource = dataSource;</span>
<span class="fc" id="L231">    this.maxConnections = maxConnections;</span>
<span class="fc" id="L232">    this.timeout = timeout;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    if (maxConnections != 0) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      if (timeout &lt;= 0) {</span>
<span class="nc" id="L235">        throw new IllegalArgumentException(&quot;Invalid timeout value.&quot;);</span>
      }
<span class="nc" id="L237">      semaphore = new Semaphore(maxConnections, true);</span>
    }
<span class="fc" id="L239">    recycledConnections = new ArrayDeque&lt;Con&gt;();</span>
<span class="fc" id="L240">    poolConnectionEventListener = new PoolConnectionEventListener(this);</span>
<span class="fc" id="L241">  }</span>

  public synchronized void resetPoolDataSource(
      final ConnectionPoolDataSource dataSource) {
<span class="fc" id="L245">    this.dataSource = dataSource;</span>
<span class="fc" id="L246">  }</span>

  /**
   * @return the max number of connections
   */
  public final int getMaxConnections() {
<span class="fc" id="L252">    return maxConnections;</span>
  }

  /**
   * @return the Login Timeout in second
   */
  public final long getLoginTimeout() {
<span class="fc" id="L259">    return timeout;</span>
  }

  /**
   * @return the Force Close Timeout in ms
   */
  public final long getTimeoutForceClose() {
<span class="fc" id="L266">    return TIME_OUT_FORCE_CLOSE;</span>
  }

  /**
   * Closes all unused pooled connections.
   *
   * @throws SQLException //
   */
  public synchronized void dispose() throws SQLException {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    if (isDisposed) {</span>
<span class="nc" id="L276">      return;</span>
    }
<span class="fc" id="L278">    isDisposed = true;</span>
<span class="fc" id="L279">    SQLException e = null;</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">    while (!recycledConnections.isEmpty()) {</span>
<span class="nc" id="L281">      final Con c = recycledConnections.remove();</span>
<span class="nc" id="L282">      final PooledConnection pconn = c.pooledCon;</span>
      try {
<span class="nc" id="L284">        pconn.close();</span>
<span class="nc" id="L285">      } catch (final SQLException e2) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L287">          e = e2;</span>
        }
<span class="nc" id="L289">      }</span>
<span class="nc" id="L290">    }</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">    if (e != null) {</span>
<span class="nc" id="L292">      throw e;</span>
    }
<span class="fc" id="L294">  }</span>

  /**
   * Retrieves a connection from the connection pool. If
   * {@code maxConnections} connections are already in
   * use, the method waits until a connection becomes available or
   * {@code timeout} seconds elapsed. When
   * the application is finished using the connection, it must close it in
   * order
   * to return it to the pool.
   *
   * @return a new Connection object.
   *
   * @throws TimeoutException when no connection becomes available
   *     within
   *     {@code timeout} seconds.
   * @throws SQLException //
   */
  public Connection getConnection() throws SQLException {
    // This routine is unsynchronized, because semaphore.tryAcquire() may
    // block.
<span class="fc" id="L315">    synchronized (this) {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">      if (isDisposed) {</span>
<span class="nc" id="L317">        throw new IllegalStateException(&quot;Connection pool has been disposed.&quot;);</span>
      }
<span class="fc" id="L319">    }</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (semaphore != null) {</span>
      try {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (!semaphore.tryAcquire(timeout, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L323">          throw new TimeoutException();</span>
        }
<span class="nc" id="L325">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L326">        throw new RuntimeException(</span>
            &quot;Interrupted while waiting for a database connection.&quot;, e);
<span class="nc" id="L328">      }</span>
    }
<span class="fc" id="L330">    boolean ok = false;</span>
    try {
<span class="nc" id="L332">      final Connection conn = getConnection2();</span>
<span class="nc" id="L333">      ok = true;</span>
<span class="nc" id="L334">      return conn;</span>
    } finally {
<span class="pc bpc" id="L336" title="3 of 4 branches missed.">      if (semaphore != null &amp;&amp; !ok) {</span>
<span class="nc" id="L337">        semaphore.release();</span>
      }
    }
  }

  private synchronized Connection getConnection2() throws SQLException {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">    if (isDisposed) {</span>
<span class="nc" id="L344">      throw new IllegalStateException(</span>
          &quot;Connection pool has been disposed.&quot;); // test again with
    }
    // lock
<span class="fc" id="L348">    final long time = System.currentTimeMillis() + timeout * 1000;</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">    while (time &lt;= System.currentTimeMillis()) {</span>
      final PooledConnection pconn;
<span class="nc bnc" id="L351" title="All 2 branches missed.">      if (!recycledConnections.isEmpty()) {</span>
<span class="nc" id="L352">        pconn = recycledConnections.remove().pooledCon;</span>
      } else {
<span class="nc" id="L354">        pconn = dataSource.getPooledConnection();</span>
      }

<span class="nc" id="L357">      final Connection conn = pconn.getConnection();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">      if (conn.isValid(DbConstant.VALIDTESTDURATION)) {</span>
<span class="nc" id="L359">        activeConnections++;</span>
<span class="nc" id="L360">        pconn.addConnectionEventListener(poolConnectionEventListener);</span>
<span class="nc" id="L361">        assertInnerState();</span>
<span class="nc" id="L362">        return conn;</span>
      }
<span class="nc" id="L364">    }</span>

<span class="fc" id="L366">    throw new SQLException(&quot;Could not get a valid connection before timeout&quot;);</span>
  }

  private synchronized void recycleConnection(final PooledConnection pconn) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (isDisposed) {</span>
<span class="nc" id="L371">      disposeConnection(pconn);</span>
<span class="nc" id="L372">      return;</span>
    }
    try {
<span class="nc bnc" id="L375" title="All 2 branches missed.">      if (!pconn.getConnection().isValid(DbConstant.VALIDTESTDURATION)) {</span>
<span class="nc" id="L376">        disposeConnection(pconn);</span>
<span class="nc" id="L377">        return;</span>
      }
<span class="nc" id="L379">    } catch (final SQLException e) {</span>
<span class="nc" id="L380">      disposeConnection(pconn);</span>
<span class="nc" id="L381">      return;</span>
<span class="nc" id="L382">    }</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    if (activeConnections &lt;= 0) {</span>
<span class="nc" id="L384">      throw new AssertionError();</span>
    }
<span class="nc" id="L386">    activeConnections--;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">    if (semaphore != null) {</span>
<span class="nc" id="L388">      semaphore.release();</span>
    }
<span class="nc" id="L390">    recycledConnections.add(new Con(pconn));</span>
<span class="nc" id="L391">    assertInnerState();</span>
<span class="nc" id="L392">  }</span>

  private synchronized void disposeConnection(final PooledConnection pconn) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">    if (activeConnections &lt;= 0) {</span>
<span class="nc" id="L396">      throw new AssertionError();</span>
    }
<span class="nc" id="L398">    activeConnections--;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">    if (semaphore != null) {</span>
<span class="nc" id="L400">      semaphore.release();</span>
    }
<span class="nc" id="L402">    closeConnectionNoEx(pconn);</span>
<span class="nc" id="L403">    assertInnerState();</span>
<span class="nc" id="L404">  }</span>

  private void closeConnectionNoEx(final PooledConnection pconn) {
    try {
<span class="nc" id="L408">      pconn.close();</span>
<span class="nc" id="L409">    } catch (final SQLException e) {</span>
      //
<span class="nc" id="L411">    }</span>
<span class="nc" id="L412">  }</span>

  private void assertInnerState() {
<span class="nc bnc" id="L415" title="All 2 branches missed.">    if (activeConnections &lt; 0) {</span>
<span class="nc" id="L416">      throw new AssertionError();</span>
    }
<span class="nc bnc" id="L418" title="All 2 branches missed.">    if (semaphore != null) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">      if (activeConnections + recycledConnections.size() &gt; maxConnections) {</span>
<span class="nc" id="L420">        throw new AssertionError();</span>
      }
<span class="nc bnc" id="L422" title="All 2 branches missed.">      if (activeConnections + semaphore.availablePermits() &gt; maxConnections) {</span>
<span class="nc" id="L423">        throw new AssertionError();</span>
      }
    }
<span class="nc" id="L426">  }</span>

  private static class PoolConnectionEventListener
      implements ConnectionEventListener {
    private final DbConnectionPool pool;

<span class="fc" id="L432">    private PoolConnectionEventListener(final DbConnectionPool pool) {</span>
<span class="fc" id="L433">      this.pool = pool;</span>
<span class="fc" id="L434">    }</span>

    @Override
    public final void connectionClosed(final ConnectionEvent event) {
<span class="nc" id="L438">      final PooledConnection pconn = (PooledConnection) event.getSource();</span>
<span class="nc" id="L439">      pconn.removeConnectionEventListener(this);</span>
<span class="nc" id="L440">      pool.recycleConnection(pconn);</span>
<span class="nc" id="L441">    }</span>

    @Override
    public final void connectionErrorOccurred(final ConnectionEvent event) {
<span class="nc" id="L445">      final PooledConnection pconn = (PooledConnection) event.getSource();</span>
<span class="nc" id="L446">      pconn.removeConnectionEventListener(this);</span>
<span class="nc" id="L447">      pool.disposeConnection(pconn);</span>
<span class="nc" id="L448">    }</span>
  }

  /**
   * Returns the number of active (open) connections of this pool. This is the
   * number of {@code Connection}
   * objects that have been issued by {@link #getConnection()} for which
   * {@code Connection.close()} has not
   * yet been called.
   *
   * @return the number of active connections.
   */
  public synchronized int getActiveConnections() {
<span class="nc" id="L461">    return activeConnections;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>