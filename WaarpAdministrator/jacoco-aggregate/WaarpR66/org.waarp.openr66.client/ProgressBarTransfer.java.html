<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ProgressBarTransfer.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Administrator</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.client</a> &gt; <span class="el_source">ProgressBarTransfer.java</span></div><h1>ProgressBarTransfer.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.client;

import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.commander.ClientRunner;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.R66Future;

/**
 * Through API Transfer from a client with or without database connection, and
 * enabling access to statistic of
 * the transfer (unblocking transfer)
 */
public abstract class ProgressBarTransfer extends AbstractTransfer {
  protected final NetworkTransaction networkTransaction;
<span class="fc" id="L46">  protected long intervalCallback = 100;</span>
  protected long filesize;

  protected ProgressBarTransfer(final R66Future future, final String remoteHost,
                                final String filename, final String rulename,
                                final String fileinfo, final boolean isMD5,
                                final int blocksize, final long id,
                                final NetworkTransaction networkTransaction,
                                final long callbackdelay) {
    // no delay so starttime = null
<span class="fc" id="L56">    super(ProgressBarTransfer.class, future, filename, rulename, fileinfo,</span>
          isMD5, remoteHost, blocksize, id, null);
<span class="fc" id="L58">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L59">    intervalCallback = callbackdelay;</span>
<span class="fc" id="L60">  }</span>

  /**
   * This function will be called every 100ms (or other fixed value in
   * INTERVALCALLBACK). Note that final rank
   * is unknown.
   *
   * @param currentBlock the current block rank (from 0 to n-1)
   * @param blocksize blocksize of 1 block
   */
  public abstract void callBack(int currentBlock, int blocksize);

  /**
   * This function will be called only once when the transfer is over
   *
   * @param success True if the transfer is successful
   * @param currentBlock
   * @param blocksize
   */
  public abstract void lastCallBack(boolean success, int currentBlock,
                                    int blocksize);

  /**
   * Prior to call this method, the pipeline and NetworkTransaction must have
   * been initialized. It is the
   * responsibility of the caller to finish all network resources.
   */
  @Override
  public void run() {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L90">      logger = WaarpLoggerFactory.getLogger(ProgressBarTransfer.class);</span>
    }
<span class="fc" id="L92">    final DbTaskRunner taskRunner = initRequest();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">    if (taskRunner == null) {</span>
      // already an error from there
<span class="nc" id="L95">      lastCallBack(false, 0, transferArgs.getBlockSize());</span>
<span class="nc" id="L96">      return;</span>
    }
<span class="fc" id="L98">    final ClientRunner runner =</span>
        new ClientRunner(networkTransaction, taskRunner, future);
<span class="fc" id="L100">    OpenR66ProtocolNotYetConnectionException exc = null;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">    for (int i = 0; i &lt; Configuration.RETRYNB; i++) {</span>
      try {
<span class="fc" id="L103">        logger.debug(&quot;starting connection done on progressBarTransfer&quot;);</span>
<span class="fc" id="L104">        final LocalChannelReference localChannelReference =</span>
<span class="fc" id="L105">            runner.initRequest();</span>
<span class="fc" id="L106">        localChannelReference.getFutureValidRequest().awaitOrInterruptible();</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (!localChannelReference.getFutureValidRequest().isSuccess() &amp;&amp;</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            localChannelReference.getFutureValidRequest() != null &amp;&amp;</span>
<span class="nc" id="L109">            localChannelReference.getFutureValidRequest().getResult()</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                                 .getCode() == ErrorCode.ServerOverloaded) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">          switch (taskRunner.getUpdatedInfo()) {</span>
            case DONE:
            case INERROR:
            case INTERRUPTED:
<span class="nc" id="L115">              break;</span>
            default:
<span class="nc" id="L117">              runner.changeUpdatedInfo(UpdatedInfo.INERROR,</span>
                                       ErrorCode.ServerOverloaded, true);
          }
          // redo if possible
<span class="nc" id="L121">          if (runner</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">              .incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB)) {</span>
            try {
<span class="nc" id="L124">              Thread.sleep(</span>
<span class="nc" id="L125">                  Configuration.configuration.getConstraintLimitHandler()</span>
<span class="nc" id="L126">                                             .getSleepTime());</span>
<span class="nc" id="L127">            } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L128">              SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L129">            }</span>
<span class="nc" id="L130">            i--;</span>
<span class="nc" id="L131">            continue;</span>
          } else {
<span class="nc" id="L133">            throw new OpenR66ProtocolNotYetConnectionException(</span>
                &quot;End of retry on ServerOverloaded&quot;);
          }
        }
<span class="fc" id="L137">        logger.debug(&quot;connection done on progressBarTransfer&quot;);</span>
<span class="fc" id="L138">        filesize = future.getFilesize();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        while (!future.awaitOrInterruptible(intervalCallback)) {</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">          if (future.isDone()) {</span>
<span class="nc" id="L141">            break;</span>
          }
<span class="fc" id="L143">          callBack(future.getRunner().getRank(),</span>
<span class="fc" id="L144">                   future.getRunner().getBlocksize());</span>
        }
<span class="fc" id="L146">        logger.debug(&quot;transfer done on progressBarTransfer&quot;);</span>
<span class="fc" id="L147">        runner.finishTransfer(localChannelReference);</span>
<span class="fc" id="L148">        lastCallBack(future.isSuccess(), future.getRunner().getRank(),</span>
<span class="fc" id="L149">                     future.getRunner().getBlocksize());</span>
<span class="fc" id="L150">        exc = null;</span>
<span class="fc" id="L151">        break;</span>
<span class="nc" id="L152">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L153">        logger.error(&quot;Cannot Transfer&quot;, e);</span>
<span class="nc" id="L154">        future.setResult(</span>
            new R66Result(e, null, true, ErrorCode.Internal, taskRunner));
<span class="nc" id="L156">        future.setFailure(e);</span>
<span class="nc" id="L157">        lastCallBack(false, taskRunner.getRank(), taskRunner.getBlocksize());</span>
<span class="nc" id="L158">        return;</span>
<span class="nc" id="L159">      } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="nc" id="L160">        logger.error(&quot;Cannot Connect&quot;, e);</span>
<span class="nc" id="L161">        future.setResult(</span>
            new R66Result(e, null, true, ErrorCode.ConnectionImpossible,
                          taskRunner));
<span class="nc" id="L164">        finalizeInErrorTransferRequest(runner, taskRunner,</span>
                                       ErrorCode.ConnectionImpossible);
        // since no connection : just forget it
<span class="nc bnc" id="L167" title="All 4 branches missed.">        if (nolog || taskRunner.shallIgnoreSave()) {</span>
          try {
<span class="nc" id="L169">            taskRunner.delete();</span>
<span class="nc" id="L170">          } catch (final WaarpDatabaseException ignored) {</span>
            // nothing
<span class="nc" id="L172">          }</span>
        }
<span class="nc" id="L174">        future.setFailure(e);</span>
<span class="nc" id="L175">        lastCallBack(false, taskRunner.getRank(), taskRunner.getBlocksize());</span>
<span class="nc" id="L176">        return;</span>
<span class="nc" id="L177">      } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L178">        logger.error(&quot;Bad Protocol&quot;, e);</span>
<span class="nc" id="L179">        future.setResult(</span>
            new R66Result(e, null, true, ErrorCode.TransferError, taskRunner));
<span class="nc" id="L181">        future.setFailure(e);</span>
<span class="nc" id="L182">        lastCallBack(false, taskRunner.getRank(), taskRunner.getBlocksize());</span>
<span class="nc" id="L183">        return;</span>
<span class="nc" id="L184">      } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="nc" id="L185">        logger.debug(&quot;Not Yet Connected&quot;, e);</span>
<span class="nc" id="L186">        exc = e;</span>
      }
    }
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">    if (exc != null) {</span>
<span class="nc" id="L190">      taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L191">      logger.error(&quot;Cannot Connect&quot;, exc);</span>
<span class="nc" id="L192">      future.setResult(</span>
          new R66Result(exc, null, true, ErrorCode.ConnectionImpossible,
                        taskRunner));
<span class="nc" id="L195">      lastCallBack(false, taskRunner.getRank(), taskRunner.getBlocksize());</span>
      // since no connection : just forget it
<span class="nc bnc" id="L197" title="All 4 branches missed.">      if (nolog || taskRunner.shallIgnoreSave()) {</span>
        try {
<span class="nc" id="L199">          taskRunner.delete();</span>
<span class="nc" id="L200">        } catch (final WaarpDatabaseException ignored) {</span>
          // nothing
<span class="nc" id="L202">        }</span>
      }
<span class="nc" id="L204">      future.setFailure(exc);</span>
    }
<span class="fc" id="L206">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>