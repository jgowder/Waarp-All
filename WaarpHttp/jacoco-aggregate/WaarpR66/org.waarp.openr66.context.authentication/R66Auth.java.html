<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>R66Auth.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Http</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.context.authentication</a> &gt; <span class="el_source">R66Auth.java</span></div><h1>R66Auth.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.context.authentication;

import org.waarp.common.command.NextCommandReply;
import org.waarp.common.command.exception.Reply421Exception;
import org.waarp.common.command.exception.Reply530Exception;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.filesystembased.FilesystemBasedAuthImpl;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.protocol.configuration.Configuration;

import java.io.File;

/**
 *
 */
public class R66Auth extends FilesystemBasedAuthImpl {
  /**
   * Internal Logger
   */
<span class="nc" id="L47">  private static final WaarpLogger logger =</span>
<span class="nc" id="L48">      WaarpLoggerFactory.getLogger(R66Auth.class);</span>

  /**
   * Current authentication
   */
  private DbHostAuth currentAuth;
  /**
   * is Admin role
   */
  private boolean isAdmin;
  /**
   * Role set from configuration file only
   */
<span class="nc" id="L61">  private final RoleDefault role = new RoleDefault();</span>

  /**
   * @param session
   */
  public R66Auth(final R66Session session) {
<span class="nc" id="L67">    super(session);</span>
<span class="nc" id="L68">  }</span>

  @Override
  protected final void businessClean() {
<span class="nc" id="L72">    currentAuth = null;</span>
<span class="nc" id="L73">    isAdmin = false;</span>
<span class="nc" id="L74">    role.clear();</span>
<span class="nc" id="L75">  }</span>

  @Override
  public final String getBaseDirectory() {
<span class="nc" id="L79">    return Configuration.configuration.getBaseDirectory();</span>
  }

  @Override
  protected final NextCommandReply setBusinessPassword(final String arg0)
      throws Reply421Exception {
<span class="nc" id="L85">    throw new Reply421Exception(&quot;Command not valid&quot;);</span>
  }

  /**
   * @param hostId
   * @param arg0
   *
   * @return True if the connection is OK (authentication is OK)
   *
   * @throws Reply530Exception if the authentication is wrong
   * @throws Reply421Exception If the service is not available
   */
  public final boolean connection(final String hostId, final byte[] arg0,
                                  final boolean isSsl)
      throws Reply530Exception, Reply421Exception {
    final DbHostAuth auth;
    try {
<span class="nc" id="L102">      auth = new DbHostAuth(hostId);</span>
<span class="nc" id="L103">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L104">      logger.error(&quot;Cannot find authentication for &quot; + hostId);</span>
<span class="nc" id="L105">      setIsIdentified(false);</span>
<span class="nc" id="L106">      currentAuth = null;</span>
<span class="nc" id="L107">      throw new Reply530Exception(&quot;HostId not allowed: &quot; + hostId);</span>
<span class="nc" id="L108">    }</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">    if (auth.isSsl() != isSsl) {</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">      if (auth.isSsl()) {</span>
<span class="nc" id="L111">        logger.error(&quot;Hostid {} must use SSL&quot;, hostId);</span>
      } else {
<span class="nc" id="L113">        logger.error(&quot;Hostid {} cannot use SSL&quot;, hostId);</span>
      }
<span class="nc" id="L115">      setIsIdentified(false);</span>
<span class="nc" id="L116">      currentAuth = null;</span>
<span class="nc" id="L117">      throw new Reply530Exception(&quot;HostId not allowed: mixed Ssl&quot;);</span>
    }
<span class="nc" id="L119">    currentAuth = auth;</span>
<span class="nc" id="L120">    role.clear();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">    if (currentAuth.isKeyValid(arg0)) {</span>
<span class="nc" id="L122">      setIsIdentified(true);</span>
<span class="nc" id="L123">      user = hostId;</span>
<span class="nc" id="L124">      setRootFromAuth();</span>
<span class="nc" id="L125">      getSession().getDir().initAfterIdentification();</span>
<span class="nc" id="L126">      isAdmin = currentAuth.isAdminrole();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      if (Configuration.configuration.getRoles().isEmpty()) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (isAdmin) {</span>
<span class="nc" id="L129">          role.setRole(ROLE.FULLADMIN);</span>
        } else {
<span class="nc" id="L131">          role.setRole(ROLE.PARTNER);</span>
        }
      } else {
<span class="nc" id="L134">        final RoleDefault configRole =</span>
<span class="nc" id="L135">            Configuration.configuration.getRoles().get(hostId);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (configRole == null) {</span>
          // set to default PARTNER
<span class="nc" id="L138">          role.setRole(ROLE.PARTNER);</span>
        } else {
<span class="nc" id="L140">          role.setRoleDefault(configRole);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">          if (role.isContaining(ROLE.FULLADMIN)) {</span>
<span class="nc" id="L142">            isAdmin = true;</span>
          }
        }
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (isAdmin) {</span>
<span class="nc" id="L146">          role.setRole(ROLE.FULLADMIN);</span>
        }
      }
<span class="nc" id="L149">      logger.debug(&quot;{}&quot;, role);</span>
<span class="nc" id="L150">      return true;</span>
    }
<span class="nc" id="L152">    throw new Reply530Exception(&quot;Key is not valid for this HostId&quot;);</span>
  }

  /**
   * Set the root relative Path from current status of Authentication (should
   * be
   * the highest level for the
   * current authentication). If setBusinessRootFromAuth returns null, by
   * default set /user.
   *
   * @throws Reply421Exception if the business root is not available
   */
  @Override
  protected final void setRootFromAuth() throws Reply421Exception {
<span class="nc" id="L166">    rootFromAuth = setBusinessRootFromAuth();</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (rootFromAuth == null) {</span>
<span class="nc" id="L168">      rootFromAuth = DirInterface.SEPARATOR;</span>
    }
<span class="nc" id="L170">  }</span>

  @Override
  protected final String setBusinessRootFromAuth() throws Reply421Exception {
<span class="nc" id="L174">    final String path = null;</span>
<span class="nc" id="L175">    final String fullpath = getAbsolutePath(null);</span>
<span class="nc" id="L176">    final File file = new File(fullpath);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">    if (!file.isDirectory()) {</span>
<span class="nc" id="L178">      throw new Reply421Exception(&quot;Filesystem not ready&quot;);</span>
    }
<span class="nc" id="L180">    return path;</span>
  }

  @Override
  protected final NextCommandReply setBusinessUser(final String arg0)
      throws Reply421Exception {
<span class="nc" id="L186">    throw new Reply421Exception(&quot;Command not valid&quot;);</span>
  }

  @Override
  public final boolean isAdmin() {
<span class="nc" id="L191">    return isAdmin;</span>
  }

  /**
   * @param roleCheck
   *
   * @return True if the current role contains the specified role to check
   */
  public final boolean isValidRole(final ROLE roleCheck) {
<span class="nc" id="L200">    final ROLE[] roles = roleCheck.getComposingRoles();</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">    for (final ROLE role1 : roles) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">      if (!role.isContaining(role1)) {</span>
<span class="nc" id="L203">        return false;</span>
      }
    }
<span class="nc" id="L206">    return true;</span>
  }

  /**
   * @return True if the associated host is using SSL
   */
  public final boolean isSsl() {
<span class="nc" id="L213">    return currentAuth.isSsl();</span>
  }

  @Override
  public final boolean isBusinessPathValid(final String newPath) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">    return newPath != null;</span>
  }

  @Override
  public String toString() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">    return &quot;Auth:&quot; + isIdentified + ' ' +</span>
<span class="nc" id="L224">           (currentAuth != null? currentAuth.toString() : &quot;no Internal Auth&quot;) +</span>
           ' ' + role;
  }

  /**
   * @param server
   *
   * @return the SimpleAuth if any for this user
   */
  public static DbHostAuth getServerAuth(final String server) {
    final DbHostAuth auth;
    try {
<span class="nc" id="L236">      auth = new DbHostAuth(server);</span>
<span class="nc" id="L237">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      if (!server.equals(Configuration.configuration.getHostId())) {</span>
<span class="nc" id="L239">        logger.warn(&quot;Cannot find the authentication &quot; + server + &quot; : {}&quot;,</span>
<span class="nc" id="L240">                    e.getMessage());</span>
      }
<span class="nc" id="L242">      return null;</span>
<span class="nc" id="L243">    }</span>
<span class="nc" id="L244">    return auth;</span>
  }

  /**
   * Special Authentication for local execution
   *
   * @param isSSL
   * @param hostid
   */
  public final void specialNoSessionAuth(final boolean isSSL,
                                         final String hostid) {
<span class="nc" id="L255">    isIdentified = true;</span>
<span class="nc" id="L256">    DbHostAuth auth = null;</span>
    try {
<span class="nc" id="L258">      auth = new DbHostAuth(hostid);</span>
<span class="nc" id="L259">    } catch (final WaarpDatabaseException ignored) {</span>
      // nothing
<span class="nc" id="L261">    }</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (auth == null) {</span>
      try {
<span class="nc" id="L264">        auth =</span>
            new DbHostAuth(hostid, &quot;127.0.0.1&quot;, 6666, isSSL, null, true, false);
<span class="nc" id="L266">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L267">        SysErrLogger.FAKE_LOGGER.syserr(e);</span>
<span class="nc" id="L268">      }</span>
    }
<span class="nc" id="L270">    role.clear();</span>
<span class="nc" id="L271">    currentAuth = auth;</span>
<span class="nc" id="L272">    setIsIdentified(true);</span>
<span class="nc" id="L273">    user = auth.getHostid(); // NOSONAR</span>
    try {
<span class="nc" id="L275">      setRootFromAuth();</span>
<span class="nc" id="L276">    } catch (final Reply421Exception ignored) {</span>
      // nothing
<span class="nc" id="L278">    }</span>
<span class="nc" id="L279">    getSession().getDir().initAfterIdentification();</span>
<span class="nc" id="L280">    isAdmin = isSSL;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (isSSL) {</span>
<span class="nc" id="L282">      role.setRole(ROLE.FULLADMIN);</span>
<span class="nc" id="L283">      user = Configuration.configuration.getAdminName();</span>
    }
<span class="nc" id="L285">  }</span>

  /**
   * connection from HTTPS (no default rights, must be set either as admin or
   * specifically through ROLEs). Only
   * &quot;false client&quot; with port with negative values are allowed.
   *
   * @param hostId
   * @param arg0
   *
   * @return True if the connection is OK (authentication is OK)
   *
   * @throws Reply530Exception if the authentication is wrong
   * @throws Reply421Exception If the service is not available
   */
  public final boolean connectionHttps(final String hostId, final byte[] arg0)
      throws Reply530Exception, Reply421Exception {
<span class="nc" id="L302">    final DbHostAuth auth = getServerAuth(hostId);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (auth == null) {</span>
<span class="nc" id="L304">      logger.error(&quot;Cannot find authentication for &quot; + hostId);</span>
<span class="nc" id="L305">      setIsIdentified(false);</span>
<span class="nc" id="L306">      currentAuth = null;</span>
<span class="nc" id="L307">      throw new Reply530Exception(&quot;HostId not allowed&quot;);</span>
    }
<span class="nc bnc" id="L309" title="All 2 branches missed.">    if (auth.getPort() &gt;= 0) {</span>
<span class="nc" id="L310">      logger.error(&quot;Authentication is unacceptable for &quot; + hostId);</span>
<span class="nc" id="L311">      setIsIdentified(false);</span>
<span class="nc" id="L312">      currentAuth = null;</span>
<span class="nc" id="L313">      throw new Reply530Exception(&quot;HostId not allowed&quot;);</span>
    }
<span class="nc" id="L315">    role.clear();</span>
<span class="nc" id="L316">    currentAuth = auth;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    if (currentAuth.isKeyValid(arg0)) {</span>
<span class="nc" id="L318">      setIsIdentified(true);</span>
<span class="nc" id="L319">      user = hostId;</span>
<span class="nc" id="L320">      setRootFromAuth();</span>
<span class="nc" id="L321">      getSession().getDir().initAfterIdentification();</span>
<span class="nc" id="L322">      isAdmin = currentAuth.isAdminrole();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (!Configuration.configuration.getRoles().isEmpty()) {</span>
<span class="nc" id="L324">        final RoleDefault configRole =</span>
<span class="nc" id="L325">            Configuration.configuration.getRoles().get(hostId);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (configRole != null) {</span>
<span class="nc" id="L327">          role.setRoleDefault(configRole);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">          if (role.isContaining(ROLE.FULLADMIN)) {</span>
<span class="nc" id="L329">            isAdmin = true;</span>
          }
        }
      }
<span class="nc bnc" id="L333" title="All 2 branches missed.">      if (isAdmin) {</span>
<span class="nc" id="L334">        role.setRole(ROLE.FULLADMIN);</span>
      }
<span class="nc" id="L336">      logger.info(&quot;{}:{}&quot;, role, currentAuth);</span>
<span class="nc" id="L337">      return true;</span>
    }
<span class="nc" id="L339">    throw new Reply530Exception(&quot;Key is not valid for this HostId&quot;);</span>
  }

  /**
   * @return a copy of the Role of the current authenticated partner
   */
  public final RoleDefault getRole() {
<span class="nc" id="L346">    return new RoleDefault().setRoleDefault(role);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>