<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HttpRequestHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Http</a> &gt; <a href="../index.html" class="el_bundle">WaarpGatewayKernel</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.kernel.http</a> &gt; <span class="el_source">HttpRequestHandler.java</span></div><h1>HttpRequestHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.gateway.kernel.http;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.codec.http.QueryStringDecoder;
import io.netty.handler.codec.http.cookie.Cookie;
import io.netty.handler.codec.http.cookie.ServerCookieDecoder;
import io.netty.handler.codec.http.cookie.ServerCookieEncoder;
import io.netty.handler.codec.http.multipart.Attribute;
import io.netty.handler.codec.http.multipart.FileUpload;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
import io.netty.handler.codec.http.multipart.InterfaceHttpData;
import io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.database.DbSession;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.gateway.kernel.AbstractHttpBusinessRequest;
import org.waarp.gateway.kernel.AbstractHttpField;
import org.waarp.gateway.kernel.AbstractHttpField.FieldPosition;
import org.waarp.gateway.kernel.AbstractHttpField.FieldRole;
import org.waarp.gateway.kernel.HttpBusinessFactory;
import org.waarp.gateway.kernel.HttpPage;
import org.waarp.gateway.kernel.HttpPage.PageRole;
import org.waarp.gateway.kernel.HttpPageHandler;
import org.waarp.gateway.kernel.database.DbConstantGateway;
import org.waarp.gateway.kernel.database.WaarpActionLogger;
import org.waarp.gateway.kernel.exception.HttpIncorrectRequestException;
import org.waarp.gateway.kernel.session.DefaultHttpAuth;
import org.waarp.gateway.kernel.session.HttpSession;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.security.SecureRandom;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 */
public abstract class HttpRequestHandler
    extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
  /**
   * Internal Logger
   */
<span class="fc" id="L90">  private static final WaarpLogger logger =</span>
<span class="fc" id="L91">      WaarpLoggerFactory.getLogger(HttpRequestHandler.class);</span>

<span class="fc" id="L93">  private static final SecureRandom random = new SecureRandom();</span>

  protected final String baseStaticPath;
  protected final String cookieSession;
  protected final HttpPageHandler httpPageHandler;

  /**
   * @param baseStaticPath
   * @param cookieSession
   * @param httpPageHandler
   */
  protected HttpRequestHandler(final String baseStaticPath,
                               final String cookieSession,
<span class="fc" id="L106">                               final HttpPageHandler httpPageHandler) {</span>
<span class="fc" id="L107">    this.baseStaticPath = baseStaticPath;</span>
<span class="fc" id="L108">    this.cookieSession = cookieSession;</span>
<span class="fc" id="L109">    this.httpPageHandler = httpPageHandler;</span>
<span class="fc" id="L110">  }</span>

  protected HttpSession session;
  protected HttpPostRequestDecoder decoder;
  protected HttpPage httpPage;
  protected AbstractHttpBusinessRequest businessRequest;

<span class="fc" id="L117">  protected HttpResponseStatus status = HttpResponseStatus.OK;</span>
  protected String errorMesg;

  protected HttpRequest request;
  protected HttpMethod method;

  protected boolean willClose;

  /**
   * Clean method
   * &lt;p&gt;
   * Override if needed
   */
  protected final void clean() {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">    if (businessRequest != null) {</span>
<span class="nc" id="L132">      businessRequest.cleanRequest();</span>
<span class="nc" id="L133">      businessRequest = null;</span>
    }
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (decoder != null) {</span>
<span class="fc" id="L136">      decoder.cleanFiles();</span>
<span class="fc" id="L137">      decoder = null;</span>
    }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (session != null) {</span>
<span class="fc" id="L140">      session.setFilename(null);</span>
<span class="fc" id="L141">      session.setLogid(DbConstantGateway.ILLEGALVALUE);</span>
    }
<span class="fc" id="L143">  }</span>

  /**
   * Called at the beginning of every new request
   * &lt;p&gt;
   * Override if needed
   */
  protected void initialize() {
    // clean previous FileUpload if Any
<span class="fc" id="L152">    clean();</span>
<span class="fc" id="L153">    willClose = false;</span>
<span class="fc" id="L154">    status = HttpResponseStatus.OK;</span>
<span class="fc" id="L155">    httpPage = null;</span>
<span class="fc" id="L156">    businessRequest = null;</span>
<span class="fc" id="L157">  }</span>

  /**
   * set values from URI
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void getUriArgs() throws HttpIncorrectRequestException {
<span class="fc" id="L165">    final QueryStringDecoder decoderQuery =</span>
<span class="fc" id="L166">        new QueryStringDecoder(request.uri());</span>
<span class="fc" id="L167">    final Map&lt;String, List&lt;String&gt;&gt; uriAttributes = decoderQuery.parameters();</span>
<span class="fc" id="L168">    final Set&lt;String&gt; attributes = uriAttributes.keySet();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">    for (final String name : attributes) {</span>
<span class="nc" id="L170">      final List&lt;String&gt; values = uriAttributes.get(name);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (values != null) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="nc" id="L174">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.URL);
<span class="nc bnc" id="L176" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
<span class="nc" id="L178">          values.clear();</span>
<span class="nc" id="L179">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
<span class="nc" id="L182">        values.clear();</span>
      }
<span class="nc" id="L184">    }</span>
<span class="fc" id="L185">  }</span>

  /**
   * set values from Header
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void getHeaderArgs() throws HttpIncorrectRequestException {
<span class="fc" id="L193">    final Set&lt;String&gt; headerNames = request.headers().names();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">    for (final String name : headerNames) {</span>
<span class="fc" id="L195">      final List&lt;String&gt; values = request.headers().getAll((CharSequence) name);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (values != null) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="fc" id="L199">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.HEADER);
<span class="nc bnc" id="L201" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
          try {
<span class="nc" id="L204">            values.clear();</span>
<span class="nc" id="L205">          } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L206">            SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L207">          }</span>
<span class="nc" id="L208">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
        try {
<span class="nc" id="L212">          values.clear();</span>
<span class="fc" id="L213">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L214">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L215">        }</span>
      }
<span class="fc" id="L217">    }</span>
<span class="fc" id="L218">  }</span>

  /**
   * set values from Cookies
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void getCookieArgs() throws HttpIncorrectRequestException {
    final Set&lt;Cookie&gt; cookies;
<span class="fc" id="L227">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L229">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L231">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    if (!cookies.isEmpty()) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L236">          httpPage.setValue(businessRequest, cookie.name(), cookie.value(),</span>
                            FieldPosition.COOKIE);
        }
<span class="nc" id="L239">      }</span>
    }
<span class="fc" id="L241">    cookies.clear();</span>
<span class="fc" id="L242">  }</span>

  /**
   * To be used for instance to check correctness of connection
   *
   * @param ctx
   */
  protected abstract void checkConnection(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Called when an error is raised. Note that clean() will be called just
   * after.
   *
   * @param ctx
   */
  protected abstract void error(ChannelHandlerContext ctx);

  @Override
  protected void channelRead0(final ChannelHandlerContext ctx,
                              final HttpObject msg) {
    try {
<span class="fc bfc" id="L264" title="All 2 branches covered.">      if (msg instanceof HttpRequest) {</span>
<span class="fc" id="L265">        initialize();</span>
<span class="fc" id="L266">        request = (HttpRequest) msg;</span>
<span class="fc" id="L267">        method = request.method();</span>
<span class="fc" id="L268">        final QueryStringDecoder queryStringDecoder =</span>
<span class="fc" id="L269">            new QueryStringDecoder(request.uri());</span>
<span class="fc" id="L270">        final String uriRequest = queryStringDecoder.path();</span>
        final HttpPage httpPageTemp;
        try {
<span class="fc" id="L273">          httpPageTemp =</span>
<span class="fc" id="L274">              httpPageHandler.getHttpPage(uriRequest, method.name(), session);</span>
<span class="fc" id="L275">        } catch (final HttpIncorrectRequestException e1) {</span>
          // real error =&gt; 400
<span class="fc" id="L277">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="fc" id="L278">          errorMesg = e1.getMessage();</span>
<span class="fc" id="L279">          writeErrorPage(ctx);</span>
<span class="fc" id="L280">          return;</span>
          // end of task
<span class="fc" id="L282">        }</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (httpPageTemp == null) {</span>
          // if Get =&gt; standard Get
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">          if (method == HttpMethod.GET) {</span>
<span class="fc" id="L286">            logger.debug(&quot;simple get: {}&quot;, request.uri());</span>
            // send content (image for instance)
<span class="fc" id="L288">            HttpWriteCacheEnable.writeFile(request, ctx,</span>
                                           baseStaticPath + uriRequest,
                                           cookieSession);
            // end of task
          } else {
            // real error =&gt; 404
<span class="nc" id="L294">            status = HttpResponseStatus.NOT_FOUND;</span>
<span class="nc" id="L295">            writeErrorPage(ctx);</span>
          }
<span class="fc" id="L297">          return;</span>
        }
<span class="fc" id="L299">        httpPage = httpPageTemp;</span>
<span class="fc" id="L300">        session.setCurrentCommand(httpPage.getPagerole());</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        final DbSession dbSession = DbConstantGateway.admin != null?</span>
<span class="pc" id="L302">            DbConstantGateway.admin.getSession() : null;</span>
<span class="fc" id="L303">        WaarpActionLogger.logCreate(dbSession, &quot;Request received: &quot; +</span>
<span class="fc" id="L304">                                               httpPage.getPagename(), session);</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (httpPageTemp.getPagerole() == PageRole.ERROR) {</span>
<span class="nc" id="L306">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L307">          error(ctx);</span>
<span class="nc" id="L308">          clean();</span>
          // order is important: first clean, then create new businessRequest
<span class="nc" id="L310">          businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="nc" id="L311">          willClose = true;</span>
<span class="nc" id="L312">          writeSimplePage(ctx);</span>
<span class="nc" id="L313">          WaarpActionLogger.logErrorAction(DbConstantGateway.admin.getSession(),</span>
                                           session,
<span class="nc" id="L315">                                           &quot;Error: &quot; + httpPage.getPagename(),</span>
                                           status);
<span class="nc" id="L317">          return;</span>
          // end of task
        }
<span class="fc" id="L320">        businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="fc" id="L321">        getUriArgs();</span>
<span class="fc" id="L322">        getHeaderArgs();</span>
<span class="fc" id="L323">        getCookieArgs();</span>
<span class="fc" id="L324">        checkConnection(ctx);</span>
<span class="pc bpc" id="L325" title="1 of 5 branches missed.">        switch (httpPage.getPagerole()) {</span>
          case DELETE:
            // no body element
<span class="fc" id="L328">            delete(ctx);</span>
<span class="fc" id="L329">            return;</span>
          case GETDOWNLOAD:
            // no body element
<span class="fc" id="L332">            getFile(ctx);</span>
<span class="fc" id="L333">            return;</span>
          case HTML:
          case MENU:
            // no body element
<span class="fc" id="L337">            beforeSimplePage(ctx);</span>
<span class="fc" id="L338">            writeSimplePage(ctx);</span>
<span class="fc" id="L339">            return;</span>
          case POST:
          case POSTUPLOAD:
          case PUT:
<span class="fc" id="L343">            post(ctx);</span>
<span class="fc" id="L344">            return;</span>
          default:
            // real error =&gt; 400
<span class="nc" id="L347">            status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L348">            writeErrorPage(ctx);</span>
        }
<span class="nc" id="L350">      } else {</span>
        // New chunk is received: only for Put, Post or PostMulti!
<span class="fc" id="L352">        postChunk(ctx, (HttpContent) msg);</span>
      }
<span class="fc" id="L354">    } catch (final HttpIncorrectRequestException e1) {</span>
      // real error =&gt; 400
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L357">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="fc" id="L359">      errorMesg = e1.getMessage();</span>
<span class="fc" id="L360">      logger.warn(&quot;Error {}&quot;, e1.getMessage());</span>
<span class="fc" id="L361">      writeErrorPage(ctx);</span>
<span class="fc" id="L362">    }</span>
<span class="fc" id="L363">  }</span>

  /**
   * Utility to prepare error
   *
   * @param ctx
   * @param message
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void prepareError(final ChannelHandlerContext ctx,
                                    final String message)
      throws HttpIncorrectRequestException {
<span class="nc" id="L376">    logger.debug(&quot;Debug {}&quot;, message);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L379">      return;</span>
    }
<span class="nc" id="L381">    errorMesg = status.reasonPhrase() + &quot; / &quot; + message;</span>
<span class="nc" id="L382">    throw new HttpIncorrectRequestException(errorMesg);</span>
  }

  /**
   * Instantiate the page and the businessRequest handler
   *
   * @param ctx
   *
   * @return True if initialized
   */
  protected final boolean setErrorPage(final ChannelHandlerContext ctx) {
<span class="fc" id="L393">    httpPage = httpPageHandler.getHttpPage(status.code());</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">    if (httpPage == null) {</span>
<span class="nc" id="L395">      return false;</span>
    }
<span class="fc" id="L397">    businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="fc" id="L398">    return true;</span>
  }

  /**
   * Write an error page
   *
   * @param ctx
   */
  protected final void writeErrorPage(final ChannelHandlerContext ctx) {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    final DbSession dbSession =</span>
<span class="pc" id="L408">        DbConstantGateway.admin != null? DbConstantGateway.admin.getSession() :</span>
            null;
<span class="fc bfc" id="L410" title="All 2 branches covered.">    WaarpActionLogger.logErrorAction(dbSession, session, &quot;Error: &quot; +</span>
                                                         (httpPage == null?
                                                             &quot;no page&quot; :
<span class="fc" id="L413">                                                             httpPage.getPagename()),</span>
                                     status);
<span class="fc" id="L415">    error(ctx);</span>
<span class="fc" id="L416">    clean();</span>
<span class="fc" id="L417">    willClose = true;</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L420">      forceClosing(ctx);</span>
<span class="nc" id="L421">      return;</span>
    }
    try {
<span class="fc" id="L424">      writeSimplePage(ctx);</span>
<span class="nc" id="L425">    } catch (final HttpIncorrectRequestException e) {</span>
      // force channel closing
<span class="nc" id="L427">      forceClosing(ctx);</span>
<span class="fc" id="L428">    }</span>
<span class="fc" id="L429">  }</span>

  /**
   * To allow quick answer even if in very bad shape
   *
   * @param ctx
   */
  protected final void forceClosing(final ChannelHandlerContext ctx) {
<span class="nc bnc" id="L437" title="All 2 branches missed.">    if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L438">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
    }
<span class="nc bnc" id="L440" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc" id="L441">      willClose = true;</span>
<span class="nc" id="L442">      final String answer =</span>
<span class="nc" id="L443">          &quot;&lt;html&gt;&lt;body&gt;Error &quot; + status.reasonPhrase() + &quot;&lt;/body&gt;&lt;/html&gt;&quot;;</span>
<span class="nc" id="L444">      final FullHttpResponse response = getResponse(</span>
<span class="nc" id="L445">          Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8)));</span>
<span class="nc" id="L446">      response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
<span class="nc" id="L447">      response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="nc" id="L448">      final ChannelFuture future = ctx.writeAndFlush(response);</span>
<span class="nc" id="L449">      logger.debug(&quot;Will close&quot;);</span>
<span class="nc" id="L450">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="nc" id="L452">    WaarpActionLogger.logErrorAction(DbConstantGateway.admin.getSession(),</span>
                                     session,
<span class="nc" id="L454">                                     &quot;Error: &quot; + httpPage.getPagename(),</span>
                                     status);
<span class="nc" id="L456">  }</span>

  /**
   * Write a simple page from current httpPage and businessRequest
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void writeSimplePage(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc bfc" id="L467" title="All 2 branches covered.">    logger.debug(&quot;HttpPage: {} businessRequest: {}&quot;,</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                 httpPage != null? httpPage.getPagename() : &quot;no page&quot;,</span>
<span class="pc" id="L469">                 businessRequest != null? businessRequest.getClass().getName() :</span>
                     &quot;no BR&quot;);
<span class="fc bfc" id="L471" title="All 4 branches covered.">    if (httpPage != null &amp;&amp; httpPage.getPagerole() == PageRole.ERROR) {</span>
      try {
<span class="fc" id="L473">        httpPage.setValue(businessRequest, AbstractHttpField.ERRORINFO,</span>
                          errorMesg, FieldPosition.BODY);
<span class="nc" id="L475">      } catch (final HttpIncorrectRequestException e) {</span>
        // ignore
<span class="fc" id="L477">      }</span>
    }
<span class="fc bfc" id="L479" title="All 2 branches covered.">    final String answer =</span>
<span class="fc" id="L480">        httpPage != null? httpPage.getHtmlPage(businessRequest) : &quot;BAD REQUEST&quot;;</span>
    final int length;
    // Convert the response content to a ByteBuf.
<span class="fc" id="L483">    final ByteBuf buf =</span>
<span class="fc" id="L484">        Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8));</span>
<span class="fc" id="L485">    final FullHttpResponse response = getResponse(buf);</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">    if (businessRequest == null) {</span>
<span class="fc" id="L487">      response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
    } else {
<span class="nc" id="L489">      response.headers().set(HttpHeaderNames.CONTENT_TYPE,</span>
<span class="nc" id="L490">                             businessRequest.getContentType());</span>
    }
<span class="fc" id="L492">    response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="fc" id="L493">    length = buf.readableBytes();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">    if (!willClose) {</span>
      // There's no need to add 'Content-Length' header
      // if this is the last response.
<span class="nc" id="L497">      response.headers()</span>
<span class="nc" id="L498">              .set(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(length));</span>
    }
    // Write the response.
<span class="fc" id="L501">    final ChannelFuture future = ctx.writeAndFlush(response);</span>
    // Close the connection after the write operation is done if necessary.
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    if (willClose) {</span>
<span class="fc" id="L504">      logger.debug(&quot;Will close&quot;);</span>
<span class="fc" id="L505">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="fc" id="L507">  }</span>

  /**
   * Could be used for other method (as validation of an authent cookie)
   *
   * @param cookie
   *
   * @return True if this cookie is valid
   */
  protected abstract boolean isCookieValid(Cookie cookie);

  /**
   * Method to add specific Cookies from business definition
   * &lt;p&gt;
   * Override if needed
   *
   * @param response
   * @param cookieNames
   */
  protected final void addBusinessCookie(final FullHttpResponse response,
                                         final Set&lt;String&gt; cookieNames) {
<span class="fc bfc" id="L528" title="All 2 branches covered.">    if (httpPage != null) {</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">      for (final AbstractHttpField field : httpPage.getFieldsForRequest(</span>
<span class="fc" id="L530">          businessRequest).values()) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (field.isFieldcookieset() &amp;&amp;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            !cookieNames.contains(field.getFieldname())) {</span>
<span class="nc" id="L533">          response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="nc" id="L534">                                 ServerCookieEncoder.LAX.encode(</span>
<span class="nc" id="L535">                                     field.getFieldname(), field.fieldvalue));</span>
        }
<span class="nc" id="L537">      }</span>
    }
<span class="fc" id="L539">  }</span>

  /**
   * Method to set Cookies in response
   *
   * @param response
   */
  protected final void setCookieEncoder(final FullHttpResponse response) {
    final Set&lt;Cookie&gt; cookies;
<span class="fc" id="L548">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L550">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L552">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="fc" id="L554">    boolean foundCookieSession = false;</span>
<span class="fc" id="L555">    final Set&lt;String&gt; cookiesName = new HashSet&lt;String&gt;();</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">    if (!cookies.isEmpty()) {</span>
      // Reset the cookies if necessary.
<span class="nc bnc" id="L558" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L560">          response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="nc" id="L561">                                 ServerCookieEncoder.LAX.encode(cookie));</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">          if (cookie.name().equals(cookieSession)) {</span>
<span class="nc" id="L563">            foundCookieSession = true;</span>
          }
<span class="nc" id="L565">          cookiesName.add(cookie.name());</span>
        }
<span class="nc" id="L567">      }</span>
    }
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">    if (!foundCookieSession) {</span>
<span class="fc" id="L570">      response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="fc" id="L571">                             ServerCookieEncoder.LAX.encode(cookieSession,</span>
<span class="fc" id="L572">                                                            session.getCookieSession()));</span>
<span class="fc" id="L573">      cookiesName.add(cookieSession);</span>
    }
<span class="fc" id="L575">    addBusinessCookie(response, cookiesName);</span>
<span class="fc" id="L576">    cookiesName.clear();</span>
<span class="fc" id="L577">  }</span>

  /**
   * @param buf might be null
   *
   * @return the Http Response according to the status
   */
  protected final FullHttpResponse getResponse(final ByteBuf buf) {
    // Decide whether to close the connection or not.
    final FullHttpResponse response;
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">    if (request == null) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">      if (buf != null) {</span>
<span class="nc" id="L589">        response =</span>
            new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status, buf);
<span class="nc" id="L591">        response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="nc" id="L592">                               response.content().readableBytes());</span>
      } else {
<span class="nc" id="L594">        response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status);</span>
      }
<span class="nc" id="L596">      setCookieEncoder(response);</span>
<span class="nc" id="L597">      willClose = true;</span>
<span class="nc" id="L598">      return response;</span>
    }
<span class="fc" id="L600">    boolean keepAlive = HttpUtil.isKeepAlive(request);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">    willClose |= status != HttpResponseStatus.OK ||</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">                 HttpHeaderValues.CLOSE.contentEqualsIgnoreCase(</span>
<span class="fc" id="L603">                     request.headers().get(HttpHeaderNames.CONNECTION)) ||</span>
<span class="pc bnc" id="L604" title="All 4 branches missed.">                 request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp;</span>
                 !keepAlive;
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">    if (willClose) {</span>
<span class="fc" id="L607">      keepAlive = false;</span>
    }
    // Build the response object.
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">    if (buf != null) {</span>
<span class="fc" id="L611">      response =</span>
<span class="fc" id="L612">          new DefaultFullHttpResponse(request.protocolVersion(), status, buf);</span>
<span class="fc" id="L613">      response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="fc" id="L614">                             response.content().readableBytes());</span>
    } else {
<span class="nc" id="L616">      response = new DefaultFullHttpResponse(request.protocolVersion(), status);</span>
    }
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">    if (keepAlive) {</span>
<span class="nc" id="L619">      response.headers()</span>
<span class="nc" id="L620">              .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span>
    }
<span class="fc" id="L622">    setCookieEncoder(response);</span>
<span class="fc" id="L623">    return response;</span>
  }

  /**
   * @return the filename used for this request
   */
  protected abstract String getFilename();

  /**
   * Called before simple Page is called (Menu or HTML)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected abstract void beforeSimplePage(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the result and send back the result
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void finalData(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="fc" id="L651">      businessValidRequestAfterAllDataReceived(ctx);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">      if (httpPage == null) {</span>
        // Cached
<span class="fc" id="L654">        return;</span>
      }
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">      if (!httpPage.isRequestValid(businessRequest)) {</span>
<span class="nc" id="L657">        throw new HttpIncorrectRequestException(&quot;Request unvalid&quot;);</span>
      }
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">      final DbSession dbSession = DbConstantGateway.admin != null?</span>
<span class="pc" id="L660">          DbConstantGateway.admin.getSession() : null;</span>
<span class="pc bpc" id="L661" title="1 of 6 branches missed.">      switch (httpPage.getPagerole()) {</span>
        case DELETE:
<span class="fc" id="L663">          session.setFilename(getFilename());</span>
<span class="fc" id="L664">          finalDelete(ctx);</span>
<span class="fc" id="L665">          WaarpActionLogger.logAction(dbSession, session, &quot;Delete OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L667">          break;</span>
        case GETDOWNLOAD:
<span class="fc" id="L669">          finalGet(ctx);</span>
<span class="fc" id="L670">          WaarpActionLogger.logAction(dbSession, session, &quot;Download OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L672">          break;</span>
        case POST:
<span class="fc" id="L674">          finalPost(ctx);</span>
<span class="fc" id="L675">          WaarpActionLogger.logAction(dbSession, session, &quot;Post OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L677">          break;</span>
        case POSTUPLOAD:
<span class="nc" id="L679">          finalPostUpload(ctx);</span>
<span class="nc" id="L680">          WaarpActionLogger.logAction(dbSession, session, &quot;PostUpload OK&quot;,</span>
                                      status, UpdatedInfo.DONE);
<span class="nc" id="L682">          break;</span>
        case PUT:
<span class="fc" id="L684">          finalPut(ctx);</span>
<span class="fc" id="L685">          WaarpActionLogger.logAction(dbSession, session, &quot;Put OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L687">          break;</span>
        default:
          // real error =&gt; 400
<span class="fc" id="L690">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="fc" id="L691">          throw new HttpIncorrectRequestException(&quot;Unknown request&quot;);</span>
      }
<span class="fc" id="L693">    } catch (final HttpIncorrectRequestException e) {</span>
      // real error =&gt; 400
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L696">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="fc" id="L698">      throw e;</span>
<span class="fc" id="L699">    }</span>
<span class="fc" id="L700">  }</span>

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalDelete(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and send back the result &lt;br&gt;
   * (this method must send back the answer using for instance a ChunkedInput
   * handler and should try to call
   * clean(), but taking into consideration that it will erase all data, so it
   * must be ensured that all data are
   * sent through the wire before calling it. Note however that when the
   * connection is closed or when a new
   * request on the same connection occurs, the clean method is automatically
   * called. The usage of a
   * HttpCleanChannelFutureListener on the last write might be useful.)
   *
   * @param ctx
   */
  protected abstract void finalGet(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPostUpload(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the post result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPost(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the put result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPut(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Validate all data as they should be all received (done before the
   * isRequestValid)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  public abstract void businessValidRequestAfterAllDataReceived(
      ChannelHandlerContext ctx) throws HttpIncorrectRequestException;

  /**
   * Method that get &quot;get&quot; data, answer has to be written in the business part
   * finalGet
   *
   * @param ctx
   */
  protected final void getFile(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc" id="L770">    finalData(ctx);</span>
<span class="fc" id="L771">  }</span>

  /**
   * Method that get delete data
   *
   * @param ctx
   */
  protected final void delete(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc" id="L780">    finalData(ctx);</span>
<span class="fc" id="L781">    writeSimplePage(ctx);</span>
<span class="fc" id="L782">    clean();</span>
<span class="fc" id="L783">  }</span>

  /**
   * Method that get post data
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void post(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="fc" id="L795">      decoder =</span>
          new HttpPostRequestDecoder(HttpBusinessFactory.factory, request);
<span class="nc" id="L797">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L798">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L799">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L800">    } catch (final Exception e1) {</span>
      // GETDOWNLOAD Method: should not try to create a HttpPostRequestDecoder
      // So OK but stop here
<span class="nc" id="L803">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L804">      throw new HttpIncorrectRequestException(e1);</span>
<span class="fc" id="L805">    }</span>

<span class="pc bpc" id="L807" title="1 of 2 branches missed.">    if (request instanceof FullHttpRequest) {</span>
      // Not chunk version
<span class="nc" id="L809">      readHttpDataAllReceive(ctx);</span>
<span class="nc" id="L810">      finalData(ctx);</span>
<span class="nc" id="L811">      writeSimplePage(ctx);</span>
<span class="nc" id="L812">      clean();</span>
    }
<span class="fc" id="L814">  }</span>

  /**
   * Method that get a chunk of data
   *
   * @param ctx
   * @param chunk
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void postChunk(final ChannelHandlerContext ctx,
                                 final HttpContent chunk)
      throws HttpIncorrectRequestException {
    // New chunk is received: only for Post!
<span class="fc bfc" id="L828" title="All 2 branches covered.">    if (decoder == null) {</span>
<span class="fc" id="L829">      finalData(ctx);</span>
<span class="fc" id="L830">      writeSimplePage(ctx);</span>
<span class="fc" id="L831">      clean();</span>
<span class="fc" id="L832">      return;</span>
    }
    try {
<span class="fc" id="L835">      decoder.offer(chunk);</span>
<span class="nc" id="L836">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L837">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L838">      throw new HttpIncorrectRequestException(e1);</span>
<span class="fc" id="L839">    }</span>
    // example of reading chunk by chunk (minimize memory usage due to
    // Factory)
<span class="fc" id="L842">    readHttpDataChunkByChunk(ctx);</span>
    // example of reading only if at the end
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    if (chunk instanceof LastHttpContent) {</span>
<span class="fc" id="L845">      finalData(ctx);</span>
<span class="fc" id="L846">      writeSimplePage(ctx);</span>
<span class="fc" id="L847">      clean();</span>
    }
<span class="fc" id="L849">  }</span>

  @Override
  public void exceptionCaught(final ChannelHandlerContext ctx,
                              final Throwable cause) {
<span class="nc bnc" id="L854" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">      if (cause != null &amp;&amp; cause.getMessage() != null) {</span>
<span class="nc" id="L856">        logger.warn(&quot;Exception {}&quot;, cause.getMessage());</span>
      } else {
<span class="nc" id="L858">        logger.warn(&quot;Exception Received&quot;, cause);</span>
      }
<span class="nc bnc" id="L860" title="All 2 branches missed.">      if (cause instanceof ClosedChannelException) {</span>
<span class="nc" id="L861">        return;</span>
      }
<span class="nc" id="L863">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L864">      writeErrorPage(ctx);</span>
    }
<span class="nc" id="L866">  }</span>

  @Override
  public void channelInactive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="fc" id="L871">    super.channelInactive(ctx);</span>
<span class="fc" id="L872">    clean();</span>
<span class="fc" id="L873">  }</span>

  /**
   * Read all InterfaceHttpData from finished transfer
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readHttpDataAllReceive(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    final List&lt;InterfaceHttpData&gt; datas;
    try {
<span class="nc" id="L886">      datas = decoder.getBodyHttpDatas();</span>
<span class="nc" id="L887">    } catch (final NotEnoughDataDecoderException e1) {</span>
      // Should not be!
<span class="nc" id="L889">      logger.warn(&quot;decoder issue&quot; + &quot; : {}&quot;, e1.getMessage());</span>
<span class="nc" id="L890">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L891">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L892">    }</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">    for (final InterfaceHttpData data : datas) {</span>
<span class="nc" id="L894">      readHttpData(data, ctx);</span>
<span class="nc" id="L895">    }</span>
<span class="nc" id="L896">  }</span>

  /**
   * Read request by chunk and getting values from chunk to chunk
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readHttpDataChunkByChunk(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">      while (decoder.hasNext()) {</span>
<span class="nc" id="L909">        final InterfaceHttpData data = decoder.next();</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (data != null) {</span>
          // new value
<span class="nc" id="L912">          readHttpData(data, ctx);</span>
        }
<span class="nc" id="L914">      }</span>
<span class="nc" id="L915">    } catch (final EndOfDataDecoderException e1) {</span>
      // end
<span class="fc" id="L917">    }</span>
<span class="fc" id="L918">  }</span>

  /**
   * Read one Data
   *
   * @param data
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected final void readHttpData(final InterfaceHttpData data,
                                    final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc bnc" id="L931" title="All 2 branches missed.">    if (data.getHttpDataType() == HttpDataType.Attribute) {</span>
<span class="nc" id="L932">      final Attribute attribute = (Attribute) data;</span>
<span class="nc" id="L933">      final String name = attribute.getName();</span>
      try {
<span class="nc" id="L935">        final String value = attribute.getValue();</span>
<span class="nc" id="L936">        httpPage.setValue(businessRequest, name, value, FieldPosition.BODY);</span>
<span class="nc" id="L937">      } catch (final IOException e) {</span>
        // Error while reading data from File, only print name and
        // error
<span class="nc" id="L940">        attribute.delete();</span>
<span class="nc" id="L941">        status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L942">        throw new HttpIncorrectRequestException(e);</span>
<span class="nc" id="L943">      }</span>
<span class="nc" id="L944">      attribute.delete();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">    } else if (data.getHttpDataType() == HttpDataType.FileUpload) {</span>
<span class="nc" id="L946">      final FileUpload fileUpload = (FileUpload) data;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">      if (fileUpload.isCompleted()) {</span>
<span class="nc" id="L948">        final AbstractHttpField field =</span>
<span class="nc" id="L949">            httpPage.getField(businessRequest, fileUpload.getName());</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (field != null &amp;&amp;</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">            field.getFieldtype() == FieldRole.BUSINESS_INPUT_FILE) {</span>
<span class="nc" id="L952">          httpPage.setValue(businessRequest, field.getFieldname(), fileUpload);</span>
        } else {
<span class="nc" id="L954">          logger.warn(&quot;File received but no variable for it&quot;);</span>
<span class="nc" id="L955">          fileUpload.delete();</span>
        }
<span class="nc" id="L957">      } else {</span>
<span class="nc" id="L958">        logger.warn(&quot;File still pending but should not&quot;);</span>
<span class="nc" id="L959">        fileUpload.delete();</span>
      }
<span class="nc" id="L961">    } else {</span>
<span class="nc" id="L962">      logger.warn(&quot;Unknown element: &quot; + data);</span>
    }
<span class="nc" id="L964">  }</span>

  /**
   * Default Session Cookie generator
   *
   * @return the new session cookie value
   */
  protected final String getNewCookieSession() {
<span class="fc" id="L972">    return &quot;Waarp&quot; + Long.toHexString(random.nextLong());</span>
  }

  /**
   * Default session creation
   *
   * @param ctx
   */
  protected final void createNewSessionAtConnection(
      final ChannelHandlerContext ctx) {
<span class="fc" id="L982">    session = new HttpSession();</span>
<span class="fc" id="L983">    session.setHttpAuth(new DefaultHttpAuth(session));</span>
<span class="fc" id="L984">    session.setCookieSession(getNewCookieSession());</span>
<span class="fc" id="L985">    session.setCurrentCommand(PageRole.HTML);</span>
<span class="fc" id="L986">  }</span>

  @Override
  public void channelActive(final ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L990">    super.channelActive(ctx);</span>
<span class="fc" id="L991">    createNewSessionAtConnection(ctx);</span>
<span class="fc" id="L992">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>