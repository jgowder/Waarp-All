<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FseTableReader.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Http</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdunsafe</a> &gt; <span class="el_source">FseTableReader.java</span></div><h1>FseTableReader.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdunsafe;

<span class="fc" id="L36">class FseTableReader {</span>
<span class="fc" id="L37">  private final short[] nextSymbol =</span>
      new short[FiniteStateEntropy.MAX_SYMBOL + 1];
<span class="fc" id="L39">  private final short[] normalizedCounters =</span>
      new short[FiniteStateEntropy.MAX_SYMBOL + 1];

  public int readFseTable(final FiniteStateEntropy.Table table,
                          final Object inputBase, final long inputAddress,
                          final long inputLimit, int maxSymbol,
                          final int maxTableLog) {
    // read table headers
<span class="fc" id="L47">    long input = inputAddress;</span>
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">    Util.verify(inputLimit - inputAddress &gt;= 4, input,</span>
                &quot;Not enough input bytes&quot;);

    int threshold;
<span class="fc" id="L52">    int symbolNumber = 0;</span>
<span class="fc" id="L53">    boolean previousIsZero = false;</span>

<span class="fc" id="L55">    int bitStream = UnsafeUtil.UNSAFE.getInt(inputBase, input);</span>

<span class="fc" id="L57">    final int tableLog = (bitStream &amp; 0xF) + FiniteStateEntropy.MIN_TABLE_LOG;</span>

<span class="fc" id="L59">    int numberOfBits = tableLog + 1;</span>
<span class="fc" id="L60">    bitStream &gt;&gt;&gt;= 4;</span>
<span class="fc" id="L61">    int bitCount = 4;</span>

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">    Util.verify(tableLog &lt;= maxTableLog, input,</span>
                &quot;FSE table size exceeds maximum allowed size&quot;);

<span class="fc" id="L66">    int remaining = (1 &lt;&lt; tableLog) + 1;</span>
<span class="fc" id="L67">    threshold = 1 &lt;&lt; tableLog;</span>

<span class="pc bpc" id="L69" title="1 of 4 branches missed.">    while (remaining &gt; 1 &amp;&amp; symbolNumber &lt;= maxSymbol) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">      if (previousIsZero) {</span>
<span class="fc" id="L71">        int n0 = symbolNumber;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        while ((bitStream &amp; 0xFFFF) == 0xFFFF) {</span>
<span class="fc" id="L73">          n0 += 24;</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">          if (input &lt; inputLimit - 5) {</span>
<span class="fc" id="L75">            input += 2;</span>
<span class="fc" id="L76">            bitStream =</span>
<span class="fc" id="L77">                (UnsafeUtil.UNSAFE.getInt(inputBase, input) &gt;&gt;&gt; bitCount);</span>
          } else {
            // end of bit stream
<span class="nc" id="L80">            bitStream &gt;&gt;&gt;= 16;</span>
<span class="nc" id="L81">            bitCount += 16;</span>
          }
        }
<span class="fc bfc" id="L84" title="All 2 branches covered.">        while ((bitStream &amp; 3) == 3) {</span>
<span class="fc" id="L85">          n0 += 3;</span>
<span class="fc" id="L86">          bitStream &gt;&gt;&gt;= 2;</span>
<span class="fc" id="L87">          bitCount += 2;</span>
        }
<span class="fc" id="L89">        n0 += bitStream &amp; 3;</span>
<span class="fc" id="L90">        bitCount += 2;</span>

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        Util.verify(n0 &lt;= maxSymbol, input, &quot;Symbol larger than max value&quot;);</span>

<span class="fc bfc" id="L94" title="All 2 branches covered.">        while (symbolNumber &lt; n0) {</span>
<span class="fc" id="L95">          normalizedCounters[symbolNumber++] = 0;</span>
        }
<span class="pc bpc" id="L97" title="1 of 4 branches missed.">        if ((input &lt;= inputLimit - 7) ||</span>
            (input + (bitCount &gt;&gt;&gt; 3) &lt;= inputLimit - 4)) {
<span class="fc" id="L99">          input += bitCount &gt;&gt;&gt; 3;</span>
<span class="fc" id="L100">          bitCount &amp;= 7;</span>
<span class="fc" id="L101">          bitStream = UnsafeUtil.UNSAFE.getInt(inputBase, input) &gt;&gt;&gt; bitCount;</span>
        } else {
<span class="nc" id="L103">          bitStream &gt;&gt;&gt;= 2;</span>
        }
      }

<span class="fc" id="L107">      final short max = (short) ((2 * threshold - 1) - remaining);</span>
      short count;

<span class="fc bfc" id="L110" title="All 2 branches covered.">      if ((bitStream &amp; (threshold - 1)) &lt; max) {</span>
<span class="fc" id="L111">        count = (short) (bitStream &amp; (threshold - 1));</span>
<span class="fc" id="L112">        bitCount += numberOfBits - 1;</span>
      } else {
<span class="fc" id="L114">        count = (short) (bitStream &amp; (2 * threshold - 1));</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (count &gt;= threshold) {</span>
<span class="fc" id="L116">          count -= max;</span>
        }
<span class="fc" id="L118">        bitCount += numberOfBits;</span>
      }
<span class="fc" id="L120">      count--;  // extra accuracy</span>

<span class="fc" id="L122">      remaining -= Math.abs(count);</span>
<span class="fc" id="L123">      normalizedCounters[symbolNumber++] = count;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">      previousIsZero = count == 0;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">      while (remaining &lt; threshold) {</span>
<span class="fc" id="L126">        numberOfBits--;</span>
<span class="fc" id="L127">        threshold &gt;&gt;&gt;= 1;</span>
      }

<span class="pc bpc" id="L130" title="1 of 4 branches missed.">      if ((input &lt;= inputLimit - 7) ||</span>
          (input + (bitCount &gt;&gt; 3) &lt;= inputLimit - 4)) {
<span class="fc" id="L132">        input += bitCount &gt;&gt;&gt; 3;</span>
<span class="fc" id="L133">        bitCount &amp;= 7;</span>
      } else {
<span class="nc" id="L135">        bitCount -= (int) (8 * (inputLimit - 4 - input));</span>
<span class="nc" id="L136">        input = inputLimit - 4;</span>
      }
<span class="fc" id="L138">      bitStream =</span>
<span class="fc" id="L139">          UnsafeUtil.UNSAFE.getInt(inputBase, input) &gt;&gt;&gt; (bitCount &amp; 31);</span>
<span class="fc" id="L140">    }</span>

<span class="pc bpc" id="L142" title="2 of 4 branches missed.">    Util.verify(remaining == 1 &amp;&amp; bitCount &lt;= 32, input, &quot;Input is corrupted&quot;);</span>

<span class="fc" id="L144">    maxSymbol = symbolNumber - 1;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    Util.verify(maxSymbol &lt;= FiniteStateEntropy.MAX_SYMBOL, input,</span>
                &quot;Max symbol value too large (too many symbols for FSE)&quot;);

<span class="fc" id="L148">    input += (bitCount + 7) &gt;&gt; 3;</span>

    // populate decoding table
<span class="fc" id="L151">    final int symbolCount = maxSymbol + 1;</span>
<span class="fc" id="L152">    final int tableSize = 1 &lt;&lt; tableLog;</span>
<span class="fc" id="L153">    int highThreshold = tableSize - 1;</span>

<span class="fc" id="L155">    table.log2Size = tableLog;</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">    for (byte symbol = 0; symbol &lt; symbolCount; symbol++) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">      if (normalizedCounters[symbol] == -1) {</span>
<span class="fc" id="L159">        table.symbol[highThreshold--] = symbol;</span>
<span class="fc" id="L160">        nextSymbol[symbol] = 1;</span>
      } else {
<span class="fc" id="L162">        nextSymbol[symbol] = normalizedCounters[symbol];</span>
      }
    }

<span class="fc" id="L166">    final int position =</span>
<span class="fc" id="L167">        FseCompressionTable.spreadSymbols(normalizedCounters, maxSymbol,</span>
                                          tableSize, highThreshold,
                                          table.symbol);

    // position must reach all cells once, otherwise normalizedCounter is incorrect
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    Util.verify(position == 0, input, &quot;Input is corrupted&quot;);</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">    for (int i = 0; i &lt; tableSize; i++) {</span>
<span class="fc" id="L175">      final byte symbol = table.symbol[i];</span>
<span class="fc" id="L176">      final short nextState = nextSymbol[symbol]++;</span>
<span class="fc" id="L177">      table.numberOfBits[i] = (byte) (tableLog - Util.highestBit(nextState));</span>
<span class="fc" id="L178">      table.newState[i] =</span>
          (short) ((nextState &lt;&lt; table.numberOfBits[i]) - tableSize);
    }

<span class="fc" id="L182">    return (int) (input - inputAddress);</span>
  }

  public static void initializeRleTable(final FiniteStateEntropy.Table table,
                                        final byte value) {
<span class="nc" id="L187">    table.log2Size = 0;</span>
<span class="nc" id="L188">    table.symbol[0] = value;</span>
<span class="nc" id="L189">    table.newState[0] = 0;</span>
<span class="nc" id="L190">    table.numberOfBits[0] = 0;</span>
<span class="nc" id="L191">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>