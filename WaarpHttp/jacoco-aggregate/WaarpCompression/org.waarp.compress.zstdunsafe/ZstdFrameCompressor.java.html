<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ZstdFrameCompressor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Http</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdunsafe</a> &gt; <span class="el_source">ZstdFrameCompressor.java</span></div><h1>ZstdFrameCompressor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdunsafe;

import static org.waarp.compress.zstdunsafe.Constants.*;
import static org.waarp.compress.zstdunsafe.Huffman.*;
import static org.waarp.compress.zstdunsafe.UnsafeUtil.*;
import static org.waarp.compress.zstdunsafe.Util.*;
import static sun.misc.Unsafe.*;

class ZstdFrameCompressor {
  static final int MAX_FRAME_HEADER_SIZE = 14;

  private static final int CHECKSUM_FLAG = 0x4;
  private static final int SINGLE_SEGMENT_FLAG = 0x20;

  private static final int MINIMUM_LITERALS_SIZE = 63;

  // the maximum table log allowed for literal encoding per RFC 8478, section 4.2.1
  private static final int MAX_HUFFMAN_TABLE_LOG = 11;
  public static final String OUTPUT_BUFFER_TOO_SMALL =
      &quot;Output buffer too small&quot;;

  private ZstdFrameCompressor() {
  }

  // visible for testing
  static int writeMagic(final Object outputBase, final long outputAddress,
                        final long outputLimit) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">    checkArgument(outputLimit - outputAddress &gt;= SIZE_OF_INT,</span>
                  OUTPUT_BUFFER_TOO_SMALL);

<span class="fc" id="L64">    UNSAFE.putInt(outputBase, outputAddress, MAGIC_NUMBER);</span>
<span class="fc" id="L65">    return SIZE_OF_INT;</span>
  }

  // visible for testing
  static int writeFrameHeader(final Object outputBase, final long outputAddress,
                              final long outputLimit, final int inputSize,
                              final int windowSize) {
<span class="fc bfc" id="L72" title="All 2 branches covered.">    checkArgument(outputLimit - outputAddress &gt;= MAX_FRAME_HEADER_SIZE,</span>
                  OUTPUT_BUFFER_TOO_SMALL);

<span class="fc" id="L75">    long output = outputAddress;</span>

<span class="fc bfc" id="L77" title="All 4 branches covered.">    final int contentSizeDescriptor =</span>
        (inputSize &gt;= 256? 1 : 0) + (inputSize &gt;= 65536 + 256? 1 : 0);
<span class="fc" id="L79">    int frameHeaderDescriptor =</span>
        (contentSizeDescriptor &lt;&lt; 6) | CHECKSUM_FLAG; // dictionary ID missing

<span class="fc bfc" id="L82" title="All 2 branches covered.">    final boolean singleSegment = windowSize &gt;= inputSize;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">    if (singleSegment) {</span>
<span class="fc" id="L84">      frameHeaderDescriptor |= SINGLE_SEGMENT_FLAG;</span>
    }

<span class="fc" id="L87">    UNSAFE.putByte(outputBase, output, (byte) frameHeaderDescriptor);</span>
<span class="fc" id="L88">    output++;</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (!singleSegment) {</span>
<span class="fc" id="L91">      final int base = Integer.highestOneBit(windowSize);</span>

<span class="fc" id="L93">      final int exponent = 32 - Integer.numberOfLeadingZeros(base) - 1;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">      if (exponent &lt; MIN_WINDOW_LOG) {</span>
<span class="fc" id="L95">        throw new IllegalArgumentException(</span>
            &quot;Minimum window size is &quot; + (1 &lt;&lt; MIN_WINDOW_LOG));
      }

<span class="fc" id="L99">      final int remainder = windowSize - base;</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">      if (remainder % (base / 8) != 0) {</span>
<span class="fc" id="L101">        throw new IllegalArgumentException(</span>
            &quot;Window size of magnitude 2^&quot; + exponent + &quot; must be multiple of &quot; +
            (base / 8));
      }

      // mantissa is guaranteed to be between 0-7
<span class="fc" id="L107">      final int mantissa = remainder / (base / 8);</span>
<span class="fc" id="L108">      final int encoded = ((exponent - MIN_WINDOW_LOG) &lt;&lt; 3) | mantissa;</span>

<span class="fc" id="L110">      UNSAFE.putByte(outputBase, output, (byte) encoded);</span>
<span class="fc" id="L111">      output++;</span>
    }

<span class="pc bpc" id="L114" title="1 of 4 branches missed.">    switch (contentSizeDescriptor) {</span>
      case 0:
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (singleSegment) {</span>
<span class="fc" id="L117">          UNSAFE.putByte(outputBase, output++, (byte) inputSize);</span>
        }
        break;
      case 1:
<span class="fc" id="L121">        UNSAFE.putShort(outputBase, output, (short) (inputSize - 256));</span>
<span class="fc" id="L122">        output += SIZE_OF_SHORT;</span>
<span class="fc" id="L123">        break;</span>
      case 2:
<span class="fc" id="L125">        UNSAFE.putInt(outputBase, output, inputSize);</span>
<span class="fc" id="L126">        output += SIZE_OF_INT;</span>
<span class="fc" id="L127">        break;</span>
      default:
<span class="nc" id="L129">        throw new AssertionError();</span>
    }

<span class="fc" id="L132">    return (int) (output - outputAddress);</span>
  }

  // visible for testing
  static int writeChecksum(final Object outputBase, final long outputAddress,
                           final long outputLimit, final Object inputBase,
                           final long inputAddress, final long inputLimit) {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    checkArgument(outputLimit - outputAddress &gt;= SIZE_OF_INT,</span>
                  OUTPUT_BUFFER_TOO_SMALL);

<span class="fc" id="L142">    final int inputSize = (int) (inputLimit - inputAddress);</span>

<span class="fc" id="L144">    final long hash = XxHash64.hash(0, inputBase, inputAddress, inputSize);</span>

<span class="fc" id="L146">    UNSAFE.putInt(outputBase, outputAddress, (int) hash);</span>

<span class="fc" id="L148">    return SIZE_OF_INT;</span>
  }

  public static int compress(final Object inputBase, final long inputAddress,
                             final long inputLimit, final Object outputBase,
                             final long outputAddress, final long outputLimit,
                             final int compressionLevel) {
<span class="fc" id="L155">    final int inputSize = (int) (inputLimit - inputAddress);</span>

<span class="fc" id="L157">    final CompressionParameters parameters =</span>
<span class="fc" id="L158">        CompressionParameters.compute(compressionLevel, inputSize);</span>

<span class="fc" id="L160">    long output = outputAddress;</span>

<span class="fc" id="L162">    output += writeMagic(outputBase, output, outputLimit);</span>
<span class="fc" id="L163">    output += writeFrameHeader(outputBase, output, outputLimit, inputSize,</span>
<span class="fc" id="L164">                               1 &lt;&lt; parameters.getWindowLog());</span>
<span class="fc" id="L165">    output +=</span>
<span class="fc" id="L166">        compressFrame(inputBase, inputAddress, inputLimit, outputBase, output,</span>
                      outputLimit, parameters);
<span class="fc" id="L168">    output +=</span>
<span class="fc" id="L169">        writeChecksum(outputBase, output, outputLimit, inputBase, inputAddress,</span>
                      inputLimit);

<span class="fc" id="L172">    return (int) (output - outputAddress);</span>
  }

  private static int compressFrame(final Object inputBase,
                                   final long inputAddress,
                                   final long inputLimit,
                                   final Object outputBase,
                                   final long outputAddress,
                                   final long outputLimit,
                                   final CompressionParameters parameters) {
<span class="fc" id="L182">    final int windowSize = 1 &lt;&lt;</span>
<span class="fc" id="L183">                           parameters.getWindowLog(); // TODO: store window size in parameters directly?</span>
<span class="fc" id="L184">    int blockSize = Math.min(MAX_BLOCK_SIZE, windowSize);</span>

<span class="fc" id="L186">    int outputSize = (int) (outputLimit - outputAddress);</span>
<span class="fc" id="L187">    int remaining = (int) (inputLimit - inputAddress);</span>

<span class="fc" id="L189">    long output = outputAddress;</span>
<span class="fc" id="L190">    long input = inputAddress;</span>

<span class="fc" id="L192">    final CompressionContext context =</span>
        new CompressionContext(parameters, inputAddress, remaining);

    do {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      checkArgument(outputSize &gt;= SIZE_OF_BLOCK_HEADER + MIN_BLOCK_SIZE,</span>
                    OUTPUT_BUFFER_TOO_SMALL);

<span class="fc bfc" id="L199" title="All 2 branches covered.">      final int lastBlockFlag = blockSize &gt;= remaining? 1 : 0;</span>
<span class="fc" id="L200">      blockSize = Math.min(blockSize, remaining);</span>

<span class="fc" id="L202">      int compressedSize = 0;</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">      if (remaining &gt; 0) {</span>
<span class="fc" id="L204">        compressedSize = compressBlock(inputBase, input, blockSize, outputBase,</span>
                                       output + SIZE_OF_BLOCK_HEADER,
                                       outputSize - SIZE_OF_BLOCK_HEADER,
                                       context, parameters);
      }

<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (compressedSize == 0) { // block is not compressible</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">        checkArgument(blockSize + SIZE_OF_BLOCK_HEADER &lt;= outputSize,</span>
                      &quot;Output size too small&quot;);

<span class="fc" id="L214">        final int blockHeader =</span>
            lastBlockFlag | (RAW_BLOCK &lt;&lt; 1) | (blockSize &lt;&lt; 3);
<span class="fc" id="L216">        put24BitLittleEndian(outputBase, output, blockHeader);</span>
<span class="fc" id="L217">        UNSAFE.copyMemory(inputBase, input, outputBase,</span>
                          output + SIZE_OF_BLOCK_HEADER, blockSize);
<span class="fc" id="L219">        compressedSize = SIZE_OF_BLOCK_HEADER + blockSize;</span>
<span class="fc" id="L220">      } else {</span>
<span class="fc" id="L221">        final int blockHeader =</span>
            lastBlockFlag | (COMPRESSED_BLOCK &lt;&lt; 1) | (compressedSize &lt;&lt; 3);
<span class="fc" id="L223">        put24BitLittleEndian(outputBase, output, blockHeader);</span>
<span class="fc" id="L224">        compressedSize += SIZE_OF_BLOCK_HEADER;</span>
      }

<span class="fc" id="L227">      input += blockSize;</span>
<span class="fc" id="L228">      remaining -= blockSize;</span>
<span class="fc" id="L229">      output += compressedSize;</span>
<span class="fc" id="L230">      outputSize -= compressedSize;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    } while (remaining &gt; 0);</span>

<span class="fc" id="L233">    return (int) (output - outputAddress);</span>
  }

  private static int compressBlock(final Object inputBase,
                                   final long inputAddress, final int inputSize,
                                   final Object outputBase,
                                   final long outputAddress,
                                   final int outputSize,
                                   final CompressionContext context,
                                   final CompressionParameters parameters) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (inputSize &lt; MIN_BLOCK_SIZE + SIZE_OF_BLOCK_HEADER + 1) {</span>
      //  don't even attempt compression below a certain input size
<span class="fc" id="L245">      return 0;</span>
    }

<span class="fc" id="L248">    context.blockCompressionState.enforceMaxDistance(inputAddress + inputSize,</span>
                                                     1 &lt;&lt;
<span class="fc" id="L250">                                                     parameters.getWindowLog());</span>
<span class="fc" id="L251">    context.sequenceStore.reset();</span>

<span class="fc" id="L253">    final int lastLiteralsSize = parameters.getStrategy().getCompressor()</span>
<span class="fc" id="L254">                                           .compressBlock(inputBase,</span>
                                                          inputAddress,
                                                          inputSize,
                                                          context.sequenceStore,
                                                          context.blockCompressionState,
                                                          context.offsets,
                                                          parameters);

<span class="fc" id="L262">    final long lastLiteralsAddress =</span>
        inputAddress + inputSize - lastLiteralsSize;

    // append [lastLiteralsAddress .. lastLiteralsSize] to sequenceStore literals buffer
<span class="fc" id="L266">    context.sequenceStore.appendLiterals(inputBase, lastLiteralsAddress,</span>
                                         lastLiteralsSize);

    // convert length/offsets into codes
<span class="fc" id="L270">    context.sequenceStore.generateCodes();</span>

<span class="fc" id="L272">    final long outputLimit = outputAddress + outputSize;</span>
<span class="fc" id="L273">    long output = outputAddress;</span>

<span class="fc" id="L275">    final int compressedLiteralsSize =</span>
<span class="fc" id="L276">        encodeLiterals(context.huffmanContext, parameters, outputBase, output,</span>
                       (int) (outputLimit - output),
                       context.sequenceStore.literalsBuffer,
                       context.sequenceStore.literalsLength);
<span class="fc" id="L280">    output += compressedLiteralsSize;</span>

<span class="fc" id="L282">    final int compressedSequencesSize =</span>
<span class="fc" id="L283">        SequenceEncoder.compressSequences(outputBase, output,</span>
                                          (int) (outputLimit - output),
                                          context.sequenceStore,
<span class="fc" id="L286">                                          parameters.getStrategy(),</span>
                                          context.sequenceEncodingContext);

<span class="fc" id="L289">    final int compressedSize = compressedLiteralsSize + compressedSequencesSize;</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    if (compressedSize == 0) {</span>
      // not compressible
<span class="nc" id="L292">      return compressedSize;</span>
    }

    // Check compressibility
<span class="fc" id="L296">    final int maxCompressedSize =</span>
<span class="fc" id="L297">        inputSize - calculateMinimumGain(inputSize, parameters.getStrategy());</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">    if (compressedSize &gt; maxCompressedSize) {</span>
<span class="fc" id="L299">      return 0; // not compressed</span>
    }

    // confirm repeated offsets and entropy tables
<span class="fc" id="L303">    context.commit();</span>

<span class="fc" id="L305">    return compressedSize;</span>
  }

  private static int encodeLiterals(final HuffmanCompressionContext context,
                                    final CompressionParameters parameters,
                                    final Object outputBase,
                                    final long outputAddress,
                                    final int outputSize, final byte[] literals,
                                    final int literalsSize) {
    // TODO: move this to Strategy
<span class="fc" id="L315">    final boolean bypassCompression =</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        (parameters.getStrategy() == CompressionParameters.Strategy.FAST) &amp;&amp;</span>
<span class="pc bnc" id="L317" title="All 2 branches missed.">        (parameters.getTargetLength() &gt; 0);</span>
<span class="pc bpc" id="L318" title="1 of 4 branches missed.">    if (bypassCompression || literalsSize &lt;= MINIMUM_LITERALS_SIZE) {</span>
<span class="fc" id="L319">      return rawLiterals(outputBase, outputAddress, outputSize, literals,</span>
                         literalsSize);
    }

<span class="fc bfc" id="L323" title="All 4 branches covered.">    final int headerSize =</span>
        3 + (literalsSize &gt;= 1024? 1 : 0) + (literalsSize &gt;= 16384? 1 : 0);

<span class="pc bpc" id="L326" title="1 of 2 branches missed.">    checkArgument(headerSize + 1 &lt;= outputSize, OUTPUT_BUFFER_TOO_SMALL);</span>

<span class="fc" id="L328">    final int[] counts = new int[MAX_SYMBOL_COUNT]; // TODO: preallocate</span>
<span class="fc" id="L329">    Histogram.count(literals, literalsSize, counts);</span>
<span class="fc" id="L330">    final int maxSymbol = Histogram.findMaxSymbol(counts, MAX_SYMBOL);</span>
<span class="fc" id="L331">    final int largestCount = Histogram.findLargestCount(counts, maxSymbol);</span>

<span class="fc" id="L333">    final long literalsAddress = ARRAY_BYTE_BASE_OFFSET;</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    if (largestCount == literalsSize) {</span>
      // all bytes in input are equal
<span class="nc" id="L336">      return rleLiterals(outputBase, outputAddress, literals, literalsSize);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">    } else if (largestCount &lt;= (literalsSize &gt;&gt;&gt; 7) + 4) {</span>
      // heuristic: probably not compressible enough
<span class="fc" id="L339">      return rawLiterals(outputBase, outputAddress, outputSize, literals,</span>
                         literalsSize);
    }

<span class="fc" id="L343">    final HuffmanCompressionTable previousTable = context.getPreviousTable();</span>
    final HuffmanCompressionTable table;
    int serializedTableSize;
    final boolean reuseTable;

<span class="fc" id="L348">    final boolean canReuse = previousTable.isValid(counts, maxSymbol);</span>

    // heuristic: use existing table for small inputs if valid
    // TODO: move to Strategy
<span class="fc" id="L352">    final boolean preferReuse = parameters.getStrategy().ordinal() &lt;</span>
<span class="pc bpc" id="L353" title="1 of 4 branches missed.">                                CompressionParameters.Strategy.LAZY.ordinal() &amp;&amp;</span>
                                literalsSize &lt;= 1024;
<span class="fc bfc" id="L355" title="All 4 branches covered.">    if (preferReuse &amp;&amp; canReuse) {</span>
<span class="fc" id="L356">      table = previousTable;</span>
<span class="fc" id="L357">      reuseTable = true;</span>
<span class="fc" id="L358">      serializedTableSize = 0;</span>
    } else {
<span class="fc" id="L360">      final HuffmanCompressionTable newTable = context.borrowTemporaryTable();</span>

<span class="fc" id="L362">      newTable.initialize(counts, maxSymbol,</span>
<span class="fc" id="L363">                          HuffmanCompressionTable.optimalNumberOfBits(</span>
                              MAX_HUFFMAN_TABLE_LOG, literalsSize, maxSymbol),
<span class="fc" id="L365">                          context.getCompressionTableWorkspace());</span>

<span class="fc" id="L367">      serializedTableSize =</span>
<span class="fc" id="L368">          newTable.write(outputBase, outputAddress + headerSize,</span>
                         outputSize - headerSize,
<span class="fc" id="L370">                         context.getTableWriterWorkspace());</span>

      // Check if using previous huffman table is beneficial
<span class="fc bfc" id="L373" title="All 2 branches covered.">      if (canReuse &amp;&amp; previousTable.estimateCompressedSize(counts, maxSymbol) &lt;=</span>
                      serializedTableSize +
<span class="fc bfc" id="L375" title="All 2 branches covered.">                      newTable.estimateCompressedSize(counts, maxSymbol)) {</span>
<span class="fc" id="L376">        table = previousTable;</span>
<span class="fc" id="L377">        reuseTable = true;</span>
<span class="fc" id="L378">        serializedTableSize = 0;</span>
<span class="fc" id="L379">        context.discardTemporaryTable();</span>
      } else {
<span class="fc" id="L381">        table = newTable;</span>
<span class="fc" id="L382">        reuseTable = false;</span>
      }
    }

    final int compressedSize;
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">    final boolean singleStream = literalsSize &lt; 256;</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">    if (singleStream) {</span>
<span class="nc" id="L389">      compressedSize = HuffmanCompressor.compressSingleStream(outputBase,</span>
                                                              outputAddress +
                                                              headerSize +
                                                              serializedTableSize,
                                                              outputSize -
                                                              headerSize -
                                                              serializedTableSize,
                                                              literals,
                                                              literalsAddress,
                                                              literalsSize,
                                                              table);
    } else {
<span class="fc" id="L401">      compressedSize = HuffmanCompressor.compress4streams(outputBase,</span>
                                                          outputAddress +
                                                          headerSize +
                                                          serializedTableSize,
                                                          outputSize -
                                                          headerSize -
                                                          serializedTableSize,
                                                          literals,
                                                          literalsAddress,
                                                          literalsSize, table);
    }

<span class="fc" id="L413">    final int totalSize = serializedTableSize + compressedSize;</span>
<span class="fc" id="L414">    final int minimumGain =</span>
<span class="fc" id="L415">        calculateMinimumGain(literalsSize, parameters.getStrategy());</span>

<span class="pc bpc" id="L417" title="1 of 4 branches missed.">    if (compressedSize == 0 || totalSize &gt;= literalsSize - minimumGain) {</span>
      // incompressible or no savings

      // discard any temporary table we might have borrowed above
<span class="fc" id="L421">      context.discardTemporaryTable();</span>

<span class="fc" id="L423">      return rawLiterals(outputBase, outputAddress, outputSize, literals,</span>
                         literalsSize);
    }

<span class="fc bfc" id="L427" title="All 2 branches covered.">    final int encodingType =</span>
        reuseTable? TREELESS_LITERALS_BLOCK : COMPRESSED_LITERALS_BLOCK;

    // Build header
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">    switch (headerSize) {</span>
      case 3: { // 2 - 2 - 10 - 10
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        final int header =</span>
            encodingType | ((singleStream? 0 : 1) &lt;&lt; 2) | (literalsSize &lt;&lt; 4) |
            (totalSize &lt;&lt; 14);
<span class="fc" id="L436">        put24BitLittleEndian(outputBase, outputAddress, header);</span>
<span class="fc" id="L437">        break;</span>
      }
      case 4: { // 2 - 2 - 14 - 14
<span class="fc" id="L440">        final int header =</span>
            encodingType | (2 &lt;&lt; 2) | (literalsSize &lt;&lt; 4) | (totalSize &lt;&lt; 18);
<span class="fc" id="L442">        UNSAFE.putInt(outputBase, outputAddress, header);</span>
<span class="fc" id="L443">        break;</span>
      }
      case 5: { // 2 - 2 - 18 - 18
<span class="fc" id="L446">        final int header =</span>
            encodingType | (3 &lt;&lt; 2) | (literalsSize &lt;&lt; 4) | (totalSize &lt;&lt; 22);
<span class="fc" id="L448">        UNSAFE.putInt(outputBase, outputAddress, header);</span>
<span class="fc" id="L449">        UNSAFE.putByte(outputBase, outputAddress + SIZE_OF_INT,</span>
                       (byte) (totalSize &gt;&gt;&gt; 10));
<span class="fc" id="L451">        break;</span>
      }
      default:  // not possible : headerSize is {3,4,5}
<span class="nc" id="L454">        throw new IllegalStateException();</span>
    }

<span class="fc" id="L457">    return headerSize + totalSize;</span>
  }

  private static int rleLiterals(final Object outputBase,
                                 final long outputAddress,
                                 final Object inputBase, final int inputSize) {
<span class="nc bnc" id="L463" title="All 4 branches missed.">    final int headerSize =</span>
        1 + (inputSize &gt; 31? 1 : 0) + (inputSize &gt; 4095? 1 : 0);

<span class="nc bnc" id="L466" title="All 4 branches missed.">    switch (headerSize) {</span>
      case 1: // 2 - 1 - 5
<span class="nc" id="L468">        UNSAFE.putByte(outputBase, outputAddress,</span>
                       (byte) (RLE_LITERALS_BLOCK | (inputSize &lt;&lt; 3)));
<span class="nc" id="L470">        break;</span>
      case 2: // 2 - 2 - 12
<span class="nc" id="L472">        UNSAFE.putShort(outputBase, outputAddress,</span>
                        (short) (RLE_LITERALS_BLOCK | (1 &lt;&lt; 2) |
                                 (inputSize &lt;&lt; 4)));
<span class="nc" id="L475">        break;</span>
      case 3: // 2 - 2 - 20
<span class="nc" id="L477">        UNSAFE.putInt(outputBase, outputAddress,</span>
                      RLE_LITERALS_BLOCK | 3 &lt;&lt; 2 | inputSize &lt;&lt; 4);
<span class="nc" id="L479">        break;</span>
      default:   // impossible. headerSize is {1,2,3}
<span class="nc" id="L481">        throw new IllegalStateException();</span>
    }

<span class="nc" id="L484">    UNSAFE.putByte(outputBase, outputAddress + headerSize,</span>
<span class="nc" id="L485">                   UNSAFE.getByte(inputBase,</span>
                                  sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET));

<span class="nc" id="L488">    return headerSize + 1;</span>
  }

  private static int calculateMinimumGain(final int inputSize,
                                          final CompressionParameters.Strategy strategy) {
    // TODO: move this to Strategy to avoid hardcoding a specific strategy here
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">    final int minLog =</span>
        strategy == CompressionParameters.Strategy.BTULTRA? 7 : 6;
<span class="fc" id="L496">    return (inputSize &gt;&gt;&gt; minLog) + 2;</span>
  }

  private static int rawLiterals(final Object outputBase,
                                 final long outputAddress, final int outputSize,
                                 final Object inputBase, final int inputSize) {
<span class="fc" id="L502">    int headerSize = 1;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">    if (inputSize &gt;= 32) {</span>
<span class="fc" id="L504">      headerSize++;</span>
    }
<span class="fc bfc" id="L506" title="All 2 branches covered.">    if (inputSize &gt;= 4096) {</span>
<span class="fc" id="L507">      headerSize++;</span>
    }

<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    checkArgument(inputSize + headerSize &lt;= outputSize,</span>
                  OUTPUT_BUFFER_TOO_SMALL);

<span class="pc bpc" id="L513" title="2 of 4 branches missed.">    switch (headerSize) {</span>
      case 1:
<span class="fc" id="L515">        UNSAFE.putByte(outputBase, outputAddress,</span>
                       (byte) (RAW_LITERALS_BLOCK | (inputSize &lt;&lt; 3)));
<span class="fc" id="L517">        break;</span>
      case 2:
<span class="nc" id="L519">        UNSAFE.putShort(outputBase, outputAddress,</span>
                        (short) (RAW_LITERALS_BLOCK | (1 &lt;&lt; 2) |
                                 (inputSize &lt;&lt; 4)));
<span class="nc" id="L522">        break;</span>
      case 3:
<span class="fc" id="L524">        put24BitLittleEndian(outputBase, outputAddress,</span>
                             RAW_LITERALS_BLOCK | (3 &lt;&lt; 2) | (inputSize &lt;&lt; 4));
<span class="fc" id="L526">        break;</span>
      default:
<span class="nc" id="L528">        throw new AssertionError();</span>
    }

    // TODO: ensure this test is correct
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">    checkArgument(inputSize + 1 &lt;= outputSize, OUTPUT_BUFFER_TOO_SMALL);</span>

<span class="fc" id="L534">    UNSAFE.copyMemory(inputBase, sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET,</span>
                      outputBase, outputAddress + headerSize, inputSize);

<span class="fc" id="L537">    return headerSize + inputSize;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>