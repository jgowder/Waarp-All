<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FiniteStateEntropy.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Http</a> &gt; <a href="../index.html" class="el_bundle">WaarpCompression</a> &gt; <a href="index.source.html" class="el_package">org.waarp.compress.zstdunsafe</a> &gt; <span class="el_source">FiniteStateEntropy.java</span></div><h1>FiniteStateEntropy.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.waarp.compress.zstdunsafe;

import static org.waarp.compress.zstdunsafe.BitInputStream.*;
import static sun.misc.Unsafe.*;

class FiniteStateEntropy {
  public static final int MAX_SYMBOL = 255;
  public static final int MAX_TABLE_LOG = 12;
  public static final int MIN_TABLE_LOG = 5;

<span class="nc" id="L44">  private static final int[] REST_TO_BEAT =</span>
      new int[] { 0, 473195, 504333, 520860, 550000, 700000, 750000, 830000 };
  private static final short UNASSIGNED = -2;
  public static final String OUTPUT_BUFFER_TOO_SMALL =
      &quot;Output buffer too small&quot;;

  private FiniteStateEntropy() {
  }

  public static int decompress(final FiniteStateEntropy.Table table,
                               final Object inputBase, final long inputAddress,
                               final long inputLimit,
                               final byte[] outputBuffer) {
<span class="nc" id="L57">    final long outputAddress = ARRAY_BYTE_BASE_OFFSET;</span>
<span class="nc" id="L58">    final long outputLimit = outputAddress + outputBuffer.length;</span>

<span class="nc" id="L60">    long output = outputAddress;</span>

    // initialize bit stream
<span class="nc" id="L63">    final BitInputStream.Initializer initializer =</span>
        new BitInputStream.Initializer(inputBase, inputAddress, inputLimit);
<span class="nc" id="L65">    initializer.initialize();</span>
<span class="nc" id="L66">    int bitsConsumed = initializer.getBitsConsumed();</span>
<span class="nc" id="L67">    long currentAddress = initializer.getCurrentAddress();</span>
<span class="nc" id="L68">    long bits = initializer.getBits();</span>

    // initialize first FSE stream
<span class="nc" id="L71">    int state1 = (int) peekBits(bitsConsumed, bits, table.log2Size);</span>
<span class="nc" id="L72">    bitsConsumed += table.log2Size;</span>

<span class="nc" id="L74">    BitInputStream.Loader loader =</span>
        new BitInputStream.Loader(inputBase, inputAddress, currentAddress, bits,
                                  bitsConsumed);
<span class="nc" id="L77">    loader.load();</span>
<span class="nc" id="L78">    bits = loader.getBits();</span>
<span class="nc" id="L79">    bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L80">    currentAddress = loader.getCurrentAddress();</span>

    // initialize second FSE stream
<span class="nc" id="L83">    int state2 = (int) peekBits(bitsConsumed, bits, table.log2Size);</span>
<span class="nc" id="L84">    bitsConsumed += table.log2Size;</span>

<span class="nc" id="L86">    loader =</span>
        new BitInputStream.Loader(inputBase, inputAddress, currentAddress, bits,
                                  bitsConsumed);
<span class="nc" id="L89">    loader.load();</span>
<span class="nc" id="L90">    bits = loader.getBits();</span>
<span class="nc" id="L91">    bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L92">    currentAddress = loader.getCurrentAddress();</span>

<span class="nc" id="L94">    final byte[] symbols = table.symbol;</span>
<span class="nc" id="L95">    final byte[] numbersOfBits = table.numberOfBits;</span>
<span class="nc" id="L96">    final int[] newStates = table.newState;</span>

    // decode 4 symbols per loop
<span class="nc bnc" id="L99" title="All 2 branches missed.">    while (output &lt;= outputLimit - 4) {</span>
      int numberOfBits;

<span class="nc" id="L102">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output, symbols[state1]);</span>
<span class="nc" id="L103">      numberOfBits = numbersOfBits[state1];</span>
<span class="nc" id="L104">      state1 = (int) (newStates[state1] +</span>
<span class="nc" id="L105">                      peekBits(bitsConsumed, bits, numberOfBits));</span>
<span class="nc" id="L106">      bitsConsumed += numberOfBits;</span>

<span class="nc" id="L108">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output + 1, symbols[state2]);</span>
<span class="nc" id="L109">      numberOfBits = numbersOfBits[state2];</span>
<span class="nc" id="L110">      state2 = (int) (newStates[state2] +</span>
<span class="nc" id="L111">                      peekBits(bitsConsumed, bits, numberOfBits));</span>
<span class="nc" id="L112">      bitsConsumed += numberOfBits;</span>

<span class="nc" id="L114">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output + 2, symbols[state1]);</span>
<span class="nc" id="L115">      numberOfBits = numbersOfBits[state1];</span>
<span class="nc" id="L116">      state1 = (int) (newStates[state1] +</span>
<span class="nc" id="L117">                      peekBits(bitsConsumed, bits, numberOfBits));</span>
<span class="nc" id="L118">      bitsConsumed += numberOfBits;</span>

<span class="nc" id="L120">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output + 3, symbols[state2]);</span>
<span class="nc" id="L121">      numberOfBits = numbersOfBits[state2];</span>
<span class="nc" id="L122">      state2 = (int) (newStates[state2] +</span>
<span class="nc" id="L123">                      peekBits(bitsConsumed, bits, numberOfBits));</span>
<span class="nc" id="L124">      bitsConsumed += numberOfBits;</span>

<span class="nc" id="L126">      output += Constants.SIZE_OF_INT;</span>

<span class="nc" id="L128">      loader =</span>
          new BitInputStream.Loader(inputBase, inputAddress, currentAddress,
                                    bits, bitsConsumed);
<span class="nc" id="L131">      final boolean done = loader.load();</span>
<span class="nc" id="L132">      bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L133">      bits = loader.getBits();</span>
<span class="nc" id="L134">      currentAddress = loader.getCurrentAddress();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L136">        break;</span>
      }
<span class="nc" id="L138">    }</span>

    while (true) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">      Util.verify(output &lt;= outputLimit - 2, inputAddress,</span>
                  &quot;Output buffer is too small&quot;);
<span class="nc" id="L143">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output++, symbols[state1]);</span>
<span class="nc" id="L144">      final int numberOfBits = numbersOfBits[state1];</span>
<span class="nc" id="L145">      state1 = (int) (newStates[state1] +</span>
<span class="nc" id="L146">                      peekBits(bitsConsumed, bits, numberOfBits));</span>
<span class="nc" id="L147">      bitsConsumed += numberOfBits;</span>

<span class="nc" id="L149">      loader =</span>
          new BitInputStream.Loader(inputBase, inputAddress, currentAddress,
                                    bits, bitsConsumed);
<span class="nc" id="L152">      loader.load();</span>
<span class="nc" id="L153">      bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L154">      bits = loader.getBits();</span>
<span class="nc" id="L155">      currentAddress = loader.getCurrentAddress();</span>

<span class="nc bnc" id="L157" title="All 2 branches missed.">      if (loader.isOverflow()) {</span>
<span class="nc" id="L158">        UnsafeUtil.UNSAFE.putByte(outputBuffer, output++, symbols[state2]);</span>
<span class="nc" id="L159">        break;</span>
      }

<span class="nc bnc" id="L162" title="All 2 branches missed.">      Util.verify(output &lt;= outputLimit - 2, inputAddress,</span>
                  &quot;Output buffer is too small&quot;);
<span class="nc" id="L164">      UnsafeUtil.UNSAFE.putByte(outputBuffer, output++, symbols[state2]);</span>
<span class="nc" id="L165">      final int numberOfBits1 = numbersOfBits[state2];</span>
<span class="nc" id="L166">      state2 = (int) (newStates[state2] +</span>
<span class="nc" id="L167">                      peekBits(bitsConsumed, bits, numberOfBits1));</span>
<span class="nc" id="L168">      bitsConsumed += numberOfBits1;</span>

<span class="nc" id="L170">      loader =</span>
          new BitInputStream.Loader(inputBase, inputAddress, currentAddress,
                                    bits, bitsConsumed);
<span class="nc" id="L173">      loader.load();</span>
<span class="nc" id="L174">      bitsConsumed = loader.getBitsConsumed();</span>
<span class="nc" id="L175">      bits = loader.getBits();</span>
<span class="nc" id="L176">      currentAddress = loader.getCurrentAddress();</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">      if (loader.isOverflow()) {</span>
<span class="nc" id="L179">        UnsafeUtil.UNSAFE.putByte(outputBuffer, output++, symbols[state1]);</span>
<span class="nc" id="L180">        break;</span>
      }
<span class="nc" id="L182">    }</span>

<span class="nc" id="L184">    return (int) (output - outputAddress);</span>
  }

  public static int compress(final Object outputBase, final long outputAddress,
                             final int outputSize, final byte[] input,
                             final int inputSize,
                             final FseCompressionTable table) {
<span class="nc" id="L191">    return compress(outputBase, outputAddress, outputSize, input,</span>
                    ARRAY_BYTE_BASE_OFFSET, inputSize, table);
  }

  public static int compress(final Object outputBase, final long outputAddress,
                             final int outputSize, final Object inputBase,
                             final long inputAddress, int inputSize,
                             final FseCompressionTable table) {
<span class="nc bnc" id="L199" title="All 2 branches missed.">    Util.checkArgument(outputSize &gt;= Constants.SIZE_OF_LONG,</span>
                       OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L202">    long input = inputAddress + inputSize;</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (inputSize &lt;= 2) {</span>
<span class="nc" id="L205">      return 0;</span>
    }

<span class="nc" id="L208">    final BitOutputStream stream =</span>
        new BitOutputStream(outputBase, outputAddress, outputSize);

    int state1;
    int state2;

<span class="nc bnc" id="L214" title="All 2 branches missed.">    if ((inputSize &amp; 1) != 0) {</span>
<span class="nc" id="L215">      input--;</span>
<span class="nc" id="L216">      state1 = table.begin(UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L218">      input--;</span>
<span class="nc" id="L219">      state2 = table.begin(UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L221">      input--;</span>
<span class="nc" id="L222">      state1 = table.encode(stream, state1,</span>
<span class="nc" id="L223">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L225">      stream.flush();</span>
    } else {
<span class="nc" id="L227">      input--;</span>
<span class="nc" id="L228">      state2 = table.begin(UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L230">      input--;</span>
<span class="nc" id="L231">      state1 = table.begin(UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>
    }

    // join to mod 4
<span class="nc" id="L235">    inputSize -= 2;</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">    if ((inputSize &amp; 2) != 0) {  /* test bit 2 */</span>
<span class="nc" id="L238">      input--;</span>
<span class="nc" id="L239">      state2 = table.encode(stream, state2,</span>
<span class="nc" id="L240">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L242">      input--;</span>
<span class="nc" id="L243">      state1 = table.encode(stream, state1,</span>
<span class="nc" id="L244">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L246">      stream.flush();</span>
    }

    // 2 or 4 encoding per loop
<span class="nc bnc" id="L250" title="All 2 branches missed.">    while (input &gt; inputAddress) {</span>
<span class="nc" id="L251">      input--;</span>
<span class="nc" id="L252">      state2 = table.encode(stream, state2,</span>
<span class="nc" id="L253">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L255">      input--;</span>
<span class="nc" id="L256">      state1 = table.encode(stream, state1,</span>
<span class="nc" id="L257">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L259">      input--;</span>
<span class="nc" id="L260">      state2 = table.encode(stream, state2,</span>
<span class="nc" id="L261">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L263">      input--;</span>
<span class="nc" id="L264">      state1 = table.encode(stream, state1,</span>
<span class="nc" id="L265">                            UnsafeUtil.UNSAFE.getByte(inputBase, input));</span>

<span class="nc" id="L267">      stream.flush();</span>
    }

<span class="nc" id="L270">    table.finish(stream, state2);</span>
<span class="nc" id="L271">    table.finish(stream, state1);</span>

<span class="nc" id="L273">    return stream.close();</span>
  }

  public static int optimalTableLog(final int maxTableLog, final int inputSize,
                                    final int maxSymbol) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">    if (inputSize &lt;= 1) {</span>
<span class="nc" id="L279">      throw new IllegalArgumentException(); // not supported. Use RLE instead</span>
    }

<span class="nc" id="L282">    int result = maxTableLog;</span>

<span class="nc" id="L284">    result = Math.min(result, Util.highestBit((inputSize - 1)) -</span>
                              2); // we may be able to reduce accuracy if input is small

    // Need a minimum to safely represent all symbol values
<span class="nc" id="L288">    result = Math.max(result, Util.minTableLog(inputSize, maxSymbol));</span>

<span class="nc" id="L290">    result = Math.max(result, MIN_TABLE_LOG);</span>
<span class="nc" id="L291">    result = Math.min(result, MAX_TABLE_LOG);</span>

<span class="nc" id="L293">    return result;</span>
  }

  public static void normalizeCounts(final short[] normalizedCounts,
                                     final int tableLog, final int[] counts,
                                     final int total, final int maxSymbol) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">    Util.checkArgument(tableLog &gt;= MIN_TABLE_LOG, &quot;Unsupported FSE table size&quot;);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">    Util.checkArgument(tableLog &lt;= MAX_TABLE_LOG, &quot;FSE table size too large&quot;);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    Util.checkArgument(tableLog &gt;= Util.minTableLog(total, maxSymbol),</span>
                       &quot;FSE table size too small&quot;);

<span class="nc" id="L304">    final long scale = 62L - tableLog;</span>
<span class="nc" id="L305">    final long step = (1L &lt;&lt; 62) / total;</span>
<span class="nc" id="L306">    final long vstep = 1L &lt;&lt; (scale - 20);</span>

<span class="nc" id="L308">    int stillToDistribute = 1 &lt;&lt; tableLog;</span>

<span class="nc" id="L310">    int largest = 0;</span>
<span class="nc" id="L311">    short largestProbability = 0;</span>
<span class="nc" id="L312">    final int lowThreshold = total &gt;&gt;&gt; tableLog;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">    for (int symbol = 0; symbol &lt;= maxSymbol; symbol++) {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      if (counts[symbol] == total) {</span>
<span class="nc" id="L316">        throw new IllegalArgumentException(); // TODO: should have been RLE-compressed by upper layers</span>
      }
<span class="nc bnc" id="L318" title="All 2 branches missed.">      if (counts[symbol] == 0) {</span>
<span class="nc" id="L319">        normalizedCounts[symbol] = 0;</span>
<span class="nc" id="L320">        continue;</span>
      }
<span class="nc bnc" id="L322" title="All 2 branches missed.">      if (counts[symbol] &lt;= lowThreshold) {</span>
<span class="nc" id="L323">        normalizedCounts[symbol] = -1;</span>
<span class="nc" id="L324">        stillToDistribute--;</span>
      } else {
<span class="nc" id="L326">        short probability = (short) ((counts[symbol] * step) &gt;&gt;&gt; scale);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (probability &lt; 8) {</span>
<span class="nc" id="L328">          final long restToBeat = vstep * REST_TO_BEAT[probability];</span>
<span class="nc" id="L329">          final long delta =</span>
              counts[symbol] * step - (((long) probability) &lt;&lt; scale);
<span class="nc bnc" id="L331" title="All 2 branches missed.">          if (delta &gt; restToBeat) {</span>
<span class="nc" id="L332">            probability++;</span>
          }
        }
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (probability &gt; largestProbability) {</span>
<span class="nc" id="L336">          largestProbability = probability;</span>
<span class="nc" id="L337">          largest = symbol;</span>
        }
<span class="nc" id="L339">        normalizedCounts[symbol] = probability;</span>
<span class="nc" id="L340">        stillToDistribute -= probability;</span>
      }
    }

<span class="nc bnc" id="L344" title="All 2 branches missed.">    if (-stillToDistribute &gt;= (normalizedCounts[largest] &gt;&gt;&gt; 1)) {</span>
      // corner case. Need another normalization method
      // TODO size_t const errorCode = FSE_normalizeM2(normalizedCounter, tableLog, count, total, maxSymbolValue);
<span class="nc" id="L347">      normalizeCounts2(normalizedCounts, tableLog, counts, total, maxSymbol);</span>
    } else {
<span class="nc" id="L349">      normalizedCounts[largest] += (short) stillToDistribute;</span>
    }

<span class="nc" id="L352">  }</span>

  private static void normalizeCounts2(final short[] normalizedCounts,
                                       final int tableLog, final int[] counts,
                                       int total, final int maxSymbol) {
<span class="nc" id="L357">    int distributed = 0;</span>

<span class="nc" id="L359">    final int lowThreshold = total &gt;&gt;&gt;</span>
                             tableLog; // minimum count below which frequency in the normalized table is &quot;too small&quot; (~ &lt; 1)
<span class="nc" id="L361">    int lowOne = (total * 3) &gt;&gt;&gt; (tableLog +</span>
                                  1); // 1.5 * lowThreshold. If count in (lowThreshold, lowOne] =&gt; assign frequency 1

<span class="nc bnc" id="L364" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxSymbol; i++) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">      if (counts[i] == 0) {</span>
<span class="nc" id="L366">        normalizedCounts[i] = 0;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">      } else if (counts[i] &lt;= lowThreshold) {</span>
<span class="nc" id="L368">        normalizedCounts[i] = -1;</span>
<span class="nc" id="L369">        distributed++;</span>
<span class="nc" id="L370">        total -= counts[i];</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">      } else if (counts[i] &lt;= lowOne) {</span>
<span class="nc" id="L372">        normalizedCounts[i] = 1;</span>
<span class="nc" id="L373">        distributed++;</span>
<span class="nc" id="L374">        total -= counts[i];</span>
      } else {
<span class="nc" id="L376">        normalizedCounts[i] = UNASSIGNED;</span>
      }
    }

<span class="nc" id="L380">    final int normalizationFactor = 1 &lt;&lt; tableLog;</span>
<span class="nc" id="L381">    int toDistribute = normalizationFactor - distributed;</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">    if ((total / toDistribute) &gt; lowOne) {</span>
      /* risk of rounding to zero */
<span class="nc" id="L385">      lowOne = ((total * 3) / (toDistribute * 2));</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">      for (int i = 0; i &lt;= maxSymbol; i++) {</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">        if ((normalizedCounts[i] == UNASSIGNED) &amp;&amp; (counts[i] &lt;= lowOne)) {</span>
<span class="nc" id="L388">          normalizedCounts[i] = 1;</span>
<span class="nc" id="L389">          distributed++;</span>
<span class="nc" id="L390">          total -= counts[i];</span>
        }
      }
<span class="nc" id="L393">      toDistribute = normalizationFactor - distributed;</span>
    }

<span class="nc bnc" id="L396" title="All 2 branches missed.">    if (distributed == maxSymbol + 1) {</span>
      // all values are pretty poor
      // probably incompressible data (should have already been detected);
      // find max, then give all remaining points to max
<span class="nc" id="L400">      int maxValue = 0;</span>
<span class="nc" id="L401">      int maxCount = 0;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">      for (int i = 0; i &lt;= maxSymbol; i++) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (counts[i] &gt; maxCount) {</span>
<span class="nc" id="L404">          maxValue = i;</span>
<span class="nc" id="L405">          maxCount = counts[i];</span>
        }
      }
<span class="nc" id="L408">      normalizedCounts[maxValue] += (short) toDistribute;</span>
<span class="nc" id="L409">      return;</span>
    }

<span class="nc bnc" id="L412" title="All 2 branches missed.">    if (total == 0) {</span>
      // all of the symbols were low enough for the lowOne or lowThreshold
<span class="nc bnc" id="L414" title="All 2 branches missed.">      for (int i = 0; toDistribute &gt; 0; i = (i + 1) % (maxSymbol + 1)) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (normalizedCounts[i] &gt; 0) {</span>
<span class="nc" id="L416">          toDistribute--;</span>
<span class="nc" id="L417">          normalizedCounts[i]++;</span>
        }
      }
<span class="nc" id="L420">      return;</span>
    }

    // TODO: simplify/document this code
<span class="nc" id="L424">    final long vStepLog = 62 - tableLog;</span>
<span class="nc" id="L425">    final long mid = (1L &lt;&lt; (vStepLog - 1)) - 1;</span>
<span class="nc" id="L426">    final long rStep = (((1L &lt;&lt; vStepLog) * toDistribute) + mid) /</span>
                       total;   /* scale on remaining */
<span class="nc" id="L428">    long tmpTotal = mid;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">    for (int i = 0; i &lt;= maxSymbol; i++) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">      if (normalizedCounts[i] == UNASSIGNED) {</span>
<span class="nc" id="L431">        final long end = tmpTotal + (counts[i] * rStep);</span>
<span class="nc" id="L432">        final int sStart = (int) (tmpTotal &gt;&gt;&gt; vStepLog);</span>
<span class="nc" id="L433">        final int sEnd = (int) (end &gt;&gt;&gt; vStepLog);</span>
<span class="nc" id="L434">        final int weight = sEnd - sStart;</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (weight &lt; 1) {</span>
<span class="nc" id="L437">          throw new AssertionError();</span>
        }
<span class="nc" id="L439">        normalizedCounts[i] = (short) weight;</span>
<span class="nc" id="L440">        tmpTotal = end;</span>
      }
    }

<span class="nc" id="L444">  }</span>

  public static int writeNormalizedCounts(final Object outputBase,
                                          final long outputAddress,
                                          final int outputSize,
                                          final short[] normalizedCounts,
                                          final int maxSymbol,
                                          final int tableLog) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">    Util.checkArgument(tableLog &lt;= MAX_TABLE_LOG, &quot;FSE table too large&quot;);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">    Util.checkArgument(tableLog &gt;= MIN_TABLE_LOG, &quot;FSE table too small&quot;);</span>

<span class="nc" id="L455">    long output = outputAddress;</span>
<span class="nc" id="L456">    final long outputLimit = outputAddress + outputSize;</span>

<span class="nc" id="L458">    final int tableSize = 1 &lt;&lt; tableLog;</span>

<span class="nc" id="L460">    int bitCount = 0;</span>

    // encode table size
<span class="nc" id="L463">    int bitStream = (tableLog - MIN_TABLE_LOG);</span>
<span class="nc" id="L464">    bitCount += 4;</span>

<span class="nc" id="L466">    int remaining = tableSize + 1; // +1 for extra accuracy</span>
<span class="nc" id="L467">    int threshold = tableSize;</span>
<span class="nc" id="L468">    int tableBitCount = tableLog + 1;</span>

<span class="nc" id="L470">    int symbol = 0;</span>

<span class="nc" id="L472">    boolean previousIs0 = false;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    while (remaining &gt; 1) {</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">      if (previousIs0) {</span>
        // From RFC 8478, section 4.1.1:
        //   When a symbol has a probability of zero, it is followed by a 2-bit
        //   repeat flag.  This repeat flag tells how many probabilities of zeroes
        //   follow the current one.  It provides a number ranging from 0 to 3.
        //   If it is a 3, another 2-bit repeat flag follows, and so on.
<span class="nc" id="L480">        int start = symbol;</span>

        // find run of symbols with count 0
<span class="nc bnc" id="L483" title="All 2 branches missed.">        while (normalizedCounts[symbol] == 0) {</span>
<span class="nc" id="L484">          symbol++;</span>
        }

        // encode in batches if 8 repeat sequences in one shot (representing 24 symbols total)
<span class="nc bnc" id="L488" title="All 2 branches missed.">        while (symbol &gt;= start + 24) {</span>
<span class="nc" id="L489">          start += 24;</span>
<span class="nc" id="L490">          bitStream |= (0xffff &lt;&lt; bitCount);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">          Util.checkArgument(output + Constants.SIZE_OF_SHORT &lt;= outputLimit,</span>
                             OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L494">          UnsafeUtil.UNSAFE.putShort(outputBase, output, (short) bitStream);</span>
<span class="nc" id="L495">          output += Constants.SIZE_OF_SHORT;</span>

          // flush now, so no need to increase bitCount by 16
<span class="nc" id="L498">          bitStream &gt;&gt;&gt;= Short.SIZE;</span>
        }

        // encode remaining in batches of 3 symbols
<span class="nc bnc" id="L502" title="All 2 branches missed.">        while (symbol &gt;= start + 3) {</span>
<span class="nc" id="L503">          start += 3;</span>
<span class="nc" id="L504">          bitStream |= 0x3 &lt;&lt; bitCount;</span>
<span class="nc" id="L505">          bitCount += 2;</span>
        }

        // encode tail
<span class="nc" id="L509">        bitStream |= (symbol - start) &lt;&lt; bitCount;</span>
<span class="nc" id="L510">        bitCount += 2;</span>

        // flush bitstream if necessary
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (bitCount &gt; 16) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">          Util.checkArgument(output + Constants.SIZE_OF_SHORT &lt;= outputLimit,</span>
                             OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L517">          UnsafeUtil.UNSAFE.putShort(outputBase, output, (short) bitStream);</span>
<span class="nc" id="L518">          output += Constants.SIZE_OF_SHORT;</span>

<span class="nc" id="L520">          bitStream &gt;&gt;&gt;= Short.SIZE;</span>
<span class="nc" id="L521">          bitCount -= Short.SIZE;</span>
        }
      }

<span class="nc" id="L525">      int count = normalizedCounts[symbol++];</span>
<span class="nc" id="L526">      final int max = (2 * threshold - 1) - remaining;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">      remaining -= count &lt; 0? -count : count;</span>
<span class="nc" id="L528">      count++;   /* +1 for extra accuracy */</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">      if (count &gt;= threshold) {</span>
<span class="nc" id="L530">        count += max;</span>
      }
<span class="nc" id="L532">      bitStream |= count &lt;&lt; bitCount;</span>
<span class="nc" id="L533">      bitCount += tableBitCount;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">      bitCount -= (count &lt; max? 1 : 0);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      previousIs0 = (count == 1);</span>

<span class="nc bnc" id="L537" title="All 2 branches missed.">      if (remaining &lt; 1) {</span>
<span class="nc" id="L538">        throw new AssertionError();</span>
      }

<span class="nc bnc" id="L541" title="All 2 branches missed.">      while (remaining &lt; threshold) {</span>
<span class="nc" id="L542">        tableBitCount--;</span>
<span class="nc" id="L543">        threshold &gt;&gt;= 1;</span>
      }

      // flush bitstream if necessary
<span class="nc bnc" id="L547" title="All 2 branches missed.">      if (bitCount &gt; 16) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        Util.checkArgument(output + Constants.SIZE_OF_SHORT &lt;= outputLimit,</span>
                           OUTPUT_BUFFER_TOO_SMALL);

<span class="nc" id="L551">        UnsafeUtil.UNSAFE.putShort(outputBase, output, (short) bitStream);</span>
<span class="nc" id="L552">        output += Constants.SIZE_OF_SHORT;</span>

<span class="nc" id="L554">        bitStream &gt;&gt;&gt;= Short.SIZE;</span>
<span class="nc" id="L555">        bitCount -= Short.SIZE;</span>
      }
<span class="nc" id="L557">    }</span>

    // flush remaining bitstream
<span class="nc bnc" id="L560" title="All 2 branches missed.">    Util.checkArgument(output + Constants.SIZE_OF_SHORT &lt;= outputLimit,</span>
                       OUTPUT_BUFFER_TOO_SMALL);
<span class="nc" id="L562">    UnsafeUtil.UNSAFE.putShort(outputBase, output, (short) bitStream);</span>
<span class="nc" id="L563">    output += (bitCount + 7) / 8;</span>

<span class="nc bnc" id="L565" title="All 2 branches missed.">    Util.checkArgument(symbol &lt;= maxSymbol + 1, &quot;Error&quot;); // TODO</span>

<span class="nc" id="L567">    return (int) (output - outputAddress);</span>
  }

  public static final class Table {
    final int[] newState;
    final byte[] symbol;
    final byte[] numberOfBits;
    int log2Size;

<span class="nc" id="L576">    public Table(final int log2Capacity) {</span>
<span class="nc" id="L577">      final int capacity = 1 &lt;&lt; log2Capacity;</span>
<span class="nc" id="L578">      newState = new int[capacity];</span>
<span class="nc" id="L579">      symbol = new byte[capacity];</span>
<span class="nc" id="L580">      numberOfBits = new byte[capacity];</span>
<span class="nc" id="L581">    }</span>

    public Table(final int log2Size, final int[] newState, final byte[] symbol,
<span class="nc" id="L584">                 final byte[] numberOfBits) {</span>
<span class="nc" id="L585">      final int size = 1 &lt;&lt; log2Size;</span>
<span class="nc bnc" id="L586" title="All 6 branches missed.">      if (newState.length != size || symbol.length != size ||</span>
          numberOfBits.length != size) {
<span class="nc" id="L588">        throw new IllegalArgumentException(</span>
            &quot;Expected arrays to match provided size&quot;);
      }

<span class="nc" id="L592">      this.log2Size = log2Size;</span>
<span class="nc" id="L593">      this.newState = newState;</span>
<span class="nc" id="L594">      this.symbol = symbol;</span>
<span class="nc" id="L595">      this.numberOfBits = numberOfBits;</span>
<span class="nc" id="L596">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>