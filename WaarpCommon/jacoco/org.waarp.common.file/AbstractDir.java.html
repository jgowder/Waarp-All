<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDir.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Common</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.file</a> &gt; <span class="el_source">AbstractDir.java</span></div><h1>AbstractDir.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.file;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.command.exception.Reply501Exception;
import org.waarp.common.command.exception.Reply530Exception;
import org.waarp.common.command.exception.Reply550Exception;
import org.waarp.common.command.exception.Reply553Exception;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.DetectionUtils;
import org.waarp.common.utility.WaarpStringUtils;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.List;

/**
 * Abstract Main Implementation of Directory
 */
<span class="nc" id="L42">public abstract class AbstractDir implements DirInterface {</span>
  /**
   * Internal Logger
   */
<span class="fc" id="L46">  private static final WaarpLogger logger =</span>
<span class="fc" id="L47">      WaarpLoggerFactory.getLogger(AbstractDir.class);</span>
  /**
   * Current Directory
   */
  protected String currentDir;
  /**
   * SessionInterface
   */
  protected SessionInterface session;

  /**
   * Opts command for MLSx. (-1) means not supported, 0 supported but not
   * active, 1 supported and active
   */
  protected OptsMLSxInterface optsMLSx;
  /**
   * Hack to say Windows or Unix (root like X:\ or /)
   */
  protected static final boolean ISUNIX;
  /**
   * Roots for Windows system
   */
  protected static final File[] roots;

  /*
   * Init Windows Support
   */
  static {
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">    ISUNIX = !DetectionUtils.isWindows();</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    if (!ISUNIX) {</span>
<span class="nc" id="L77">      roots = File.listRoots();</span>
    } else {
<span class="fc" id="L79">      roots = new File[] { new File(&quot;/&quot;) };</span>
    }
<span class="fc" id="L81">  }</span>

  /**
   * @param file
   *
   * @return The corresponding Root file
   */
  protected File getCorrespondingRoot(final File file) {
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (ISUNIX) {</span>
<span class="nc" id="L90">      return new File(&quot;/&quot;);</span>
    }
<span class="nc" id="L92">    final String path = file.getAbsolutePath();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">    for (final File root : roots) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">      if (path.startsWith(root.getAbsolutePath())) {</span>
<span class="nc" id="L95">        return root;</span>
      }
    }
    // hack !
<span class="nc" id="L99">    logger.warn(&quot;No root found for &quot; + file.getAbsolutePath());</span>
<span class="nc" id="L100">    return roots[0];</span>
  }

  /**
   * Normalize Path to Internal unique representation
   *
   * @param path
   *
   * @return the normalized path
   */
  public static String normalizePath(final String path) {
<span class="fc" id="L111">    return path.replace('\\', SEPARATORCHAR);</span>
  }

  /**
   * Convert the URI representation of a file path to a simple path.
   * &lt;p&gt;
   * If the path is not an URI, this method does nothing.
   *
   * @param path
   *
   * @return the normalized path
   */
  public static String pathFromURI(String path) {

<span class="fc bfc" id="L125" title="All 2 branches covered.">    if (path.startsWith(&quot;file://&quot;)) {</span>
<span class="fc" id="L126">      int charToRemove = 7;</span>

<span class="fc bfc" id="L128" title="All 4 branches covered.">      if (path.charAt(7) == '/' &amp;&amp; path.charAt(9) == ':') {</span>
<span class="fc" id="L129">        charToRemove++;</span>
      }

<span class="fc" id="L132">      path = path.substring(charToRemove);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      if (path.contains(&quot;%&quot;)) {</span>
        try {
<span class="fc" id="L135">          path = URLDecoder.decode(path, WaarpStringUtils.UTF8.name());</span>
<span class="nc" id="L136">        } catch (final UnsupportedEncodingException e) {</span>
<span class="nc" id="L137">          logger.warn(&quot;Cannot convert filename to UTF-8: &quot; + path);</span>
<span class="fc" id="L138">        } catch (final IllegalArgumentException e) {</span>
          // ignore: it was propably not url-encoded!
<span class="pc" id="L140">        }</span>
      }
    }
<span class="fc" id="L143">    return path;</span>
  }

  /**
   * @return the SessionInterface
   */
  @Override
  public SessionInterface getSession() {
<span class="nc" id="L151">    return session;</span>
  }

  @Override
  public String validatePath(final String path)
      throws CommandAbstractException {
    String extDir;
<span class="nc bnc" id="L158" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L159">      extDir = path;</span>
<span class="nc" id="L160">      final File newDir = new File(extDir);</span>
      try {
<span class="nc" id="L162">        return validatePath(newDir);</span>
<span class="nc" id="L163">      } catch (final Reply553Exception e) {</span>
        // ignore and continue as it could be not absolute
      }
    }
<span class="nc bnc" id="L167" title="All 2 branches missed.">    if (path.charAt(0) == SEPARATORCHAR) {</span>
<span class="nc" id="L168">      extDir = path;</span>
    } else {
<span class="nc" id="L170">      extDir = currentDir + SEPARATOR + path;</span>
    }
    // Get the baseDir (mount point)
<span class="nc" id="L173">    final String baseDir = getSession().getAuth().getBaseDirectory();</span>
    // Get the translated real file path (removing '..')
<span class="nc" id="L175">    final File newDir = new File(baseDir, extDir);</span>
<span class="nc" id="L176">    return validatePath(newDir);</span>
  }

  /**
   * @param path
   *
   * @return True if the given Path is an absolute one under Windows System or
   *     should be an absolute one on Unix
   */
  public boolean isAbsolute(final String path) {
<span class="nc" id="L186">    File file = new File(path);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">    if (!ISUNIX) {</span>
<span class="nc" id="L188">      return file.isAbsolute();</span>
    } else {
<span class="nc" id="L190">      file = file.getParentFile();</span>
<span class="nc bnc" id="L191" title="All 6 branches missed.">      return file != null &amp;&amp; file.isAbsolute() &amp;&amp; file.isDirectory() &amp;&amp;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">             !file.getAbsolutePath().equals(File.separator);</span>
    }
  }

  /**
   * Consolidate Path as relative or absolute path to an absolute path
   *
   * @param path
   *
   * @return the consolidated path
   *
   * @throws CommandAbstractException
   */
  protected String consolidatePath(final String path)
      throws CommandAbstractException {
<span class="nc bnc" id="L207" title="All 4 branches missed.">    if (path == null || path.isEmpty()) {</span>
<span class="nc" id="L208">      throw new Reply501Exception(&quot;Path must not be empty&quot;);</span>
    }
    // First check if the path is relative or absolute
<span class="nc bnc" id="L211" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L212">      return normalizePath(path);</span>
    }
<span class="nc" id="L214">    String extDir = normalizePath(path);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">    if (extDir.charAt(0) != SEPARATORCHAR) {</span>
<span class="nc" id="L216">      extDir = currentDir + SEPARATOR + extDir;</span>
    }
<span class="nc" id="L218">    return extDir;</span>
  }

  /**
   * Construct the CanonicalPath without taking into account symbolic link
   *
   * @param dir
   *
   * @return the canonicalPath
   */
  protected String getCanonicalPath(final File dir) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">    if (ISUNIX) {</span>
      // resolve it without getting symbolic links
<span class="nc" id="L231">      final StringBuilder builder = new StringBuilder();</span>
      // Get the path in reverse order from end to start
<span class="nc" id="L233">      final List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L234">      File newdir = dir;</span>
<span class="nc" id="L235">      String lastdir = newdir.getName();</span>
<span class="nc" id="L236">      list.add(lastdir);</span>
<span class="nc" id="L237">      File parent = newdir.getParentFile();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      while (parent != null) {</span>
<span class="nc" id="L239">        newdir = parent;</span>
<span class="nc" id="L240">        lastdir = newdir.getName();</span>
<span class="nc" id="L241">        list.add(lastdir);</span>
<span class="nc" id="L242">        parent = newdir.getParentFile();</span>
      }
      // Now filter on '..' or '.'
<span class="nc bnc" id="L245" title="All 2 branches missed.">      for (int i = list.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L246">        final String curdir = list.get(i);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (&quot;.&quot;.equals(curdir)) {</span>
<span class="nc" id="L248">          list.remove(i);// removes '.'</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        } else if (&quot;..&quot;.equals(curdir)) {</span>
<span class="nc" id="L250">          list.remove(i);// removes '..'</span>
<span class="nc" id="L251">          final int len = list.size();</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">          if (len &gt; 0 &amp;&amp; i &lt; len) {</span>
<span class="nc" id="L253">            list.remove(i);// and removes parent dir</span>
          }
        }
      }
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (list.isEmpty()) {</span>
<span class="nc" id="L258">        return &quot;/&quot;;</span>
      }

<span class="nc bnc" id="L261" title="All 2 branches missed.">      for (int i = list.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L262">        builder.append('/').append(list.get(i));</span>
      }
<span class="nc" id="L264">      return builder.toString();</span>
    }
    // Windows version
    // no link so just use the default version of canonical Path
    try {
<span class="nc" id="L269">      return dir.getCanonicalPath();</span>
<span class="nc" id="L270">    } catch (final IOException e) {</span>
<span class="nc" id="L271">      return dir.getAbsolutePath();</span>
    }
  }

  /**
   * Same as validatePath but from a FileInterface
   *
   * @param dir
   *
   * @return the construct and validated path (could be different than the one
   *     given as argument, example: '..'
   *     are removed)
   *
   * @throws CommandAbstractException
   */
  protected String validatePath(final File dir)
      throws CommandAbstractException {
    String extDir;
<span class="nc" id="L289">    extDir = normalizePath(getCanonicalPath(dir));</span>
    // Get the relative business path
<span class="nc" id="L291">    extDir = getSession().getAuth().getRelativePath(extDir);</span>
    // Check if this business path is valid
<span class="nc bnc" id="L293" title="All 2 branches missed.">    if (getSession().getAuth().isBusinessPathValid(extDir)) {</span>
<span class="nc" id="L294">      return extDir;</span>
    }
<span class="nc" id="L296">    throw new Reply553Exception(&quot;Pathname not allowed&quot;);</span>
  }

  @Override
  public boolean isPathInCurrentDir(final String path) {
    final String extDir;
<span class="nc bnc" id="L302" title="All 2 branches missed.">    if (isAbsolute(path)) {</span>
<span class="nc" id="L303">      extDir = path;</span>
<span class="nc" id="L304">      final File newDir = new File(extDir);</span>
<span class="nc" id="L305">      return isPathInCurrentDir(newDir);</span>
    }
<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (path.charAt(0) == SEPARATORCHAR) {</span>
<span class="nc" id="L308">      extDir = path;</span>
    } else {
<span class="nc" id="L310">      extDir = currentDir + SEPARATOR + path;</span>
    }
    // Get the baseDir (mount point)
<span class="nc" id="L313">    final String baseDir = getSession().getAuth().getBaseDirectory();</span>
    // Get the translated real file path (removing '..')
<span class="nc" id="L315">    final File newDir = new File(baseDir, extDir);</span>
<span class="nc" id="L316">    return isPathInCurrentDir(newDir);</span>
  }

  /**
   * Validate a file according to the current Directory
   *
   * @param dir
   *
   * @return True if validated
   *
   * @throws CommandAbstractException
   */
  protected boolean isPathInCurrentDir(final File dir) {
    String extDir;
<span class="nc" id="L330">    extDir = normalizePath(getCanonicalPath(dir));</span>
    // Get the relative business path
<span class="nc" id="L332">    extDir = getSession().getAuth().getRelativePath(extDir);</span>
    // Check if this business path is valid
<span class="nc bnc" id="L334" title="All 2 branches missed.">    if (extDir.startsWith(currentDir)) {</span>
<span class="nc" id="L335">      return true;</span>
    }
<span class="nc" id="L337">    logger.warn(&quot;File not OK: {} not in {}&quot;, extDir, currentDir);</span>
<span class="nc" id="L338">    return false;</span>
  }

  /**
   * Finds all files matching a wildcard expression (based on '?', '~' or
   * '*').
   *
   * @param pathWithWildcard The wildcard expression with a business
   *     path.
   *
   * @return List of String as relative paths matching the wildcard
   *     expression.
   *     Those files are tested as valid
   *     from business point of view. If Wildcard support is not active,
   *     if the
   *     path contains any wildcards,
   *     it will throw an error.
   *
   * @throws CommandAbstractException
   */
  protected abstract List&lt;String&gt; wildcardFiles(String pathWithWildcard)
      throws CommandAbstractException;

  @Override
  public String getPwd() {
<span class="nc" id="L363">    return currentDir;</span>
  }

  @Override
  public boolean changeParentDirectory() throws CommandAbstractException {
<span class="nc" id="L368">    return changeDirectory(&quot;..&quot;);</span>
  }

  @Override
  public FileInterface setFile(final String path, final boolean append)
      throws CommandAbstractException {
<span class="nc" id="L374">    checkIdentify();</span>
<span class="nc" id="L375">    final String newpath = consolidatePath(path);</span>
<span class="nc" id="L376">    final List&lt;String&gt; paths = wildcardFiles(newpath);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (paths.size() != 1) {</span>
<span class="nc" id="L378">      throw new Reply550Exception(</span>
<span class="nc" id="L379">          &quot;File not found: &quot; + paths.size() + &quot; founds&quot;);</span>
    }
<span class="nc" id="L381">    final String extDir = paths.get(0);</span>
<span class="nc" id="L382">    return newFile(extDir, append);</span>
  }

  @Override
  public void checkIdentify() throws Reply530Exception {
<span class="nc bnc" id="L387" title="All 2 branches missed.">    if (!getSession().getAuth().isIdentified()) {</span>
<span class="nc" id="L388">      throw new Reply530Exception(&quot;User not authentified&quot;);</span>
    }
<span class="nc" id="L390">  }</span>

  @Override
  public void clear() {
<span class="nc" id="L394">    currentDir = null;</span>
<span class="nc" id="L395">  }</span>

  @Override
  public void initAfterIdentification() {
<span class="nc" id="L399">    currentDir = getSession().getAuth().getBusinessPath();</span>
<span class="nc" id="L400">  }</span>

  @Override
  public OptsMLSxInterface getOptsMLSx() {
<span class="nc" id="L404">    return optsMLSx;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>