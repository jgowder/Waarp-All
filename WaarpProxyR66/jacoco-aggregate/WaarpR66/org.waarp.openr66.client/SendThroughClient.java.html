<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SendThroughClient.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.client</a> &gt; <span class="el_source">SendThroughClient.java</span></div><h1>SendThroughClient.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.client;

import io.netty.channel.ChannelFuture;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.file.DataBlock;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.commander.ClientRunner;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.data.DbRule;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.exception.OpenR66DatabaseGlobalException;
import org.waarp.openr66.protocol.exception.OpenR66Exception;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolSystemException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.RetrieveRunner;
import org.waarp.openr66.protocol.localhandler.packet.EndRequestPacket;
import org.waarp.openr66.protocol.localhandler.packet.ErrorPacket;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;

/**
 * Class for Send Through client
 * &lt;p&gt;
 * This class does not included the real file transfer since it is up to the
 * business project to implement how
 * to read new data to be sent to the remote host. If an error occurs, no
 * transfer log is kept.
 * &lt;p&gt;
 * 1) Configuration must have been loaded&lt;br&gt;
 * &lt;br&gt;
 * 2) Pipeline and NetworkTransaction must have been initiated:&lt;br&gt;
 * &lt;tt&gt;     Configuration.configuration.pipelineInit();&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     NetworkTransaction networkTransaction = new
 * NetworkTransaction();&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 3) Prepare the request of transfer:&lt;br&gt;
 * &lt;tt&gt;     R66Future futureReq = new R66Future(true);&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     SendThroughClient transaction = new SendThroughClient(futureReq,...);&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     if (! transaction.initiateRequest()) { error }&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 4) Once initiateRequest() gives true, you are ready to send the data in
 * through mode like:&lt;br&gt;
 * &lt;tt&gt;     byte[] data = readOrGetInSomeWayData();&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     DataBlock block = transaction.transformToDataBlock(data);&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     futureWrite = transaction.writeWhenPossible(block);&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 5) Once you have finished, so this is the last block, you have to do the
 * following:&lt;br&gt;
 * If the last block is not empty:&lt;br&gt;
 * &lt;tt&gt;     DataBlock block = transaction.transformToDataBlock(data);&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     block.setEOF(true);&lt;/tt&gt;&lt;br&gt;
 * Or if the last block is empty:&lt;br&gt;
 * &lt;tt&gt;     DataBlock block = transaction.transformToDataBlock(null);&lt;/tt&gt;&lt;br&gt;
 * Then &lt;br&gt;
 * &lt;tt&gt;     futureWrite = transaction.writeWhenPossible(block);&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     futureWrite.awaitUninterruptibly();&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 6) If everything is in success:&lt;br&gt;
 * &lt;tt&gt;     transaction.finalizeRequest();&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * And now wait for the transfer to finish:&lt;br&gt;
 * &lt;tt&gt;     futureReq.awaitUninterruptibly();&lt;/tt&gt;&lt;br&gt;
 * &lt;tt&gt;     R66Result result = futureReq.getResult();&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 7) If there is the need to re-do, just re-execute the steps from 3 to 6.&lt;br&gt;
 * Don't forget at the very end to finish the global structure (steps 3 to 6 no
 * more executed):&lt;br&gt;
 * &lt;tt&gt;     networkTransaction.closeAll();&lt;/tt&gt;&lt;br&gt;
 * &lt;br&gt;
 * 8) In case of errors during steps 4 or 5 (and only those), call the
 * following:&lt;br&gt;
 * &lt;tr&gt;
 * transaction.transferInError(openR66Exception);
 * &lt;/tr&gt;
 * &lt;br&gt;
 * &lt;br&gt;
 *
 * @see TestSendThroughClient Class as example of usage in test part
 */
public abstract class SendThroughClient extends AbstractTransfer {
  protected final NetworkTransaction networkTransaction;
  protected LocalChannelReference localChannelReference;
  protected DbTaskRunner taskRunner;

  /**
   * @param future
   * @param remoteHost
   * @param filename
   * @param rulename
   * @param fileinfo
   * @param isMD5
   * @param blocksize
   * @param networkTransaction
   * @param id
   */
  protected SendThroughClient(final R66Future future, final String remoteHost,
                              final String filename, final String rulename,
                              final String fileinfo, final boolean isMD5,
                              final int blocksize, final long id,
                              final NetworkTransaction networkTransaction) {
<span class="fc" id="L131">    super(SendThroughClient.class, future, filename, rulename, fileinfo, isMD5,</span>
          remoteHost, blocksize, id, null);
<span class="fc" id="L133">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L134">  }</span>

  /**
   * DO NOT CALL THIS!
   */
  @Override
  public void run() {
<span class="nc" id="L141">    logger.error(&quot;DO NOT call this method for this class&quot;);</span>
<span class="nc" id="L142">  }</span>

  /**
   * Prior to call this method, the pipeline and NetworkTransaction must have
   * been initialized. It is the
   * responsibility of the caller to finish all network resources. Note that
   * this is only the first part of the
   * execution for this client.
   *
   * @return True if the initiate of the request is OK, else False
   */
  public boolean initiateRequest() {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L155">      logger = WaarpLoggerFactory.getLogger(SendThroughClient.class);</span>
    }
    final DbRule rule;
    try {
<span class="fc" id="L159">      rule = new DbRule(transferArgs.getRulename());</span>
<span class="nc" id="L160">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L161">      logger.error(&quot;Cannot get Rule: &quot; + transferArgs.getRulename() + &quot;: {}&quot;,</span>
<span class="nc" id="L162">                   e.getMessage());</span>
<span class="nc" id="L163">      future.setResult(</span>
          new R66Result(new OpenR66DatabaseGlobalException(e), null, true,
                        ErrorCode.Internal, null));
<span class="nc" id="L166">      future.setFailure(e);</span>
<span class="nc" id="L167">      return false;</span>
<span class="fc" id="L168">    }</span>
<span class="fc" id="L169">    int mode = rule.getMode();</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">    if (transferArgs.isMD5()) {</span>
<span class="fc" id="L171">      mode = RequestPacket.getModeMD5(mode);</span>
    }
<span class="fc" id="L173">    final String sep =</span>
<span class="fc" id="L174">        PartnerConfiguration.getSeparator(transferArgs.getRemoteHost());</span>
<span class="fc" id="L175">    final RequestPacket request =</span>
<span class="fc" id="L176">        new RequestPacket(transferArgs.getRulename(), mode,</span>
<span class="fc" id="L177">                          transferArgs.getFilename(),</span>
<span class="fc" id="L178">                          transferArgs.getBlockSize(), 0, transferArgs.getId(),</span>
<span class="fc" id="L179">                          transferArgs.getTransferInfo(), -1, sep);</span>
    // Not isRecv since it is the requester, so send =&gt; isSender is true
<span class="fc" id="L181">    final boolean isSender = true;</span>
    try {
      try {
        // no starttime since immediate
<span class="fc" id="L185">        taskRunner = new DbTaskRunner(rule, isSender, request,</span>
<span class="fc" id="L186">                                      transferArgs.getRemoteHost(), null);</span>
<span class="nc" id="L187">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L188">        logger.error(&quot;Cannot get task: {}&quot;, e.getMessage());</span>
<span class="nc" id="L189">        future.setResult(</span>
            new R66Result(new OpenR66DatabaseGlobalException(e), null, true,
                          ErrorCode.Internal, null));
<span class="nc" id="L192">        future.setFailure(e);</span>
<span class="nc" id="L193">        return false;</span>
<span class="fc" id="L194">      }</span>
<span class="fc" id="L195">      final ClientRunner runner =</span>
          new ClientRunner(networkTransaction, taskRunner, future);
<span class="fc" id="L197">      runner.setSendThroughMode();</span>
<span class="fc" id="L198">      OpenR66ProtocolNotYetConnectionException exc = null;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">      for (int i = 0; i &lt; Configuration.RETRYNB; i++) {</span>
        try {
<span class="fc" id="L201">          localChannelReference = runner.initRequest();</span>
<span class="fc" id="L202">          exc = null;</span>
<span class="fc" id="L203">          break;</span>
<span class="nc" id="L204">        } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="nc" id="L205">          logger.error(&quot;Cannot Connect&quot;, e);</span>
<span class="nc" id="L206">          future.setResult(</span>
              new R66Result(e, null, true, ErrorCode.ConnectionImpossible,
                            taskRunner));
<span class="nc" id="L209">          finalizeInErrorTransferRequest(runner, taskRunner,</span>
                                         ErrorCode.ConnectionImpossible);
<span class="nc" id="L211">          future.setFailure(e);</span>
<span class="nc" id="L212">          return false;</span>
<span class="nc" id="L213">        } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L214">          logger.error(&quot;Bad Protocol&quot;, e);</span>
<span class="nc" id="L215">          future.setResult(new R66Result(e, null, true, ErrorCode.TransferError,</span>
                                         taskRunner));
<span class="nc" id="L217">          future.setFailure(e);</span>
<span class="nc" id="L218">          return false;</span>
<span class="nc" id="L219">        } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="nc" id="L220">          logger.debug(&quot;Not Yet Connected&quot;, e);</span>
<span class="nc" id="L221">          exc = e;</span>
        }
      }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">      if (exc != null) {</span>
<span class="nc" id="L225">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L226">        logger.error(&quot;Cannot Connect&quot;, exc);</span>
<span class="nc" id="L227">        future.setResult(</span>
            new R66Result(exc, null, true, ErrorCode.ConnectionImpossible,
                          taskRunner));
<span class="nc" id="L230">        future.setFailure(exc);</span>
<span class="nc" id="L231">        return false;</span>
      }
      try {
<span class="fc" id="L234">        localChannelReference.waitReadyForSendThrough();</span>
<span class="nc" id="L235">      } catch (final OpenR66Exception e) {</span>
<span class="nc" id="L236">        logger.error(&quot;Cannot Transfer&quot;, e);</span>
<span class="nc" id="L237">        future.setResult(</span>
            new R66Result(e, null, true, ErrorCode.Internal, taskRunner));
<span class="nc" id="L239">        future.setFailure(e);</span>
<span class="nc" id="L240">        return false;</span>
<span class="fc" id="L241">      }</span>
      // now start the send from external data
<span class="fc" id="L243">      return true;</span>
    } finally {
<span class="pc bpc" id="L245" title="3 of 6 branches missed.">      if (taskRunner != null &amp;&amp; (future.isFailed() || nolog)) {</span>
        try {
<span class="nc" id="L247">          taskRunner.delete();</span>
<span class="nc" id="L248">        } catch (final WaarpDatabaseException ignored) {</span>
          // nothing
<span class="nc" id="L250">        }</span>
      }
    }
  }

  /**
   * Finalize the request
   */
  public void finalizeRequest() {
    try {
      try {
<span class="fc" id="L261">        ChannelUtils.writeEndTransfer(localChannelReference);</span>
<span class="nc" id="L262">      } catch (final OpenR66ProtocolPacketException e) {</span>
        // An error occurs!
        try {
<span class="nc" id="L265">          localChannelReference.getSession().setFinalizeTransfer(false,</span>
                                                                 new R66Result(
                                                                     e,
<span class="nc" id="L268">                                                                     localChannelReference.getSession(),</span>
                                                                     false,
                                                                     ErrorCode.Internal,
                                                                     taskRunner));
<span class="nc" id="L272">        } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L273">          transferInError(e1);</span>
<span class="nc" id="L274">          return;</span>
<span class="nc" id="L275">        } catch (final OpenR66ProtocolSystemException e1) {</span>
<span class="nc" id="L276">          transferInError(e1);</span>
<span class="nc" id="L277">          return;</span>
<span class="nc" id="L278">        }</span>
<span class="fc" id="L279">      }</span>
<span class="fc" id="L280">      localChannelReference.getFutureEndTransfer().awaitOrInterruptible();</span>
<span class="fc" id="L281">      logger.debug(&quot;Await future End Transfer done: {}&quot;,</span>
<span class="fc" id="L282">                   localChannelReference.getFutureEndTransfer().isSuccess());</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">      if (localChannelReference.getFutureEndTransfer().isSuccess()) {</span>
        // send a validation
<span class="fc" id="L285">        localChannelReference.sessionNewState(R66FiniteDualStates.ENDREQUESTS);</span>
<span class="fc" id="L286">        final EndRequestPacket validPacket =</span>
<span class="fc" id="L287">            new EndRequestPacket(ErrorCode.CompleteOk.ordinal());</span>
<span class="fc" id="L288">        final R66Session session = localChannelReference.getSession();</span>
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">        if (session != null &amp;&amp; session.getExtendedProtocol() &amp;&amp;</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            session.getBusinessObject() != null &amp;&amp;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            session.getBusinessObject().getInfo(session) != null) {</span>
<span class="nc" id="L292">          validPacket.setOptional(session.getBusinessObject().getInfo(session));</span>
        }
        try {
<span class="fc" id="L295">          ChannelUtils.writeAbstractLocalPacket(localChannelReference,</span>
                                                validPacket, false);
<span class="nc" id="L297">        } catch (final OpenR66ProtocolPacketException ignored) {</span>
          // nothing
<span class="fc" id="L299">        }</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (!localChannelReference.getFutureRequest().awaitOrInterruptible()) {</span>
          // valid it however
<span class="nc" id="L302">          localChannelReference.validateRequest(</span>
<span class="nc" id="L303">              localChannelReference.getFutureEndTransfer().getResult());</span>
        }
<span class="pc bpc" id="L305" title="2 of 4 branches missed.">        if (taskRunner != null &amp;&amp; taskRunner.isRequestOnRequested()) {</span>
<span class="nc" id="L306">          localChannelReference.close();</span>
        }
<span class="fc" id="L308">      } else {</span>
<span class="nc" id="L309">        transferInError(null);</span>
      }
    } finally {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">      if (taskRunner != null) {</span>
<span class="pc bpc" id="L313" title="3 of 6 branches missed.">        if (future.isDone() &amp;&amp; !future.isSuccess() || nolog) {</span>
          try {
<span class="nc" id="L315">            taskRunner.delete();</span>
<span class="nc" id="L316">          } catch (final WaarpDatabaseException ignored) {</span>
            // nothing
<span class="nc" id="L318">          }</span>
        }
      }
    }
<span class="fc" id="L322">  }</span>

  /**
   * To be used in case of error after a correct initiate of the request
   *
   * @param e
   */
  public void transferInError(final OpenR66Exception e) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">    if (localChannelReference != null) {</span>
<span class="nc" id="L331">      if (!localChannelReference.getFutureEndTransfer().getResult()</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                                .isAnswered()) {</span>
<span class="nc" id="L333">        final R66Result result =</span>
<span class="nc" id="L334">            new R66Result(e, localChannelReference.getSession(), true,</span>
                          ErrorCode.TransferError, taskRunner);
<span class="nc" id="L336">        logger.error(&quot;Transfer in error&quot;, e);</span>
<span class="nc" id="L337">        localChannelReference.sessionNewState(R66FiniteDualStates.ERROR);</span>
<span class="nc" id="L338">        final ErrorPacket error = new ErrorPacket(&quot;Transfer in error&quot;,</span>
<span class="nc" id="L339">                                                  ErrorCode.TransferError.getCode(),</span>
                                                  ErrorPacket.FORWARDCLOSECODE);
        try {
<span class="nc" id="L342">          ChannelUtils.writeAbstractLocalPacket(localChannelReference, error,</span>
                                                false);
<span class="nc" id="L344">        } catch (final OpenR66ProtocolPacketException ignored) {</span>
          // nothing
<span class="nc" id="L346">        }</span>
<span class="nc" id="L347">        localChannelReference.invalidateRequest(result);</span>
      }
<span class="nc" id="L349">      localChannelReference.close();</span>
    }
<span class="nc" id="L351">  }</span>

  /**
   * Write the next block when the channel is ready to prevent OOM
   *
   * @param block
   *
   * @return the ChannelFuture on the write operation
   *
   * @throws OpenR66ProtocolPacketException
   */
  public ChannelFuture writeWhenPossible(final DataBlock block)
      throws OpenR66ProtocolPacketException {
<span class="fc" id="L364">    return RetrieveRunner.writeWhenPossible(block, localChannelReference, null,</span>
                                            null);
  }

  /**
   * Utility method for send through mode
   *
   * @param data the data byte, if null it is the last block
   * @param length length of data
   *
   * @return the DataBlock associated to the data
   */
  public DataBlock transformToDataBlock(final byte[] data, final int length) {
<span class="nc" id="L377">    final DataBlock block = new DataBlock();</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">    if (data == null) {</span>
      // last block
<span class="nc" id="L380">      block.setEOF(true);</span>
    } else {
<span class="nc" id="L382">      block.setBlock(data, length);</span>
    }
<span class="nc" id="L384">    return block;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>