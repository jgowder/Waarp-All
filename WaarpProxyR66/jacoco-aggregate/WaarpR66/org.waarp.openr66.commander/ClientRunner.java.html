<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientRunner.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.commander</a> &gt; <span class="el_source">ClientRunner.java</span></div><h1>ClientRunner.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.commander;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.database.data.AbstractDbData;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.RecvThroughHandler;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66FiniteDualStates;
import org.waarp.openr66.context.R66Result;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.task.exception.OpenR66RunnerErrorException;
import org.waarp.openr66.database.DbConstantR66;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.database.data.DbTaskRunner.TASKSTEP;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.Messages;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotAuthenticatedException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNotYetConnectionException;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;
import org.waarp.openr66.protocol.networkhandler.NetworkTransaction;
import org.waarp.openr66.protocol.utils.ChannelUtils;
import org.waarp.openr66.protocol.utils.R66Future;
import org.waarp.openr66.protocol.utils.TransferUtils;

import java.io.File;
import java.net.SocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Client Runner from a TaskRunner
 */
public class ClientRunner extends Thread {
  private static final String CANNOT_CONNECT_TO_SERVER =
      &quot;Cannot connect to server &quot;;

  private static final String NO_RESULT = &quot;no result&quot;;

  private static final String REQUEST_INFORMATION_FAILURE =
      &quot;RequestInformation.Failure&quot;;

  private static final String REQUEST_INFORMATION_SUCCESS =
      &quot;RequestInformation.Success&quot;;

  private static final String TRANSFER_STATUS = &quot;Transfer.Status&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L78">  private static final WaarpLogger logger =</span>
<span class="fc" id="L79">      WaarpLoggerFactory.getLogger(ClientRunner.class);</span>

  private static final ConcurrentHashMap&lt;String, Integer&gt;
<span class="fc" id="L82">      taskRunnerRetryHashMap = new ConcurrentHashMap&lt;String, Integer&gt;();</span>

  public static ConcurrentLinkedQueue&lt;ClientRunner&gt; activeRunners;

  private final NetworkTransaction networkTransaction;

  private final DbTaskRunner taskRunner;

  private final R66Future futureRequest;

  private RecvThroughHandler handler;

  private boolean isSendThroughMode;

  private LocalChannelReference localChannelReference;

  private final String nameTask;

<span class="fc" id="L100">  private boolean limitRetryConnection = true;</span>

  public ClientRunner(NetworkTransaction networkTransaction,
<span class="fc" id="L103">                      DbTaskRunner taskRunner, R66Future futureRequest) {</span>
<span class="fc" id="L104">    this.networkTransaction = networkTransaction;</span>
<span class="fc" id="L105">    this.taskRunner = taskRunner;</span>
<span class="fc" id="L106">    this.futureRequest = futureRequest;</span>
<span class="fc" id="L107">    setDaemon(true);</span>
<span class="fc" id="L108">    nameTask = &quot;Client_Runner_&quot; + taskRunner.getKey();</span>
<span class="fc" id="L109">    setName(nameTask);</span>
<span class="fc" id="L110">  }</span>

  public static String hashStatus() {
<span class="nc" id="L113">    return &quot;ClientRunner: [taskRunnerRetryHashMap: &quot; +</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">           taskRunnerRetryHashMap.size() + &quot; activeRunners: &quot; +</span>
<span class="nc" id="L115">           (activeRunners != null? activeRunners.size() : 0) + &quot;] &quot;;</span>
  }

  /**
   * @return the networkTransaction
   */
  public NetworkTransaction getNetworkTransaction() {
<span class="nc" id="L122">    return networkTransaction;</span>
  }

  /**
   * @return the taskRunner
   */
  public DbTaskRunner getTaskRunner() {
<span class="nc" id="L129">    return taskRunner;</span>
  }

  /**
   * @return the localChannelReference
   */
  public LocalChannelReference getLocalChannelReference() {
<span class="fc" id="L136">    return localChannelReference;</span>
  }

  @Override
  public void run() {
<span class="pc bpc" id="L141" title="2 of 4 branches missed.">    if (Configuration.configuration.isShutdown() || Thread.interrupted()) {</span>
<span class="nc" id="L142">      taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc" id="L143">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L144">      return;</span>
    }
    try {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L148">        activeRunners.add(this);</span>
      }
      // fix for SelfRequest
<span class="fc bfc" id="L151" title="All 2 branches covered.">      if (taskRunner.isSelfRequest()) {</span>
<span class="fc" id="L152">        taskRunner.setSenderByRequestToValidate(false);</span>
      }
      // Try to check if file still exists in send not self not through mode
<span class="fc bfc" id="L155" title="All 4 branches covered.">      if (taskRunner.isSender() &amp;&amp; !taskRunner.isSelfRequest() &amp;&amp;</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">          !taskRunner.isSendThrough()) {</span>
        try {
<span class="fc" id="L158">          R66Session session = new R66Session();</span>
<span class="fc" id="L159">          session.setReady(true);</span>
<span class="fc" id="L160">          boolean ssl = Configuration.configuration.isUseSSL();</span>
<span class="fc" id="L161">          session.getAuth().specialNoSessionAuth(ssl,</span>
                                                 Configuration.configuration
<span class="fc" id="L163">                                                     .getHostId(ssl));</span>
<span class="fc" id="L164">          DbTaskRunner reloaded =</span>
<span class="fc" id="L165">              new DbTaskRunner(session, taskRunner.getRule(),</span>
<span class="fc" id="L166">                               taskRunner.getSpecialId(),</span>
<span class="fc" id="L167">                               taskRunner.getRequester(),</span>
<span class="fc" id="L168">                               taskRunner.getRequested());</span>
<span class="fc" id="L169">          session.setRunner(reloaded);</span>
<span class="fc" id="L170">          File file = new File(reloaded.getFullFilePath());</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">          if (!file.isFile()) {</span>
<span class="fc" id="L172">            logger.warn(&quot;File not found: {}&quot;, file.getAbsolutePath());</span>
            // File does no more exist =&gt; error
<span class="fc" id="L174">            reloaded.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="fc" id="L175">            reloaded.setErrorExecutionStatus(ErrorCode.FileNotFound);</span>
<span class="fc" id="L176">            logger</span>
<span class="fc" id="L177">                .error(&quot;Runner Error: {} {}&quot;, ErrorCode.FileNotFound.getMesg(),</span>
<span class="fc" id="L178">                       taskRunner.toShortString());</span>
<span class="fc" id="L179">            reloaded.setErrorTask();</span>
<span class="fc" id="L180">            reloaded.update();</span>
<span class="fc" id="L181">            return;</span>
          }
<span class="nc" id="L183">        } catch (CommandAbstractException e) {</span>
          // Wrong path? Ignore
<span class="nc" id="L185">          logger.warn(e);</span>
<span class="nc" id="L186">        } catch (OpenR66RunnerErrorException e) {</span>
          // Wrong run error? Ignore
<span class="nc" id="L188">          logger.warn(e);</span>
<span class="fc" id="L189">        } catch (WaarpDatabaseException e) {</span>
          // Wrong dbtask? Ignore
<span class="fc" id="L191">          logger.warn(e);</span>
<span class="nc" id="L192">        } catch (OpenR66ProtocolNoSslException e) {</span>
          // Wrong ssl? Ignore
<span class="nc" id="L194">          logger.warn(e);</span>
<span class="pc" id="L195">        }</span>
      }
      R66Future transfer;
      try {
<span class="fc" id="L199">        transfer = runTransfer();</span>
<span class="nc" id="L200">      } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L201">        logger.error(&quot;Runner Error: {} {}&quot;, e.getMessage(),</span>
<span class="nc" id="L202">                     taskRunner.toShortString());</span>
<span class="nc" id="L203">        return;</span>
<span class="fc" id="L204">      } catch (final OpenR66ProtocolNoConnectionException e) {</span>
<span class="fc" id="L205">        logger.error(&quot;No connection Error {}&quot;, e.getMessage());</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (localChannelReference != null) {</span>
<span class="nc" id="L207">          localChannelReference</span>
<span class="nc" id="L208">              .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                               ErrorCode.ConnectionImpossible);
        }
<span class="fc" id="L211">        taskRunner.setErrorTask();</span>
        try {
<span class="fc" id="L213">          taskRunner.forceSaveStatus();</span>
<span class="fc" id="L214">          taskRunner.run();</span>
<span class="nc" id="L215">        } catch (final OpenR66RunnerErrorException e1) {</span>
<span class="nc" id="L216">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">        return;</span>
<span class="nc" id="L220">      } catch (final OpenR66ProtocolPacketException e) {</span>
<span class="nc" id="L221">        logger.error(&quot;Protocol Error&quot;, e);</span>
<span class="nc" id="L222">        return;</span>
<span class="fc" id="L223">      } catch (final OpenR66ProtocolNotYetConnectionException e) {</span>
<span class="fc" id="L224">        logger.warn(&quot;No connection warning {}&quot;, e.getMessage());</span>
<span class="fc" id="L225">        return;</span>
<span class="fc" id="L226">      }</span>
<span class="fc" id="L227">      final R66Result result = transfer.getResult();</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      if (result != null) {</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        if (result.getCode() == ErrorCode.QueryAlreadyFinished) {</span>
<span class="nc" id="L230">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                      (transfer.isSuccess()?</span>
<span class="nc" id="L232">                          Messages.getString(REQUEST_INFORMATION_SUCCESS) :</span>
<span class="nc" id="L233">                          Messages.getString(REQUEST_INFORMATION_FAILURE)) +</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                      &quot;     &quot; + ErrorCode.QueryAlreadyFinished.getMesg() + ':' +</span>
<span class="nc" id="L235">                      (result != null? result.toString() : NO_RESULT));</span>
        } else {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">          if (transfer.isSuccess()) {</span>
<span class="fc" id="L238">            logger.info(Messages.getString(TRANSFER_STATUS) +</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">                        Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
                        &quot;     &quot; +
<span class="pc" id="L241">                        (result != null? result.toString() : NO_RESULT));</span>
          } else {
<span class="nc" id="L243">            logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                         Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                         &quot;     &quot; +
<span class="nc" id="L246">                         (result != null? result.toString() : NO_RESULT));</span>
          }
        }
      } else {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (transfer.isSuccess()) {</span>
<span class="nc" id="L251">          logger.warn(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L252">                      Messages.getString(REQUEST_INFORMATION_SUCCESS) +</span>
                      &quot;     no result&quot;);
        } else {
<span class="nc" id="L255">          logger.error(Messages.getString(TRANSFER_STATUS) +</span>
<span class="nc" id="L256">                       Messages.getString(REQUEST_INFORMATION_FAILURE) +</span>
                       &quot;     no result&quot;);
        }
      }
    } finally {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">      if (activeRunners != null) {</span>
<span class="nc" id="L262">        activeRunners.remove(this);</span>
      }
<span class="fc" id="L264">      setName(&quot;Finished_&quot; + nameTask);</span>
    }
<span class="fc" id="L266">  }</span>

  /**
   * @param runner
   * @param limit
   *
   * @return True if the task was run less than limit, else False
   */
  public boolean incrementTaskRunnerTry(DbTaskRunner runner, int limit) {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">    if (!isLimitRetryConnection()) {</span>
<span class="nc" id="L276">      return true;</span>
    }
<span class="fc" id="L278">    final String key = runner.getKey();</span>
<span class="fc" id="L279">    Integer tries = taskRunnerRetryHashMap.get(key);</span>
<span class="fc" id="L280">    logger.debug(&quot;try to find integer: &quot; + tries);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">    if (tries == null) {</span>
<span class="fc" id="L282">      tries = Integer.valueOf(1);</span>
    } else {
<span class="fc" id="L284">      tries += 1;</span>
    }
<span class="fc bfc" id="L286" title="All 2 branches covered.">    logger.debug(&quot;Check: {} vs {}: {}&quot;, tries, limit, limit &lt;= tries);</span>
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">    if (limit &lt;= tries || Thread.interrupted()) {</span>
<span class="fc" id="L288">      taskRunnerRetryHashMap.remove(key);</span>
<span class="fc" id="L289">      return false;</span>
    } else {
<span class="fc" id="L291">      taskRunnerRetryHashMap.put(key, tries);</span>
<span class="fc" id="L292">      return true;</span>
    }
  }

  /**
   * True transfer run (can be called directly to enable exception outside any
   * executors)
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future runTransfer()
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L311">    logger.debug(&quot;Start attempt Transfer&quot;);</span>
<span class="fc" id="L312">    localChannelReference = initRequest();</span>
<span class="fc" id="L313">    localChannelReference.getFutureValidRequest().awaitOrInterruptible(</span>
<span class="fc" id="L314">        Configuration.configuration.getTimeoutCon());</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">    if (localChannelReference.getFutureValidRequest().isSuccess()) {</span>
<span class="fc" id="L316">      return finishTransfer(localChannelReference);</span>
<span class="nc" id="L317">    } else if (</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult() != null &amp;&amp;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        localChannelReference.getFutureValidRequest().getResult().getCode() ==</span>
        ErrorCode.ServerOverloaded) {
<span class="nc" id="L321">      return tryAgainTransferOnOverloaded(true, localChannelReference);</span>
    } else {
<span class="nc" id="L323">      return finishTransfer(localChannelReference);</span>
    }
  }

  /**
   * In case an overloaded signal is returned by the requested
   *
   * @param retry if True, it will retry in case of overloaded remote
   *     server, else it just stops
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public R66Future tryAgainTransferOnOverloaded(boolean retry,
                                                LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException, OpenR66ProtocolNoConnectionException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="nc bnc" id="L346" title="All 2 branches missed.">    if (this.localChannelReference == null) {</span>
<span class="nc" id="L347">      this.localChannelReference = localChannelReference;</span>
    }
<span class="nc" id="L349">    final boolean incRetry =</span>
<span class="nc" id="L350">        incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB);</span>
<span class="nc" id="L351">    logger.debug(&quot;tryAgainTransferOnOverloaded: &quot; + retry + ':' + incRetry);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    switch (taskRunner.getUpdatedInfo()) {</span>
      case DONE:
      case INERROR:
      case INTERRUPTED:
<span class="nc" id="L356">        break;</span>
      default:
<span class="nc" id="L358">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ServerOverloaded,</span>
                          true);
    }
    // redo if possible
<span class="nc bnc" id="L362" title="All 4 branches missed.">    if (retry &amp;&amp; incRetry) {</span>
      try {
<span class="nc" id="L364">        Thread.sleep(Configuration.configuration.getConstraintLimitHandler()</span>
<span class="nc" id="L365">                                                .getSleepTime());</span>
<span class="nc" id="L366">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L367">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L368">      }</span>
<span class="nc" id="L369">      return runTransfer();</span>
    } else {
<span class="nc bnc" id="L371" title="All 2 branches missed.">      if (localChannelReference == null) {</span>
<span class="nc" id="L372">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
      }
<span class="nc" id="L374">      taskRunner.getLocalChannelReference()</span>
<span class="nc" id="L375">                .setErrorMessage(ErrorCode.ConnectionImpossible.getMesg(),</span>
                                 ErrorCode.ConnectionImpossible);
<span class="nc" id="L377">      taskRunner.setErrorTask();</span>
<span class="nc" id="L378">      taskRunner.run();</span>
<span class="nc" id="L379">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;End of retry on ServerOverloaded&quot;);
    }
  }

  /**
   * Finish the transfer (called at the end of runTransfer)
   *
   * @param localChannelReference
   *
   * @return The R66Future of the transfer operation
   *
   * @throws OpenR66ProtocolNotYetConnectionException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66RunnerErrorException
   */
  public R66Future finishTransfer(LocalChannelReference localChannelReference)
      throws OpenR66RunnerErrorException {
<span class="fc bfc" id="L398" title="All 2 branches covered.">    if (this.localChannelReference == null) {</span>
<span class="fc" id="L399">      this.localChannelReference = localChannelReference;</span>
    }
<span class="fc" id="L401">    final R66Future transfer = localChannelReference.getFutureRequest();</span>
<span class="fc" id="L402">    transfer.awaitOrInterruptible();</span>
<span class="fc" id="L403">    taskRunnerRetryHashMap.remove(taskRunner.getKey());</span>
<span class="fc" id="L404">    logger.info(&quot;Request done with {}&quot;,</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">                transfer.isSuccess()? &quot;success&quot; : &quot;error&quot;);</span>
<span class="fc" id="L406">    localChannelReference.close();</span>
    // now reload TaskRunner if it still exists (light client can forget it)
<span class="fc" id="L408">    final boolean isSender = taskRunner.isSender();</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    if (transfer.isSuccess()) {</span>
      try {
<span class="fc" id="L411">        taskRunner.select();</span>
<span class="nc" id="L412">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L413">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;, e);</span>
<span class="nc" id="L414">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L415">      }</span>
<span class="fc" id="L416">      taskRunner.setSender(isSender);</span>
<span class="fc" id="L417">      changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
    } else {
      try {
<span class="fc" id="L420">        taskRunner.select();</span>
<span class="nc" id="L421">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L422">        logger.debug(&quot;Not a problem but cannot find at the end the task&quot;);</span>
<span class="nc" id="L423">        taskRunner.setFrom(transfer.getRunner());</span>
<span class="fc" id="L424">      }</span>
<span class="fc" id="L425">      taskRunner.setSender(isSender);</span>
      // Case when we were interrupted
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">      if (transfer.getResult() == null) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
<span class="nc" id="L430">            final R66Result ok =</span>
                new R66Result(null, true, ErrorCode.CompleteOk, taskRunner);
<span class="nc" id="L432">            transfer.setResult(ok);</span>
<span class="nc" id="L433">            transfer.setSuccess();</span>
<span class="nc" id="L434">            changeUpdatedInfo(UpdatedInfo.DONE, ErrorCode.CompleteOk, false);</span>
<span class="nc" id="L435">            break;</span>
          case INERROR:
          case INTERRUPTED:
          default:
<span class="nc" id="L439">            final R66Result error =</span>
                new R66Result(null, true, ErrorCode.Internal, taskRunner);
<span class="nc" id="L441">            transfer.setResult(error);</span>
<span class="nc" id="L442">            transfer.cancel();</span>
<span class="nc" id="L443">            changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.Internal, false);</span>
        }
<span class="nc" id="L445">        return transfer;</span>
      }
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">      if (transfer.getResult().getCode() == ErrorCode.QueryAlreadyFinished) {</span>
        // check if post task to execute
<span class="nc" id="L449">        logger.warn(&quot;WARN QueryAlreadyFinished:     &quot; + transfer + &quot;     &quot; +</span>
<span class="nc" id="L450">                    taskRunner.toShortString());</span>
        try {
<span class="nc" id="L452">          TransferUtils</span>
<span class="nc" id="L453">              .finalizeTaskWithNoSession(taskRunner, localChannelReference);</span>
<span class="nc" id="L454">        } catch (final OpenR66RunnerErrorException e) {</span>
<span class="nc" id="L455">          taskRunner.changeUpdatedInfo(UpdatedInfo.INERROR);</span>
<span class="nc" id="L456">          taskRunner.forceSaveStatus();</span>
<span class="nc" id="L457">        }</span>
      } else {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        switch (taskRunner.getUpdatedInfo()) {</span>
          case DONE:
          case INERROR:
          case INTERRUPTED:
          case TOSUBMIT:
<span class="fc" id="L464">            break;</span>
          default:
<span class="nc" id="L466">            changeUpdatedInfo(UpdatedInfo.INERROR,</span>
<span class="nc" id="L467">                              transfer.getResult().getCode(), false);</span>
        }
      }
    }
<span class="fc" id="L471">    return transfer;</span>
  }

  /**
   * Initialize the request
   *
   * @return the localChannelReference holding the transfer request
   *
   * @throws OpenR66ProtocolNoConnectionException
   * @throws OpenR66RunnerErrorException
   * @throws OpenR66ProtocolPacketException
   * @throws OpenR66ProtocolNotYetConnectionException
   */
  public LocalChannelReference initRequest()
      throws OpenR66ProtocolNoConnectionException, OpenR66RunnerErrorException,
             OpenR66ProtocolPacketException,
             OpenR66ProtocolNotYetConnectionException {
<span class="fc" id="L488">    changeUpdatedInfo(UpdatedInfo.RUNNING, ErrorCode.Running, true);</span>
<span class="fc" id="L489">    final long id = taskRunner.getSpecialId();</span>
    String tid;
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    if (id == DbConstantR66.ILLEGALVALUE) {</span>
<span class="nc" id="L492">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            &quot;_NEWTRANSFER&quot;;
    } else {
<span class="fc" id="L495">      tid = &quot;Runner_&quot; + taskRunner.getRuleId() + '_' + taskRunner.getMode() +</span>
            '_' + id;
    }
<span class="fc" id="L498">    setName(tid);</span>
<span class="fc" id="L499">    logger.debug(&quot;Will run {}&quot;, taskRunner);</span>
<span class="fc" id="L500">    boolean restartPost = false;</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    if (taskRunner.getGloballaststep() == TASKSTEP.POSTTASK.ordinal()) {</span>
      // Send a validation to requested
<span class="nc bnc" id="L503" title="All 2 branches missed.">      if (!taskRunner.isSelfRequested()) {</span>
        // restart
<span class="nc" id="L505">        restartPost = true;</span>
      }
    }
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">    if (taskRunner.isSelfRequested()) {</span>
      // Don't have to restart a task for itself (or should use requester)
<span class="nc" id="L510">      logger.warn(&quot;Requested host cannot initiate itself the request&quot;);</span>
<span class="nc" id="L511">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.LoopSelfRequestedHost,</span>
                        true);
<span class="nc" id="L513">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Requested host cannot initiate itself the request&quot;);
    }
    DbHostAuth host;
    try {
<span class="fc" id="L518">      host = new DbHostAuth(taskRunner.getRequested());</span>
<span class="fc" id="L519">    } catch (final WaarpDatabaseException e) {</span>
<span class="fc" id="L520">      logger.error(</span>
<span class="fc" id="L521">          &quot;Requested host cannot be found: &quot; + taskRunner.getRequested());</span>
<span class="fc" id="L522">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.NotKnownHost, true);</span>
<span class="fc" id="L523">      throw new OpenR66ProtocolNoConnectionException(</span>
<span class="fc" id="L524">          &quot;Requested host cannot be found &quot; + taskRunner.getRequested());</span>
<span class="fc" id="L525">    }</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">    if (host.isClient()) {</span>
<span class="nc" id="L527">      logger.warn(&quot;Cannot initiate a connection with a client: {}&quot;, host);</span>
<span class="nc" id="L528">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                        true);
<span class="nc" id="L530">      throw new OpenR66ProtocolNoConnectionException(</span>
          &quot;Cannot connect to client &quot; + host);
    }
<span class="fc" id="L533">    SocketAddress socketAddress = host.getSocketAddress();</span>
<span class="fc" id="L534">    final boolean isSSL = host.isSsl();</span>

    LocalChannelReference localChannelReference;
    try {
<span class="fc" id="L538">      localChannelReference = networkTransaction</span>
<span class="fc" id="L539">          .createConnectionWithRetryWithAuthenticationException(socketAddress,</span>
                                                                isSSL,
                                                                futureRequest);
<span class="nc" id="L542">    } catch (OpenR66ProtocolNotAuthenticatedException e1) {</span>
<span class="nc" id="L543">      changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.BadAuthent, true);</span>
<span class="nc" id="L544">      taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L545">      throw new OpenR66ProtocolNoConnectionException(</span>
          CANNOT_CONNECT_TO_SERVER + host +
          &quot; cannot be authenticated so stop retry here&quot;, e1);
<span class="fc" id="L548">    }</span>
<span class="fc" id="L549">    taskRunner.setLocalChannelReference(localChannelReference);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    if (localChannelReference == null) {</span>
      // propose to redo
      String retry;
<span class="fc bfc" id="L553" title="All 2 branches covered.">      if (incrementTaskRunnerTry(taskRunner, Configuration.RETRYNB)) {</span>

<span class="fc" id="L555">        logger.debug(&quot;Will retry since Cannot connect to {}&quot;, host);</span>
<span class="fc" id="L556">        retry = &quot; but will retry&quot;;</span>
        // now wait
        try {
<span class="fc" id="L559">          Thread.sleep(Configuration.configuration.getDelayRetry());</span>
<span class="nc" id="L560">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L561">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L562">          logger.debug(</span>
              &quot;Will not retry since an interruption occurs while connection &quot; +
              &quot;to {}&quot;, host);
<span class="nc" id="L565">          retry = &quot; and retries gets an interruption so stop here&quot;;</span>
<span class="nc" id="L566">          changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                            true);
<span class="nc" id="L568">          taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="nc" id="L569">          throw new OpenR66ProtocolNoConnectionException(</span>
              CANNOT_CONNECT_TO_SERVER + host + retry);
<span class="fc" id="L571">        }</span>
<span class="fc" id="L572">        changeUpdatedInfo(UpdatedInfo.TOSUBMIT, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L574">        throw new OpenR66ProtocolNotYetConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      } else {
<span class="fc" id="L577">        logger.debug(</span>
            &quot;Will not retry since limit of connection attemtps is reached for {}&quot;,
            host);
<span class="fc" id="L580">        retry = &quot; and retries reach step limit so stop here&quot;;</span>
<span class="fc" id="L581">        changeUpdatedInfo(UpdatedInfo.INERROR, ErrorCode.ConnectionImpossible,</span>
                          true);
<span class="fc" id="L583">        taskRunner.setLocalChannelReference(new LocalChannelReference());</span>
<span class="fc" id="L584">        throw new OpenR66ProtocolNoConnectionException(</span>
            CANNOT_CONNECT_TO_SERVER + host + retry);
      }
    }
<span class="fc bfc" id="L588" title="All 2 branches covered.">    if (handler != null) {</span>
<span class="fc" id="L589">      localChannelReference.setRecvThroughHandler(handler);</span>
    }
<span class="fc" id="L591">    localChannelReference.setSendThroughMode(isSendThroughMode);</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">    if (restartPost) {</span>
<span class="nc" id="L593">      RequestPacket request = taskRunner.getRequest();</span>
<span class="nc" id="L594">      logger.debug(&quot;Will send request {} &quot;, request);</span>
<span class="nc" id="L595">      localChannelReference.setClientRunner(this);</span>
<span class="nc" id="L596">      localChannelReference.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
      try {
<span class="nc" id="L598">        ChannelUtils</span>
<span class="nc" id="L599">            .writeAbstractLocalPacket(localChannelReference, request, true);</span>
<span class="nc" id="L600">      } catch (final OpenR66ProtocolPacketException e) {</span>
        // propose to redo
<span class="nc" id="L602">        logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L603">        changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L604">        localChannelReference.close();</span>
<span class="nc" id="L605">        throw e;</span>
<span class="nc" id="L606">      }</span>
<span class="nc" id="L607">      logger.debug(&quot;Wait for request to {}&quot;, host);</span>
<span class="nc" id="L608">      return localChannelReference;</span>
    }
    // If Requester is NOT Sender, and if TransferTask then decrease now if
    // possible the rank
<span class="fc bfc" id="L612" title="All 2 branches covered.">    if (!taskRunner.isSender() &amp;&amp;</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        taskRunner.getGloballaststep() == TASKSTEP.TRANSFERTASK.ordinal()) {</span>
<span class="nc" id="L614">      logger</span>
<span class="nc" id="L615">          .debug(&quot;Requester is not Sender so decrease if possible the rank {}&quot;,</span>
                 taskRunner);
<span class="nc" id="L617">      taskRunner.restartRank();</span>
<span class="nc" id="L618">      taskRunner.forceSaveStatus();</span>
<span class="nc" id="L619">      logger.debug(</span>
<span class="nc" id="L620">          &quot;Requester is not Sender so new rank is &quot; + taskRunner.getRank() +</span>
          &quot; {}&quot;, taskRunner);
    }
<span class="fc" id="L623">    RequestPacket request = taskRunner.getRequest();</span>
<span class="fc" id="L624">    request</span>
<span class="fc" id="L625">        .setLimit(localChannelReference.getChannelLimit(taskRunner.isSender()));</span>
<span class="fc" id="L626">    localChannelReference.setClientRunner(this);</span>
<span class="fc" id="L627">    logger.debug(&quot;Will send request {} {}&quot;, request, localChannelReference);</span>
<span class="fc" id="L628">    localChannelReference.sessionNewState(R66FiniteDualStates.REQUESTR);</span>
    try {
<span class="fc" id="L630">      ChannelUtils</span>
<span class="fc" id="L631">          .writeAbstractLocalPacket(localChannelReference, request, true);</span>
<span class="nc" id="L632">    } catch (final OpenR66ProtocolPacketException e) {</span>
      // propose to redo
<span class="nc" id="L634">      logger.warn(&quot;Cannot transfer request to &quot; + host);</span>
<span class="nc" id="L635">      changeUpdatedInfo(UpdatedInfo.INTERRUPTED, ErrorCode.Internal, true);</span>
<span class="nc" id="L636">      localChannelReference.close();</span>
<span class="nc" id="L637">      throw e;</span>
<span class="fc" id="L638">    }</span>
<span class="fc" id="L639">    logger.debug(&quot;Wait for request to {} {} {}&quot;, host, localChannelReference,</span>
                 request);
<span class="fc" id="L641">    return localChannelReference;</span>
  }

  /**
   * Change the UpdatedInfo of the current runner
   *
   * @param info
   */
  public void changeUpdatedInfo(AbstractDbData.UpdatedInfo info, ErrorCode code,
                                boolean force) {
<span class="fc" id="L651">    taskRunner.changeUpdatedInfo(info);</span>
<span class="fc" id="L652">    taskRunner.setErrorExecutionStatus(code);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">    if (force) {</span>
<span class="fc" id="L654">      taskRunner.forceSaveStatus();</span>
    } else {
      try {
<span class="fc" id="L657">        taskRunner.saveStatus();</span>
<span class="nc" id="L658">      } catch (final OpenR66RunnerErrorException ignored) {</span>
        // nothing
<span class="fc" id="L660">      }</span>
    }
<span class="fc" id="L662">  }</span>

  /**
   * @param handler the handler to set
   */
  public void setRecvThroughHandler(RecvThroughHandler handler) {
<span class="fc" id="L668">    this.handler = handler;</span>
<span class="fc" id="L669">  }</span>

  public void setSendThroughMode() {
<span class="fc" id="L672">    isSendThroughMode = true;</span>
<span class="fc" id="L673">  }</span>

  public boolean getSendThroughMode() {
<span class="nc" id="L676">    return isSendThroughMode;</span>
  }

  public boolean isLimitRetryConnection() {
<span class="fc" id="L680">    return limitRetryConnection;</span>
  }

  public void setLimitRetryConnection(final boolean limitRetryConnection) {
<span class="fc" id="L684">    this.limitRetryConnection = limitRetryConnection;</span>
<span class="fc" id="L685">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>