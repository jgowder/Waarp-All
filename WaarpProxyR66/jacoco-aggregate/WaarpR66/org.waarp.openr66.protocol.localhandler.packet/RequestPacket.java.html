<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RequestPacket.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.localhandler.packet</a> &gt; <span class="el_source">RequestPacket.java</span></div><h1>RequestPacket.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.protocol.localhandler.packet;

import com.fasterxml.jackson.databind.node.ObjectNode;
import io.netty.buffer.ByteBuf;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolPacketException;
import org.waarp.openr66.protocol.localhandler.LocalChannelReference;

/**
 * Request class
 * &lt;p&gt;
 * header = &quot;rulename MODETRANS&quot; middle = way+&quot;FILENAME BLOCKSIZE RANK specialId
 * code (optional length)&quot; end =
 * &quot;fileInformation&quot;
 * &lt;p&gt;
 * or
 * &lt;p&gt;
 * header = &quot;{rule:rulename, mode:MODETRANS}&quot; middle = way{filename:FILENAME,
 * block:BLOCKSIZE, rank:RANK,
 * id:specialId, code:code, length:length}&quot; end = &quot;fileInformation&quot;
 */
public class RequestPacket extends AbstractLocalPacket {
  /**
   * Internal Logger
   */
<span class="fc" id="L52">  private static final WaarpLogger logger =</span>
<span class="fc" id="L53">      WaarpLoggerFactory.getLogger(RequestPacket.class);</span>
  private static final String NOT_ENOUGH_DATA = &quot;Not enough data&quot;;

<span class="fc" id="L56">  public enum TRANSFERMODE {</span>
<span class="fc" id="L57">    UNKNOWNMODE, SENDMODE, RECVMODE, SENDMD5MODE, RECVMD5MODE, SENDTHROUGHMODE,</span>
<span class="fc" id="L58">    RECVTHROUGHMODE, SENDMD5THROUGHMODE, RECVMD5THROUGHMODE</span>
  }

<span class="fc" id="L61">  protected enum FIELDS {</span>
<span class="fc" id="L62">    rule, mode, filename, block, rank, id, code, length, limit</span>
  }

  protected static final byte REQVALIDATE = 0;

  protected static final byte REQANSWERVALIDATE = 1;

  protected final String rulename;

  protected final int mode;

  protected String filename;

  protected final int blocksize;

  protected int rank;

  protected long specialId;

  protected byte way;

  protected char code;

  protected long originalSize;

  protected long limit;

  protected final String transferInformation;

<span class="fc" id="L91">  protected String separator = PartnerConfiguration.getSEPARATOR_FIELD();</span>

  /**
   * @param mode
   *
   * @return the same mode (RECV or SEND) in MD5 version
   */
  public static int getModeMD5(final int mode) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">    switch (mode) {</span>
      case 1:
      case 2:
      case 5:
      case 6:
<span class="fc" id="L104">        return mode + 2;</span>
      default:
        // nothing
    }
<span class="fc" id="L108">    return mode;</span>
  }

  /**
   * @param mode
   *
   * @return true if this mode is a RECV(MD5) mode
   */
  public static boolean isRecvMode(final int mode) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">    return mode == TRANSFERMODE.RECVMODE.ordinal() ||</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">           mode == TRANSFERMODE.RECVMD5MODE.ordinal() ||</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">           mode == TRANSFERMODE.RECVTHROUGHMODE.ordinal() ||</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">           mode == TRANSFERMODE.RECVMD5THROUGHMODE.ordinal();</span>
  }

  /**
   * @param mode
   * @param isRequested
   *
   * @return True if this mode is a THROUGH (MD5) mode
   */
  public static boolean isSendThroughMode(final int mode,
                                          final boolean isRequested) {
<span class="fc bfc" id="L131" title="All 6 branches covered.">    return !isRequested &amp;&amp; isSendThroughMode(mode) ||</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">           isRequested &amp;&amp; isRecvThroughMode(mode);</span>
  }

  /**
   * @param mode
   *
   * @return True if this mode is a SEND THROUGH (MD5) mode
   */
  public static boolean isSendThroughMode(final int mode) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">    return mode == TRANSFERMODE.SENDTHROUGHMODE.ordinal() ||</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">           mode == TRANSFERMODE.SENDMD5THROUGHMODE.ordinal();</span>
  }

  /**
   * @param mode
   * @param isRequested
   *
   * @return True if this mode is a THROUGH (MD5) mode
   */
  public static boolean isRecvThroughMode(final int mode,
                                          final boolean isRequested) {
<span class="fc bfc" id="L153" title="All 6 branches covered.">    return !isRequested &amp;&amp; isRecvThroughMode(mode) ||</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">           isRequested &amp;&amp; isSendThroughMode(mode);</span>
  }

  /**
   * @param mode
   *
   * @return True if this mode is a RECV THROUGH (MD5) mode
   */
  public static boolean isRecvThroughMode(final int mode) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    return mode == TRANSFERMODE.RECVTHROUGHMODE.ordinal() ||</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">           mode == TRANSFERMODE.RECVMD5THROUGHMODE.ordinal();</span>
  }

  public static boolean isSendMode(final int mode) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">    return !isRecvMode(mode);</span>
  }

  /**
   * @param mode
   *
   * @return True if this mode is a THROUGH mode (with or without MD5)
   */
  public static boolean isThroughMode(final int mode) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    return mode &gt;= TRANSFERMODE.SENDTHROUGHMODE.ordinal() &amp;&amp;</span>
<span class="pc bnc" id="L178" title="All 2 branches missed.">           mode &lt;= TRANSFERMODE.RECVMD5THROUGHMODE.ordinal();</span>
  }

  /**
   * @param mode
   *
   * @return true if this mode is a MD5 mode
   */
  public static boolean isMD5Mode(final int mode) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">    return mode == TRANSFERMODE.RECVMD5MODE.ordinal() ||</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">           mode == TRANSFERMODE.SENDMD5MODE.ordinal() ||</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">           mode == TRANSFERMODE.SENDMD5THROUGHMODE.ordinal() ||</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">           mode == TRANSFERMODE.RECVMD5THROUGHMODE.ordinal();</span>
  }

  /**
   * @param mode1
   * @param mode2
   *
   * @return true if both modes are compatible (both send, or both recv)
   */
  public static boolean isCompatibleMode(final int mode1, final int mode2) {
<span class="fc bfc" id="L200" title="All 4 branches covered.">    return isRecvMode(mode1) &amp;&amp; isRecvMode(mode2) ||</span>
<span class="fc bfc" id="L201" title="All 4 branches covered.">           !isRecvMode(mode1) &amp;&amp; !isRecvMode(mode2);</span>
  }

  /**
   * @param headerLength
   * @param middleLength
   * @param endLength
   * @param buf
   *
   * @return the new RequestPacket from buffer
   *
   * @throws OpenR66ProtocolPacketException
   */
  public static RequestPacket createFromBuffer(final int headerLength,
                                               final int middleLength,
                                               final int endLength,
                                               final ByteBuf buf)
      throws OpenR66ProtocolPacketException {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (headerLength - 1 &lt;= 0) {</span>
<span class="nc" id="L220">      throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
    }
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (middleLength &lt;= 1) {</span>
<span class="nc" id="L223">      throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
    }
<span class="fc" id="L225">    final byte[] bheader = new byte[headerLength - 1];</span>
<span class="fc" id="L226">    final byte[] bmiddle = new byte[middleLength - 1];// valid is not in bmiddle</span>
<span class="fc" id="L227">    final byte[] bend = new byte[endLength];</span>
<span class="fc" id="L228">    buf.readBytes(bheader);</span>
<span class="fc" id="L229">    final byte valid = buf.readByte();</span>
<span class="fc" id="L230">    buf.readBytes(bmiddle);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">    if (endLength &gt; 0) {</span>
<span class="fc" id="L232">      buf.readBytes(bend);</span>
    }
<span class="fc" id="L234">    final String sheader = new String(bheader, WaarpStringUtils.UTF8);</span>
<span class="fc" id="L235">    final String smiddle = new String(bmiddle, WaarpStringUtils.UTF8);</span>
<span class="fc" id="L236">    final String send = new String(bend, WaarpStringUtils.UTF8);</span>

    // check if JSON on header since it will directly starts with a JSON, in contrary to middle
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    if (sheader.startsWith(PartnerConfiguration.BAR_JSON_FIELD)) {</span>
      // JSON
<span class="fc" id="L241">      logger.debug(&quot;Request is using JSON&quot;);</span>
<span class="fc" id="L242">      final ObjectNode map = JsonHandler.getFromString(sheader);</span>
<span class="fc" id="L243">      final ObjectNode map2 = JsonHandler.getFromString(smiddle);</span>
<span class="fc" id="L244">      return new RequestPacket(map.path(FIELDS.rule.name()).asText(),</span>
<span class="fc" id="L245">                               map.path(FIELDS.mode.name()).asInt(),</span>
<span class="fc" id="L246">                               map2.path(FIELDS.filename.name()).asText(),</span>
<span class="fc" id="L247">                               map2.path(FIELDS.block.name()).asInt(),</span>
<span class="fc" id="L248">                               map2.path(FIELDS.rank.name()).asInt(),</span>
<span class="fc" id="L249">                               map2.path(FIELDS.id.name()).asLong(), valid,</span>
                               send,
<span class="fc" id="L251">                               (char) map2.path(FIELDS.code.name()).asInt(),</span>
<span class="fc" id="L252">                               map2.path(FIELDS.length.name()).asLong(),</span>
                               // Get speed if it exists if not speed is set to 0
<span class="fc" id="L254">                               map2.path(FIELDS.limit.name()).asLong(0),</span>
                               PartnerConfiguration.BAR_JSON_FIELD);
    }

<span class="nc" id="L258">    final String[] aheader =</span>
<span class="nc" id="L259">        sheader.split(PartnerConfiguration.BLANK_SEPARATOR_FIELD);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (aheader.length != 2) {</span>
<span class="nc" id="L261">      throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
    }
    // FIX to check both ' ' and SEPARATOR_FIELD
<span class="nc" id="L264">    String[] amiddle = smiddle.split(PartnerConfiguration.BAR_SEPARATOR_FIELD);</span>
<span class="nc" id="L265">    String sep = PartnerConfiguration.BAR_SEPARATOR_FIELD;</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if (amiddle.length &lt; 5) {</span>
<span class="nc" id="L267">      amiddle = smiddle.split(PartnerConfiguration.BLANK_SEPARATOR_FIELD);</span>
<span class="nc" id="L268">      sep = PartnerConfiguration.BLANK_SEPARATOR_FIELD;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (amiddle.length &lt; 5) {</span>
<span class="nc" id="L270">        throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
      }
    }
<span class="nc" id="L273">    int blocksize = Integer.parseInt(amiddle[1]);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">    if (blocksize &lt; 100) {</span>
<span class="nc" id="L275">      blocksize = Configuration.configuration.getBlockSize();</span>
    }
<span class="nc" id="L277">    final int rank = Integer.parseInt(amiddle[2]);</span>
<span class="nc" id="L278">    final long specialId = Long.parseLong(amiddle[3]);</span>
<span class="nc" id="L279">    final char code = amiddle[4].charAt(0);</span>
<span class="nc" id="L280">    long originalSize = -1;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (amiddle.length &gt; 5) {</span>
<span class="nc" id="L282">      originalSize = Long.parseLong(amiddle[5]);</span>
    }
<span class="nc" id="L284">    return new RequestPacket(aheader[0], Integer.parseInt(aheader[1]),</span>
                             amiddle[0], blocksize, rank, specialId, valid,
                             send, code, originalSize, sep);
  }

  /**
   * @param rulename
   * @param mode
   * @param filename
   * @param blocksize
   * @param rank
   * @param specialId
   * @param valid
   * @param transferInformation
   * @param code
   * @param originalSize
   */
  private RequestPacket(final String rulename, final int mode,
                        final String filename, final int blocksize,
                        final int rank, final long specialId, final byte valid,
                        final String transferInformation, final char code,
<span class="fc" id="L305">                        final long originalSize, final String separator) {</span>
<span class="fc" id="L306">    this.rulename = rulename;</span>
<span class="fc" id="L307">    this.mode = mode;</span>
<span class="fc" id="L308">    this.filename = filename;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (blocksize &lt; 100) {</span>
<span class="fc" id="L310">      this.blocksize = Configuration.configuration.getBlockSize();</span>
    } else {
<span class="fc" id="L312">      this.blocksize = blocksize;</span>
    }
<span class="fc" id="L314">    this.rank = rank;</span>
<span class="fc" id="L315">    this.specialId = specialId;</span>
<span class="fc" id="L316">    way = valid;</span>
<span class="fc" id="L317">    this.transferInformation = transferInformation;</span>
<span class="fc" id="L318">    this.code = code;</span>
<span class="fc" id="L319">    this.originalSize = originalSize;</span>
<span class="fc" id="L320">    this.separator = separator;</span>
<span class="fc" id="L321">  }</span>

  /**
   * @param rulename
   * @param mode
   * @param filename
   * @param blocksize
   * @param rank
   * @param specialId
   * @param transferInformation
   */
  public RequestPacket(final String rulename, final int mode,
                       final String filename, final int blocksize,
                       final int rank, final long specialId,
                       final String transferInformation,
                       final long originalSize, final String separator) {
<span class="fc" id="L337">    this(rulename, mode, filename, blocksize, rank, specialId, REQVALIDATE,</span>
         transferInformation, ErrorCode.InitOk.code, originalSize, separator);
<span class="fc" id="L339">  }</span>

  /**
   * Create a Request packet with a speed negociation
   */
  private RequestPacket(final String rulename, final int mode,
                        final String filename, final int blocksize,
                        final int rank, final long specialId, final byte valid,
                        final String transferInformation, final char code,
                        final long originalSize, final long limit,
                        final String separator) {
<span class="fc" id="L350">    this(rulename, mode, filename, blocksize, rank, specialId, valid,</span>
         transferInformation, code, originalSize, separator);
<span class="fc" id="L352">    this.limit = limit;</span>
<span class="fc" id="L353">  }</span>

  @Override
  public final boolean hasGlobalBuffer() {
<span class="fc" id="L357">    return false;</span>
  }

  @Override
  public final void createAllBuffers(final LocalChannelReference lcr,
                                     final int networkHeader) {
<span class="nc" id="L363">    throw new IllegalStateException(&quot;Should not be called&quot;);</span>
  }

  @Override
  public final synchronized void createEnd(final LocalChannelReference lcr) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">    if (transferInformation != null) {</span>
<span class="fc" id="L369">      end = WaarpNettyUtil.wrappedBuffer(</span>
<span class="fc" id="L370">          transferInformation.getBytes(WaarpStringUtils.UTF8));</span>
    }
<span class="fc" id="L372">  }</span>

  @Override
  public final synchronized void createHeader(final LocalChannelReference lcr)
      throws OpenR66ProtocolPacketException {
<span class="pc bpc" id="L377" title="2 of 4 branches missed.">    if (rulename == null || mode &lt;= 0) {</span>
<span class="nc" id="L378">      throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
    }
<span class="pc bpc" id="L380" title="2 of 4 branches missed.">    if (lcr.getPartner() != null &amp;&amp; lcr.getPartner().useJson()) {</span>
<span class="fc" id="L381">      logger.debug(&quot;Request will use JSON {}&quot;, lcr.getPartner());</span>
<span class="fc" id="L382">      final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="fc" id="L383">      JsonHandler.setValue(node, FIELDS.rule, rulename);</span>
<span class="fc" id="L384">      JsonHandler.setValue(node, FIELDS.mode, mode);</span>
<span class="fc" id="L385">      header = WaarpNettyUtil.wrappedBuffer(</span>
<span class="fc" id="L386">          JsonHandler.writeAsString(node).getBytes(WaarpStringUtils.UTF8));</span>
<span class="fc" id="L387">    } else {</span>
<span class="nc" id="L388">      header =</span>
<span class="nc" id="L389">          WaarpNettyUtil.wrappedBuffer(rulename.getBytes(WaarpStringUtils.UTF8),</span>
<span class="nc" id="L390">                                       PartnerConfiguration.BLANK_SEPARATOR_FIELD.getBytes(</span>
                                           WaarpStringUtils.UTF8),
<span class="nc" id="L392">                                       Integer.toString(mode)</span>
<span class="nc" id="L393">                                              .getBytes(WaarpStringUtils.UTF8));</span>
    }
<span class="fc" id="L395">  }</span>

  @Override
  public final synchronized void createMiddle(final LocalChannelReference lcr)
      throws OpenR66ProtocolPacketException {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">    if (filename == null) {</span>
<span class="nc" id="L401">      throw new OpenR66ProtocolPacketException(NOT_ENOUGH_DATA);</span>
    }
<span class="fc" id="L403">    final byte[] away = { way };</span>
<span class="pc bpc" id="L404" title="2 of 4 branches missed.">    if (lcr.getPartner() != null &amp;&amp; lcr.getPartner().useJson()) {</span>
<span class="fc" id="L405">      logger.debug(&quot;Request {} will use JSON {}&quot;, specialId, lcr.getPartner());</span>
<span class="fc" id="L406">      final ObjectNode node = JsonHandler.createObjectNode();</span>
<span class="fc" id="L407">      JsonHandler.setValue(node, FIELDS.filename, filename);</span>
<span class="fc" id="L408">      JsonHandler.setValue(node, FIELDS.block, blocksize);</span>
<span class="fc" id="L409">      JsonHandler.setValue(node, FIELDS.rank, rank);</span>
<span class="fc" id="L410">      JsonHandler.setValue(node, FIELDS.id, specialId);</span>
<span class="fc" id="L411">      JsonHandler.setValue(node, FIELDS.code, code);</span>
<span class="fc" id="L412">      JsonHandler.setValue(node, FIELDS.length, originalSize);</span>
      // Add limit if specified
<span class="fc" id="L414">      JsonHandler.setValue(node, FIELDS.limit, limit);</span>
<span class="fc" id="L415">      middle = WaarpNettyUtil.wrappedBuffer(away,</span>
<span class="fc" id="L416">                                            JsonHandler.writeAsString(node)</span>
<span class="fc" id="L417">                                                       .getBytes(</span>
                                                           WaarpStringUtils.UTF8));
<span class="fc" id="L419">    } else {</span>
<span class="nc" id="L420">      middle = WaarpNettyUtil.wrappedBuffer(away, filename.getBytes(</span>
<span class="nc" id="L421">                                                WaarpStringUtils.UTF8), separator.getBytes(WaarpStringUtils.UTF8),</span>
<span class="nc" id="L422">                                            Integer.toString(blocksize)</span>
<span class="nc" id="L423">                                                   .getBytes(</span>
                                                       WaarpStringUtils.UTF8),
<span class="nc" id="L425">                                            separator.getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L427">                                            Integer.toString(rank).getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L429">                                            separator.getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L431">                                            Long.toString(specialId).getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L433">                                            separator.getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L435">                                            Character.toString(code).getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L437">                                            separator.getBytes(</span>
                                                WaarpStringUtils.UTF8),
<span class="nc" id="L439">                                            Long.toString(originalSize)</span>
<span class="nc" id="L440">                                                .getBytes(</span>
                                                    WaarpStringUtils.UTF8));
    }
<span class="fc" id="L443">  }</span>

  @Override
  public final byte getType() {
<span class="fc" id="L447">    return LocalPacketFactory.REQUESTPACKET;</span>
  }

  @Override
  public final String toString() {
<span class="nc" id="L452">    return &quot;RequestPacket: &quot; + specialId + &quot; : &quot; + rulename + &quot; : &quot; + mode +</span>
           &quot; :  &quot; + filename + &quot; : &quot; + transferInformation + &quot; : &quot; + blocksize +
           &quot; : &quot; + rank + &quot; : &quot; + way + &quot; : &quot; + code + &quot; : &quot; + originalSize +
           &quot; : &quot; + limit;
  }

  /**
   * @return the rulename
   */
  public final String getRulename() {
<span class="fc" id="L462">    return rulename;</span>
  }

  /**
   * @return the filename
   */
  public final String getFilename() {
<span class="fc" id="L469">    return filename;</span>
  }

  /**
   * @return the mode
   */
  public final int getMode() {
<span class="fc" id="L476">    return mode;</span>
  }

  /**
   * @return True if this packet concerns a Retrieve operation
   */
  public final boolean isRetrieve() {
<span class="fc" id="L483">    return isRecvMode(mode);</span>
  }

  /**
   * @return the fifinal Information
   */
  public final String getTransferInformation() {
<span class="fc" id="L490">    return transferInformation;</span>
  }

  /**
   * @return the blocksize
   */
  public final int getBlocksize() {
<span class="fc" id="L497">    return blocksize;</span>
  }

  /**
   * @return the rank
   */
  public final int getRank() {
<span class="fc" id="L504">    return rank;</span>
  }

  /**
   * @param rank the rank to set
   */
  public final void setRank(final int rank) {
<span class="fc" id="L511">    this.rank = rank;</span>
<span class="fc" id="L512">  }</span>

  /**
   * @return the originalSize
   */
  public final long getOriginalSize() {
<span class="fc" id="L518">    return originalSize;</span>
  }

  /**
   * @param originalSize the originalSize to set
   */
  public final void setOriginalSize(final long originalSize) {
<span class="fc" id="L525">    this.originalSize = originalSize;</span>
<span class="fc" id="L526">  }</span>

  /**
   * @param specialId the specialId to set
   */
  public final void setSpecialId(final long specialId) {
<span class="fc" id="L532">    this.specialId = specialId;</span>
<span class="fc" id="L533">  }</span>

  /**
   * @return the specialId
   */
  public final long getSpecialId() {
<span class="fc" id="L539">    return specialId;</span>
  }

  /**
   * @return True if this packet is to be validated
   */
  public final boolean isToValidate() {
<span class="fc bfc" id="L546" title="All 2 branches covered.">    return way == REQVALIDATE;</span>
  }

  /**
   * Validate the request
   */
  public final synchronized void validate() {
<span class="fc" id="L553">    way = REQANSWERVALIDATE;</span>
<span class="fc" id="L554">    middle = null;</span>
<span class="fc" id="L555">  }</span>

  /**
   * @param filename the filename to set
   */
  public void setFilename(final String filename) {
<span class="fc" id="L561">    this.filename = filename;</span>
<span class="fc" id="L562">  }</span>

  /**
   * @return the code
   */
  public final char getCode() {
<span class="fc" id="L568">    return code;</span>
  }

  /**
   * @param code the code to set
   */
  public final void setCode(final char code) {
<span class="nc" id="L575">    this.code = code;</span>
<span class="nc" id="L576">  }</span>

  public final long getLimit() {
<span class="fc" id="L579">    return limit;</span>
  }

  public final void setLimit(final long limit) {
<span class="fc" id="L583">    this.limit = limit;</span>
<span class="fc" id="L584">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>