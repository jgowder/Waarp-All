<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTask.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Proxy in R66 protocol</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.context.task</a> &gt; <span class="el_source">AbstractTask.java</span></div><h1>AbstractTask.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.context.task;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.filesystem.R66Dir;
import org.waarp.openr66.context.filesystem.R66File;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.utils.R66Future;

import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.regex.Pattern;

/**
 * Abstract implementation of task
 */
public abstract class AbstractTask implements Runnable {
  /**
   * Internal Logger
   */
<span class="fc" id="L48">  private static final WaarpLogger logger =</span>
<span class="fc" id="L49">      WaarpLoggerFactory.getLogger(AbstractTask.class);</span>
<span class="fc" id="L50">  protected static final Pattern BLANK = WaarpStringUtils.BLANK;</span>
  /**
   * Current full path of current FILENAME
   */
  public static final String TRUEFULLPATH = &quot;#TRUEFULLPATH#&quot;;

  /**
   * Current FILENAME (basename) (change in retrieval part)
   */
  public static final String TRUEFILENAME = &quot;#TRUEFILENAME#&quot;;
  /**
   * Current full path of Original FILENAME (as transmitted) (before changing
   * in
   * retrieval part)
   */
  public static final String ORIGINALFULLPATH = &quot;#ORIGINALFULLPATH#&quot;;

  /**
   * Original FILENAME (basename) (before changing in retrieval part)
   */
  public static final String ORIGINALFILENAME = &quot;#ORIGINALFILENAME#&quot;;

  /**
   * Size of the current FILE
   */
  public static final String FILESIZE = &quot;#FILESIZE#&quot;;

  /**
   * Current full path of current RULE
   */
  public static final String RULE = &quot;#RULE#&quot;;

  /**
   * Date in yyyyMMdd format
   */
  public static final String DATE = &quot;#DATE#&quot;;

  /**
   * Hour in HHmmss format
   */
  public static final String HOUR = &quot;#HOUR#&quot;;

  /**
   * Remote host id (if not the initiator of the call)
   */
  public static final String REMOTEHOST = &quot;#REMOTEHOST#&quot;;

  /**
   * Remote host address
   */
  public static final String REMOTEHOSTADDR = &quot;#REMOTEHOSTADDR#&quot;;

  /**
   * Local host id
   */
  public static final String LOCALHOST = &quot;#LOCALHOST#&quot;;

  /**
   * Local host address
   */
  public static final String LOCALHOSTADDR = &quot;#LOCALHOSTADDR#&quot;;

  /**
   * Transfer id
   */
  public static final String TRANSFERID = &quot;#TRANSFERID#&quot;;

  /**
   * Requester Host
   */
  public static final String REQUESTERHOST = &quot;#REQUESTERHOST#&quot;;

  /**
   * Requested Host
   */
  public static final String REQUESTEDHOST = &quot;#REQUESTEDHOST#&quot;;

  /**
   * Full Transfer id (TRANSFERID_REQUESTERHOST_REQUESTEDHOST)
   */
  public static final String FULLTRANSFERID = &quot;#FULLTRANSFERID#&quot;;

  /**
   * Current or final RANK of block
   */
  public static final String RANKTRANSFER = &quot;#RANKTRANSFER#&quot;;

  /**
   * Block size used
   */
  public static final String BLOCKSIZE = &quot;#BLOCKSIZE#&quot;;

  /**
   * IN Path used
   */
  public static final String INPATH = &quot;#INPATH#&quot;;

  /**
   * OUT Path used
   */
  public static final String OUTPATH = &quot;#OUTPATH#&quot;;

  /**
   * WORK Path used
   */
  public static final String WORKPATH = &quot;#WORKPATH#&quot;;

  /**
   * ARCH Path used
   */
  public static final String ARCHPATH = &quot;#ARCHPATH#&quot;;

  /**
   * HOME Path used
   */
  public static final String HOMEPATH = &quot;#HOMEPATH#&quot;;
  /**
   * Last Current Error Message
   */
  public static final String ERRORMSG = &quot;#ERRORMSG#&quot;;
  /**
   * Last Current Error Code
   */
  public static final String ERRORCODE = &quot;#ERRORCODE#&quot;;
  /**
   * Last Current Error Code in Full String
   */
  public static final String ERRORSTRCODE = &quot;#ERRORSTRCODE#&quot;;
  /**
   * If specified, no Wait for Task Validation (default is wait)
   */
  public static final String NOWAIT = &quot;#NOWAIT#&quot;;
  /**
   * If specified, use the LocalExec Daemon specified in the global
   * configuration (default no usage of
   * LocalExec)
   */
  public static final String LOCALEXEC = &quot;#LOCALEXEC#&quot;;

  /**
   * Type of operation
   */
  final TaskType type;

  /**
   * Argument from Rule
   */
  final String argRule;

  /**
   * Delay from Rule (if applicable)
   */
  final int delay;

  /**
   * Argument from Transfer
   */
  final String argTransfer;

  /**
   * Current session
   */
  final R66Session session;

  /**
   * R66Future of completion
   */
  final R66Future futureCompletion;
  /**
   * Do we wait for a validation of the task ? Default = True
   */
<span class="fc" id="L221">  boolean waitForValidation = true;</span>
  /**
   * Do we need to use LocalExec for an Exec Task ? Default = False
   */
  boolean useLocalExec;

  /**
   * Constructor
   *
   * @param type
   * @param delay
   * @param argRule
   * @param argTransfer
   * @param session
   */
  AbstractTask(final TaskType type, final int delay, final String argRule,
<span class="fc" id="L237">               final String argTransfer, final R66Session session) {</span>
<span class="fc" id="L238">    this.type = type;</span>
<span class="fc" id="L239">    this.delay = delay;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (argRule != null) {</span>
<span class="fc" id="L241">      this.argRule = argRule.replaceAll(WaarpStringUtils.BLANK_REGEX, &quot; &quot;);</span>
    } else {
<span class="nc" id="L243">      this.argRule = null;</span>
    }
<span class="fc bfc" id="L245" title="All 2 branches covered.">    if (argTransfer != null) {</span>
<span class="fc" id="L246">      this.argTransfer =</span>
<span class="fc" id="L247">          argTransfer.replaceAll(WaarpStringUtils.BLANK_REGEX, &quot; &quot;);</span>
    } else {
<span class="fc" id="L249">      this.argTransfer = null;</span>
    }
<span class="fc" id="L251">    this.session = session;</span>
<span class="fc" id="L252">    futureCompletion = new R66Future(true);</span>
<span class="fc" id="L253">  }</span>

  /**
   * @return the TaskType of this AbstractTask
   */
  public TaskType getType() {
<span class="fc" id="L259">    return type;</span>
  }

  /**
   * @return True if the operation is in success status
   */
  public boolean isSuccess() {
<span class="fc" id="L266">    futureCompletion.awaitOrInterruptible();</span>
<span class="fc" id="L267">    return futureCompletion.isSuccess();</span>
  }

  /**
   * @return the R66Future of completion
   */
  public R66Future getFutureCompletion() {
<span class="fc" id="L274">    return futureCompletion;</span>
  }

  /**
   * @param arg as the Format string where FIXED items will be
   *     replaced by
   *     context values and next using
   *     argFormat as format second argument; this arg comes from the
   *     rule
   *     itself
   * @param argFormat as format second argument; this argFormat comes
   *     from
   *     the transfer Information itself
   *
   * @return The string with replaced values from context and second argument
   */
  protected String getReplacedValue(final String arg,
                                    final Object[] argFormat) {
<span class="fc" id="L292">    final StringBuilder builder = new StringBuilder(arg);</span>
    // check NOWAIT and LOCALEXEC
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">    if (arg.contains(NOWAIT)) {</span>
<span class="nc" id="L295">      waitForValidation = false;</span>
<span class="nc" id="L296">      WaarpStringUtils.replaceAll(builder, NOWAIT, &quot;&quot;);</span>
    }
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">    if (arg.contains(LOCALEXEC)) {</span>
<span class="nc" id="L299">      useLocalExec = true;</span>
<span class="nc" id="L300">      WaarpStringUtils.replaceAll(builder, LOCALEXEC, &quot;&quot;);</span>
    }
<span class="fc" id="L302">    File trueFile = null;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (session.getFile() != null) {</span>
<span class="fc" id="L304">      trueFile = session.getFile().getTrueFile();</span>
    }
<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (trueFile != null) {</span>
<span class="fc" id="L307">      WaarpStringUtils</span>
<span class="fc" id="L308">          .replaceAll(builder, TRUEFULLPATH, trueFile.getAbsolutePath());</span>
<span class="fc" id="L309">      WaarpStringUtils.replaceAll(builder, TRUEFILENAME, R66Dir</span>
<span class="fc" id="L310">          .getFinalUniqueFilename(session.getFile()));</span>
<span class="fc" id="L311">      WaarpStringUtils</span>
<span class="fc" id="L312">          .replaceAll(builder, FILESIZE, Long.toString(trueFile.length()));</span>
    } else {
<span class="fc" id="L314">      WaarpStringUtils.replaceAll(builder, TRUEFULLPATH, &quot;nofile&quot;);</span>
<span class="fc" id="L315">      WaarpStringUtils.replaceAll(builder, TRUEFILENAME, &quot;nofile&quot;);</span>
<span class="fc" id="L316">      WaarpStringUtils.replaceAll(builder, FILESIZE, &quot;0&quot;);</span>
    }
<span class="fc" id="L318">    final DbTaskRunner runner = session.getRunner();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc" id="L320">      WaarpStringUtils</span>
<span class="fc" id="L321">          .replaceAll(builder, ORIGINALFULLPATH, runner.getOriginalFilename());</span>
<span class="fc" id="L322">      WaarpStringUtils.replaceAll(builder, ORIGINALFILENAME, R66File</span>
<span class="fc" id="L323">          .getBasename(runner.getOriginalFilename()));</span>
<span class="fc" id="L324">      WaarpStringUtils.replaceAll(builder, RULE, runner.getRuleId());</span>
    }
<span class="fc" id="L326">    DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span>
<span class="fc" id="L327">    final Date date = new Date();</span>
<span class="fc" id="L328">    WaarpStringUtils.replaceAll(builder, DATE, dateFormat.format(date));</span>
<span class="fc" id="L329">    dateFormat = new SimpleDateFormat(&quot;HHmmss&quot;);</span>
<span class="fc" id="L330">    WaarpStringUtils.replaceAll(builder, HOUR, dateFormat.format(date));</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    if (session.getAuth() != null) {</span>
<span class="fc" id="L332">      WaarpStringUtils</span>
<span class="fc" id="L333">          .replaceAll(builder, REMOTEHOST, session.getAuth().getUser());</span>
      try {
<span class="fc" id="L335">        WaarpStringUtils.replaceAll(builder, LOCALHOST,</span>
                                    Configuration.configuration
<span class="fc" id="L337">                                        .getHostId(session.getAuth().isSsl()));</span>
<span class="nc" id="L338">      } catch (final OpenR66ProtocolNoSslException e) {</span>
        // replace by standard name
<span class="nc" id="L340">        WaarpStringUtils.replaceAll(builder, LOCALHOST,</span>
<span class="nc" id="L341">                                    Configuration.configuration.getHostId());</span>
<span class="fc" id="L342">      }</span>
    }
<span class="fc bfc" id="L344" title="All 2 branches covered.">    if (session.getRemoteAddress() != null) {</span>
<span class="fc" id="L345">      WaarpStringUtils.replaceAll(builder, REMOTEHOSTADDR,</span>
<span class="fc" id="L346">                                  session.getRemoteAddress().toString());</span>
<span class="fc" id="L347">      WaarpStringUtils.replaceAll(builder, LOCALHOSTADDR,</span>
<span class="fc" id="L348">                                  session.getLocalAddress().toString());</span>
    } else {
<span class="fc" id="L350">      WaarpStringUtils.replaceAll(builder, REMOTEHOSTADDR, &quot;unknown&quot;);</span>
<span class="fc" id="L351">      WaarpStringUtils.replaceAll(builder, LOCALHOSTADDR, &quot;unknown&quot;);</span>
    }
<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc" id="L354">      WaarpStringUtils.replaceAll(builder, TRANSFERID,</span>
<span class="fc" id="L355">                                  Long.toString(runner.getSpecialId()));</span>
<span class="fc" id="L356">      final String requester = runner.getRequester();</span>
<span class="fc" id="L357">      WaarpStringUtils.replaceAll(builder, REQUESTERHOST, requester);</span>
<span class="fc" id="L358">      final String requested = runner.getRequested();</span>
<span class="fc" id="L359">      WaarpStringUtils.replaceAll(builder, REQUESTEDHOST, requested);</span>
<span class="fc" id="L360">      WaarpStringUtils.replaceAll(builder, FULLTRANSFERID,</span>
<span class="fc" id="L361">                                  runner.getSpecialId() + &quot;_&quot; + requester +</span>
                                  '_' + requested);
<span class="fc" id="L363">      WaarpStringUtils.replaceAll(builder, RANKTRANSFER,</span>
<span class="fc" id="L364">                                  Integer.toString(runner.getRank()));</span>
    }
<span class="fc" id="L366">    WaarpStringUtils.replaceAll(builder, BLOCKSIZE,</span>
<span class="fc" id="L367">                                Integer.toString(session.getBlockSize()));</span>
<span class="fc" id="L368">    R66Dir dir = new R66Dir(session);</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc bfc" id="L370" title="All 4 branches covered.">      if (runner.isRecvThrough() || runner.isSendThrough()) {</span>
        try {
<span class="fc" id="L372">          dir.changeDirectoryNotChecked(runner.getRule().getRecvPath());</span>
<span class="fc" id="L373">          WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L374">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L379">          dir.changeDirectoryNotChecked(runner.getRule().getSendPath());</span>
<span class="fc" id="L380">          WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L381">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L383">        }</span>
<span class="fc" id="L384">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L386">          dir.changeDirectoryNotChecked(runner.getRule().getWorkPath());</span>
<span class="fc" id="L387">          WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L388">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L390">        }</span>
<span class="fc" id="L391">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L393">          dir.changeDirectoryNotChecked(runner.getRule().getArchivePath());</span>
<span class="fc" id="L394">          WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L395">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="pc" id="L397">        }</span>
      } else {
        try {
<span class="fc" id="L400">          dir.changeDirectory(runner.getRule().getRecvPath());</span>
<span class="fc" id="L401">          WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L402">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L404">        }</span>
<span class="fc" id="L405">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L407">          dir.changeDirectory(runner.getRule().getSendPath());</span>
<span class="fc" id="L408">          WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L409">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L411">        }</span>
<span class="fc" id="L412">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L414">          dir.changeDirectory(runner.getRule().getWorkPath());</span>
<span class="fc" id="L415">          WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L416">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L418">        }</span>
<span class="fc" id="L419">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L421">          dir.changeDirectory(runner.getRule().getArchivePath());</span>
<span class="fc" id="L422">          WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L423">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="pc" id="L425">        }</span>
      }
    } else {
      try {
<span class="fc" id="L429">        dir.changeDirectory(Configuration.configuration.getInPath());</span>
<span class="fc" id="L430">        WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L431">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L433">      }</span>
<span class="fc" id="L434">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L436">        dir.changeDirectory(Configuration.configuration.getOutPath());</span>
<span class="fc" id="L437">        WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L438">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L440">      }</span>
<span class="fc" id="L441">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L443">        dir.changeDirectory(Configuration.configuration.getWorkingPath());</span>
<span class="fc" id="L444">        WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L445">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L447">      }</span>
<span class="fc" id="L448">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L450">        dir.changeDirectory(Configuration.configuration.getArchivePath());</span>
<span class="fc" id="L451">        WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L452">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L454">      }</span>
    }
<span class="fc" id="L456">    WaarpStringUtils.replaceAll(builder, HOMEPATH,</span>
<span class="fc" id="L457">                                Configuration.configuration.getBaseDirectory());</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">    if (session.getLocalChannelReference() == null) {</span>
<span class="fc" id="L459">      WaarpStringUtils.replaceAll(builder, ERRORMSG, &quot;NoError&quot;);</span>
<span class="fc" id="L460">      WaarpStringUtils.replaceAll(builder, ERRORCODE, &quot;-&quot;);</span>
<span class="fc" id="L461">      WaarpStringUtils</span>
<span class="fc" id="L462">          .replaceAll(builder, ERRORSTRCODE, ErrorCode.Unknown.name());</span>
    } else {
      try {
<span class="fc" id="L465">        WaarpStringUtils.replaceAll(builder, ERRORMSG,</span>
<span class="fc" id="L466">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L467">                                           .getErrorMessage());</span>
<span class="nc" id="L468">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L469">        WaarpStringUtils.replaceAll(builder, ERRORMSG, &quot;NoError&quot;);</span>
<span class="fc" id="L470">      }</span>
      try {
<span class="fc" id="L472">        WaarpStringUtils.replaceAll(builder, ERRORCODE,</span>
<span class="fc" id="L473">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L474">                                           .getCurrentCode().getCode());</span>
<span class="nc" id="L475">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L476">        WaarpStringUtils.replaceAll(builder, ERRORCODE, &quot;-&quot;);</span>
<span class="fc" id="L477">      }</span>
      try {
<span class="fc" id="L479">        WaarpStringUtils.replaceAll(builder, ERRORSTRCODE,</span>
<span class="fc" id="L480">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L481">                                           .getCurrentCode().name());</span>
<span class="nc" id="L482">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L483">        WaarpStringUtils</span>
<span class="nc" id="L484">            .replaceAll(builder, ERRORSTRCODE, ErrorCode.Unknown.name());</span>
<span class="fc" id="L485">      }</span>
    }
    // finalname
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">    if (argFormat != null &amp;&amp; argFormat.length &gt; 0) {</span>
      try {
<span class="fc" id="L490">        return String.format(builder.toString(), argFormat);</span>
<span class="nc" id="L491">      } catch (final Exception e) {</span>
        // ignored error since bad argument in static rule info
<span class="nc" id="L493">        logger.error(&quot;Bad format in Rule: {&quot; + builder + &quot;} &quot; + e.getMessage());</span>
      }
    }
<span class="nc" id="L496">    return builder.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>