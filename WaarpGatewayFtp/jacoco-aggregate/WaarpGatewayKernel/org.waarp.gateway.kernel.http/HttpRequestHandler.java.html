<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HttpRequestHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpGatewayKernel</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.kernel.http</a> &gt; <span class="el_source">HttpRequestHandler.java</span></div><h1>HttpRequestHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.gateway.kernel.http;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.codec.http.QueryStringDecoder;
import io.netty.handler.codec.http.cookie.Cookie;
import io.netty.handler.codec.http.cookie.ServerCookieDecoder;
import io.netty.handler.codec.http.cookie.ServerCookieEncoder;
import io.netty.handler.codec.http.multipart.Attribute;
import io.netty.handler.codec.http.multipart.FileUpload;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
import io.netty.handler.codec.http.multipart.InterfaceHttpData;
import io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.database.DbSession;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.gateway.kernel.AbstractHttpBusinessRequest;
import org.waarp.gateway.kernel.AbstractHttpField;
import org.waarp.gateway.kernel.AbstractHttpField.FieldPosition;
import org.waarp.gateway.kernel.AbstractHttpField.FieldRole;
import org.waarp.gateway.kernel.HttpBusinessFactory;
import org.waarp.gateway.kernel.HttpPage;
import org.waarp.gateway.kernel.HttpPage.PageRole;
import org.waarp.gateway.kernel.HttpPageHandler;
import org.waarp.gateway.kernel.database.DbConstantGateway;
import org.waarp.gateway.kernel.database.WaarpActionLogger;
import org.waarp.gateway.kernel.exception.HttpIncorrectRequestException;
import org.waarp.gateway.kernel.session.DefaultHttpAuth;
import org.waarp.gateway.kernel.session.HttpSession;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.security.SecureRandom;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 */
public abstract class HttpRequestHandler
    extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
  /**
   * Internal Logger
   */
<span class="fc" id="L90">  private static final WaarpLogger logger =</span>
<span class="fc" id="L91">      WaarpLoggerFactory.getLogger(HttpRequestHandler.class);</span>

<span class="fc" id="L93">  private static final SecureRandom random = new SecureRandom();</span>

  protected final String baseStaticPath;
  protected final String cookieSession;
  protected final HttpPageHandler httpPageHandler;

  /**
   * @param baseStaticPath
   * @param cookieSession
   * @param httpPageHandler
   */
  protected HttpRequestHandler(final String baseStaticPath,
                               final String cookieSession,
<span class="fc" id="L106">                               final HttpPageHandler httpPageHandler) {</span>
<span class="fc" id="L107">    this.baseStaticPath = baseStaticPath;</span>
<span class="fc" id="L108">    this.cookieSession = cookieSession;</span>
<span class="fc" id="L109">    this.httpPageHandler = httpPageHandler;</span>
<span class="fc" id="L110">  }</span>

  protected HttpSession session;
  protected HttpPostRequestDecoder decoder;
  protected HttpPage httpPage;
  protected AbstractHttpBusinessRequest businessRequest;

<span class="fc" id="L117">  protected HttpResponseStatus status = HttpResponseStatus.OK;</span>
  protected String errorMesg;

  protected HttpRequest request;
  protected HttpMethod method;

  protected volatile boolean willClose;

  /**
   * Clean method
   * &lt;p&gt;
   * Override if needed
   */
  protected void clean() {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">    if (businessRequest != null) {</span>
<span class="nc" id="L132">      businessRequest.cleanRequest();</span>
<span class="nc" id="L133">      businessRequest = null;</span>
    }
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (decoder != null) {</span>
<span class="fc" id="L136">      decoder.cleanFiles();</span>
<span class="fc" id="L137">      decoder = null;</span>
    }
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (session != null) {</span>
<span class="fc" id="L140">      session.setFilename(null);</span>
<span class="fc" id="L141">      session.setLogid(DbConstantGateway.ILLEGALVALUE);</span>
    }
<span class="fc" id="L143">  }</span>

  /**
   * Called at the beginning of every new request
   * &lt;p&gt;
   * Override if needed
   */
  protected void initialize() {
    // clean previous FileUpload if Any
<span class="fc" id="L152">    clean();</span>
<span class="fc" id="L153">    willClose = false;</span>
<span class="fc" id="L154">    status = HttpResponseStatus.OK;</span>
<span class="fc" id="L155">    httpPage = null;</span>
<span class="fc" id="L156">    businessRequest = null;</span>
<span class="fc" id="L157">  }</span>

  /**
   * set values from URI
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getUriArgs() throws HttpIncorrectRequestException {
<span class="fc" id="L165">    final QueryStringDecoder decoderQuery =</span>
<span class="fc" id="L166">        new QueryStringDecoder(request.uri());</span>
<span class="fc" id="L167">    final Map&lt;String, List&lt;String&gt;&gt; uriAttributes = decoderQuery.parameters();</span>
<span class="fc" id="L168">    final Set&lt;String&gt; attributes = uriAttributes.keySet();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">    for (final String name : attributes) {</span>
<span class="nc" id="L170">      final List&lt;String&gt; values = uriAttributes.get(name);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (values != null) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="nc" id="L174">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.URL);
<span class="nc bnc" id="L176" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
<span class="nc" id="L178">          values.clear();</span>
<span class="nc" id="L179">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
<span class="nc" id="L182">        values.clear();</span>
      }
<span class="nc" id="L184">    }</span>
<span class="fc" id="L185">  }</span>

  /**
   * set values from Header
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getHeaderArgs() throws HttpIncorrectRequestException {
<span class="fc" id="L193">    final Set&lt;String&gt; headerNames = request.headers().names();</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">    for (final String name : headerNames) {</span>
<span class="fc" id="L195">      final List&lt;String&gt; values = request.headers().getAll((CharSequence) name);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">      if (values != null) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="fc" id="L199">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.HEADER);
<span class="nc bnc" id="L201" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
          try {
<span class="nc" id="L204">            values.clear();</span>
<span class="nc" id="L205">          } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L206">            SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L207">          }</span>
<span class="nc" id="L208">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
        try {
<span class="nc" id="L212">          values.clear();</span>
<span class="fc" id="L213">        } catch (final UnsupportedOperationException e) {</span>
<span class="fc" id="L214">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L215">        }</span>
      }
<span class="fc" id="L217">    }</span>
<span class="fc" id="L218">  }</span>

  /**
   * set values from Cookies
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getCookieArgs() throws HttpIncorrectRequestException {
    final Set&lt;Cookie&gt; cookies;
<span class="fc" id="L227">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L229">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L231">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    if (!cookies.isEmpty()) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L236">          httpPage.setValue(businessRequest, cookie.name(), cookie.value(),</span>
                            FieldPosition.COOKIE);
        }
<span class="nc" id="L239">      }</span>
    }
<span class="fc" id="L241">    cookies.clear();</span>
<span class="fc" id="L242">  }</span>

  /**
   * To be used for instance to check correctness of connection
   *
   * @param ctx
   */
  protected abstract void checkConnection(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Called when an error is raised. Note that clean() will be called just
   * after.
   *
   * @param ctx
   */
  protected abstract void error(ChannelHandlerContext ctx);

  @Override
  protected void channelRead0(final ChannelHandlerContext ctx,
                              final HttpObject msg) {
    try {
<span class="fc bfc" id="L264" title="All 2 branches covered.">      if (msg instanceof HttpRequest) {</span>
<span class="fc" id="L265">        initialize();</span>
<span class="fc" id="L266">        request = (HttpRequest) msg;</span>
<span class="fc" id="L267">        method = request.method();</span>
<span class="fc" id="L268">        final QueryStringDecoder queryStringDecoder =</span>
<span class="fc" id="L269">            new QueryStringDecoder(request.uri());</span>
<span class="fc" id="L270">        final String uriRequest = queryStringDecoder.path();</span>
        final HttpPage httpPageTemp;
        try {
<span class="fc" id="L273">          httpPageTemp =</span>
<span class="fc" id="L274">              httpPageHandler.getHttpPage(uriRequest, method.name(), session);</span>
<span class="fc" id="L275">        } catch (final HttpIncorrectRequestException e1) {</span>
          // real error =&gt; 400
<span class="fc" id="L277">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="fc" id="L278">          errorMesg = e1.getMessage();</span>
<span class="fc" id="L279">          writeErrorPage(ctx);</span>
<span class="fc" id="L280">          return;</span>
          // end of task
<span class="fc" id="L282">        }</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (httpPageTemp == null) {</span>
          // if Get =&gt; standard Get
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">          if (method == HttpMethod.GET) {</span>
<span class="fc" id="L286">            logger.debug(&quot;simple get: {}&quot;, request.uri());</span>
            // send content (image for instance)
<span class="fc" id="L288">            HttpWriteCacheEnable</span>
<span class="fc" id="L289">                .writeFile(request, ctx, baseStaticPath + uriRequest,</span>
                           cookieSession);
            // end of task
          } else {
            // real error =&gt; 404
<span class="nc" id="L294">            status = HttpResponseStatus.NOT_FOUND;</span>
<span class="nc" id="L295">            writeErrorPage(ctx);</span>
          }
<span class="fc" id="L297">          return;</span>
        }
<span class="fc" id="L299">        httpPage = httpPageTemp;</span>
<span class="fc" id="L300">        session.setCurrentCommand(httpPage.getPagerole());</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        final DbSession dbSession = DbConstantGateway.admin != null?</span>
<span class="pc" id="L302">            DbConstantGateway.admin.getSession() : null;</span>
<span class="fc" id="L303">        WaarpActionLogger</span>
<span class="fc" id="L304">            .logCreate(dbSession, &quot;Request received: &quot; + httpPage.getPagename(),</span>
                       session);
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (httpPageTemp.getPagerole() == PageRole.ERROR) {</span>
<span class="nc" id="L307">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L308">          error(ctx);</span>
<span class="nc" id="L309">          clean();</span>
          // order is important: first clean, then create new businessRequest
<span class="nc" id="L311">          businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="nc" id="L312">          willClose = true;</span>
<span class="nc" id="L313">          writeSimplePage(ctx);</span>
<span class="nc" id="L314">          WaarpActionLogger</span>
<span class="nc" id="L315">              .logErrorAction(DbConstantGateway.admin.getSession(), session,</span>
<span class="nc" id="L316">                              &quot;Error: &quot; + httpPage.getPagename(), status);</span>
<span class="nc" id="L317">          return;</span>
          // end of task
        }
<span class="fc" id="L320">        businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="fc" id="L321">        getUriArgs();</span>
<span class="fc" id="L322">        getHeaderArgs();</span>
<span class="fc" id="L323">        getCookieArgs();</span>
<span class="fc" id="L324">        checkConnection(ctx);</span>
<span class="pc bpc" id="L325" title="1 of 5 branches missed.">        switch (httpPage.getPagerole()) {</span>
          case DELETE:
            // no body element
<span class="fc" id="L328">            delete(ctx);</span>
<span class="fc" id="L329">            return;</span>
          case GETDOWNLOAD:
            // no body element
<span class="fc" id="L332">            getFile(ctx);</span>
<span class="fc" id="L333">            return;</span>
          case HTML:
          case MENU:
            // no body element
<span class="fc" id="L337">            beforeSimplePage(ctx);</span>
<span class="fc" id="L338">            writeSimplePage(ctx);</span>
<span class="fc" id="L339">            return;</span>
          case POST:
          case POSTUPLOAD:
          case PUT:
<span class="fc" id="L343">            post(ctx);</span>
<span class="fc" id="L344">            return;</span>
          default:
            // real error =&gt; 400
<span class="nc" id="L347">            status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L348">            writeErrorPage(ctx);</span>
        }
<span class="nc" id="L350">      } else {</span>
        // New chunk is received: only for Put, Post or PostMulti!
<span class="fc" id="L352">        postChunk(ctx, (HttpContent) msg);</span>
      }
<span class="fc" id="L354">    } catch (final HttpIncorrectRequestException e1) {</span>
      // real error =&gt; 400
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L357">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="fc" id="L359">      errorMesg = e1.getMessage();</span>
<span class="fc" id="L360">      logger.warn(&quot;Error&quot;, e1);</span>
<span class="fc" id="L361">      writeErrorPage(ctx);</span>
<span class="fc" id="L362">    }</span>
<span class="fc" id="L363">  }</span>

  /**
   * Utility to prepare error
   *
   * @param ctx
   * @param message
   *
   * @throws HttpIncorrectRequestException
   */
  protected void prepareError(final ChannelHandlerContext ctx,
                              final String message)
      throws HttpIncorrectRequestException {
<span class="nc" id="L376">    logger.debug(&quot;Debug {}&quot;, message);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L379">      return;</span>
    }
<span class="nc" id="L381">    errorMesg = status.reasonPhrase() + &quot; / &quot; + message;</span>
<span class="nc" id="L382">    throw new HttpIncorrectRequestException(errorMesg);</span>
  }

  /**
   * Instantiate the page and the businessRequest handler
   *
   * @param ctx
   *
   * @return True if initialized
   */
  protected boolean setErrorPage(final ChannelHandlerContext ctx) {
<span class="fc" id="L393">    httpPage = httpPageHandler.getHttpPage(status.code());</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">    if (httpPage == null) {</span>
<span class="nc" id="L395">      return false;</span>
    }
<span class="fc" id="L397">    businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="fc" id="L398">    return true;</span>
  }

  /**
   * Write an error page
   *
   * @param ctx
   */
  protected void writeErrorPage(final ChannelHandlerContext ctx) {
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    final DbSession dbSession =</span>
<span class="pc" id="L408">        DbConstantGateway.admin != null? DbConstantGateway.admin.getSession() :</span>
            null;
<span class="fc bfc" id="L410" title="All 2 branches covered.">    WaarpActionLogger.logErrorAction(dbSession, session, &quot;Error: &quot; +</span>
                                                         (httpPage == null?
                                                             &quot;no page&quot; :
                                                             httpPage
<span class="fc" id="L414">                                                                 .getPagename()),</span>
                                     status);
<span class="fc" id="L416">    error(ctx);</span>
<span class="fc" id="L417">    clean();</span>
<span class="fc" id="L418">    willClose = true;</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L421">      forceClosing(ctx);</span>
<span class="nc" id="L422">      return;</span>
    }
    try {
<span class="fc" id="L425">      writeSimplePage(ctx);</span>
<span class="nc" id="L426">    } catch (final HttpIncorrectRequestException e) {</span>
      // force channel closing
<span class="nc" id="L428">      forceClosing(ctx);</span>
<span class="fc" id="L429">    }</span>
<span class="fc" id="L430">  }</span>

  /**
   * To allow quick answer even if in very bad shape
   *
   * @param ctx
   */
  protected void forceClosing(final ChannelHandlerContext ctx) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">    if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L439">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
    }
<span class="nc bnc" id="L441" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc" id="L442">      willClose = true;</span>
<span class="nc" id="L443">      final String answer =</span>
<span class="nc" id="L444">          &quot;&lt;html&gt;&lt;body&gt;Error &quot; + status.reasonPhrase() + &quot;&lt;/body&gt;&lt;/html&gt;&quot;;</span>
<span class="nc" id="L445">      final FullHttpResponse response = getResponse(</span>
<span class="nc" id="L446">          Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8)));</span>
<span class="nc" id="L447">      response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
<span class="nc" id="L448">      response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="nc" id="L449">      final ChannelFuture future = ctx.writeAndFlush(response);</span>
<span class="nc" id="L450">      logger.debug(&quot;Will close&quot;);</span>
<span class="nc" id="L451">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="nc" id="L453">    WaarpActionLogger</span>
<span class="nc" id="L454">        .logErrorAction(DbConstantGateway.admin.getSession(), session,</span>
<span class="nc" id="L455">                        &quot;Error: &quot; + httpPage.getPagename(), status);</span>
<span class="nc" id="L456">  }</span>

  /**
   * Write a simple page from current httpPage and businessRequest
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void writeSimplePage(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc bfc" id="L467" title="All 2 branches covered.">    logger.debug(&quot;HttpPage: {} businessRequest: {}&quot;,</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                 httpPage != null? httpPage.getPagename() : &quot;no page&quot;,</span>
<span class="pc" id="L469">                 businessRequest != null? businessRequest.getClass().getName() :</span>
                     &quot;no BR&quot;);
<span class="fc bfc" id="L471" title="All 4 branches covered.">    if (httpPage != null &amp;&amp; httpPage.getPagerole() == PageRole.ERROR) {</span>
      try {
<span class="fc" id="L473">        httpPage</span>
<span class="fc" id="L474">            .setValue(businessRequest, AbstractHttpField.ERRORINFO, errorMesg,</span>
                      FieldPosition.BODY);
<span class="nc" id="L476">      } catch (final HttpIncorrectRequestException e) {</span>
        // ignore
<span class="fc" id="L478">      }</span>
    }
<span class="fc bfc" id="L480" title="All 2 branches covered.">    final String answer =</span>
<span class="fc" id="L481">        httpPage != null? httpPage.getHtmlPage(businessRequest) : &quot;BAD REQUEST&quot;;</span>
    final int length;
    // Convert the response content to a ByteBuf.
<span class="fc" id="L484">    final ByteBuf buf =</span>
<span class="fc" id="L485">        Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8));</span>
<span class="fc" id="L486">    final FullHttpResponse response = getResponse(buf);</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">    if (businessRequest == null) {</span>
<span class="fc" id="L488">      response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
    } else {
<span class="nc" id="L490">      response.headers().set(HttpHeaderNames.CONTENT_TYPE,</span>
<span class="nc" id="L491">                             businessRequest.getContentType());</span>
    }
<span class="fc" id="L493">    response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="fc" id="L494">    length = buf.readableBytes();</span>
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">    if (!willClose) {</span>
      // There's no need to add 'Content-Length' header
      // if this is the last response.
<span class="nc" id="L498">      response.headers()</span>
<span class="nc" id="L499">              .set(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(length));</span>
    }
    // Write the response.
<span class="fc" id="L502">    final ChannelFuture future = ctx.writeAndFlush(response);</span>
    // Close the connection after the write operation is done if necessary.
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">    if (willClose) {</span>
<span class="fc" id="L505">      logger.debug(&quot;Will close&quot;);</span>
<span class="fc" id="L506">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="fc" id="L508">  }</span>

  /**
   * Could be used for other method (as validation of an authent cookie)
   *
   * @param cookie
   *
   * @return True if this cookie is valid
   */
  protected abstract boolean isCookieValid(Cookie cookie);

  /**
   * Method to add specific Cookies from business definition
   * &lt;p&gt;
   * Override if needed
   *
   * @param response
   * @param cookieNames
   */
  protected void addBusinessCookie(final FullHttpResponse response,
                                   final Set&lt;String&gt; cookieNames) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">    if (httpPage != null) {</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">      for (final AbstractHttpField field : httpPage</span>
<span class="fc" id="L531">          .getFieldsForRequest(businessRequest).values()) {</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (field.isFieldcookieset() &amp;&amp;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            !cookieNames.contains(field.getFieldname())) {</span>
<span class="nc" id="L534">          response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
                                 ServerCookieEncoder.LAX
<span class="nc" id="L536">                                     .encode(field.getFieldname(),</span>
                                             field.fieldvalue));
        }
<span class="nc" id="L539">      }</span>
    }
<span class="fc" id="L541">  }</span>

  /**
   * Method to set Cookies in response
   *
   * @param response
   */
  protected void setCookieEncoder(final FullHttpResponse response) {
    final Set&lt;Cookie&gt; cookies;
<span class="fc" id="L550">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L552">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L554">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="fc" id="L556">    boolean foundCookieSession = false;</span>
<span class="fc" id="L557">    final Set&lt;String&gt; cookiesName = new HashSet&lt;String&gt;();</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">    if (!cookies.isEmpty()) {</span>
      // Reset the cookies if necessary.
<span class="nc bnc" id="L560" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L562">          response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="nc" id="L563">                                 ServerCookieEncoder.LAX.encode(cookie));</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">          if (cookie.name().equals(cookieSession)) {</span>
<span class="nc" id="L565">            foundCookieSession = true;</span>
          }
<span class="nc" id="L567">          cookiesName.add(cookie.name());</span>
        }
<span class="nc" id="L569">      }</span>
    }
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">    if (!foundCookieSession) {</span>
<span class="fc" id="L572">      response.headers().add(HttpHeaderNames.SET_COOKIE, ServerCookieEncoder.LAX</span>
<span class="fc" id="L573">          .encode(cookieSession, session.getCookieSession()));</span>
<span class="fc" id="L574">      cookiesName.add(cookieSession);</span>
    }
<span class="fc" id="L576">    addBusinessCookie(response, cookiesName);</span>
<span class="fc" id="L577">    cookiesName.clear();</span>
<span class="fc" id="L578">  }</span>

  /**
   * @param buf might be null
   *
   * @return the Http Response according to the status
   */
  protected FullHttpResponse getResponse(final ByteBuf buf) {
    // Decide whether to close the connection or not.
    final FullHttpResponse response;
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">    if (request == null) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">      if (buf != null) {</span>
<span class="nc" id="L590">        response =</span>
            new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status, buf);
<span class="nc" id="L592">        response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="nc" id="L593">                               response.content().readableBytes());</span>
      } else {
<span class="nc" id="L595">        response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status);</span>
      }
<span class="nc" id="L597">      setCookieEncoder(response);</span>
<span class="nc" id="L598">      willClose = true;</span>
<span class="nc" id="L599">      return response;</span>
    }
<span class="fc" id="L601">    boolean keepAlive = HttpUtil.isKeepAlive(request);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">    willClose |= status != HttpResponseStatus.OK || HttpHeaderValues.CLOSE</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        .contentEqualsIgnoreCase(</span>
<span class="fc" id="L604">            request.headers().get(HttpHeaderNames.CONNECTION)) ||</span>
<span class="pc bnc" id="L605" title="All 4 branches missed.">                 request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp;</span>
                 !keepAlive;
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">    if (willClose) {</span>
<span class="fc" id="L608">      keepAlive = false;</span>
    }
    // Build the response object.
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">    if (buf != null) {</span>
<span class="fc" id="L612">      response =</span>
<span class="fc" id="L613">          new DefaultFullHttpResponse(request.protocolVersion(), status, buf);</span>
<span class="fc" id="L614">      response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="fc" id="L615">                             response.content().readableBytes());</span>
    } else {
<span class="nc" id="L617">      response = new DefaultFullHttpResponse(request.protocolVersion(), status);</span>
    }
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">    if (keepAlive) {</span>
<span class="nc" id="L620">      response.headers()</span>
<span class="nc" id="L621">              .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span>
    }
<span class="fc" id="L623">    setCookieEncoder(response);</span>
<span class="fc" id="L624">    return response;</span>
  }

  /**
   * @return the filename used for this request
   */
  protected abstract String getFilename();

  /**
   * Called before simple Page is called (Menu or HTML)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected abstract void beforeSimplePage(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the result and send back the result
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void finalData(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="fc" id="L652">      businessValidRequestAfterAllDataReceived(ctx);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">      if (httpPage == null) {</span>
        // Cached
<span class="fc" id="L655">        return;</span>
      }
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">      if (!httpPage.isRequestValid(businessRequest)) {</span>
<span class="nc" id="L658">        throw new HttpIncorrectRequestException(&quot;Request unvalid&quot;);</span>
      }
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">      final DbSession dbSession = DbConstantGateway.admin != null?</span>
<span class="pc" id="L661">          DbConstantGateway.admin.getSession() : null;</span>
<span class="pc bpc" id="L662" title="1 of 6 branches missed.">      switch (httpPage.getPagerole()) {</span>
        case DELETE:
<span class="fc" id="L664">          session.setFilename(getFilename());</span>
<span class="fc" id="L665">          finalDelete(ctx);</span>
<span class="fc" id="L666">          WaarpActionLogger.logAction(dbSession, session, &quot;Delete OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L668">          break;</span>
        case GETDOWNLOAD:
<span class="fc" id="L670">          finalGet(ctx);</span>
<span class="fc" id="L671">          WaarpActionLogger.logAction(dbSession, session, &quot;Download OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L673">          break;</span>
        case POST:
<span class="fc" id="L675">          finalPost(ctx);</span>
<span class="fc" id="L676">          WaarpActionLogger.logAction(dbSession, session, &quot;Post OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L678">          break;</span>
        case POSTUPLOAD:
<span class="nc" id="L680">          finalPostUpload(ctx);</span>
<span class="nc" id="L681">          WaarpActionLogger</span>
<span class="nc" id="L682">              .logAction(dbSession, session, &quot;PostUpload OK&quot;, status,</span>
                         UpdatedInfo.DONE);
<span class="nc" id="L684">          break;</span>
        case PUT:
<span class="fc" id="L686">          finalPut(ctx);</span>
<span class="fc" id="L687">          WaarpActionLogger.logAction(dbSession, session, &quot;Put OK&quot;, status,</span>
                                      UpdatedInfo.DONE);
<span class="fc" id="L689">          break;</span>
        default:
          // real error =&gt; 400
<span class="fc" id="L692">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="fc" id="L693">          throw new HttpIncorrectRequestException(&quot;Unknown request&quot;);</span>
      }
<span class="fc" id="L695">    } catch (final HttpIncorrectRequestException e) {</span>
      // real error =&gt; 400
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L698">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="fc" id="L700">      throw e;</span>
<span class="fc" id="L701">    }</span>
<span class="fc" id="L702">  }</span>

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalDelete(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and send back the result &lt;br&gt;
   * (this method must send back the answer using for instance a ChunkedInput
   * handler and should try to call
   * clean(), but taking into consideration that it will erase all data, so it
   * must be ensured that all data are
   * sent through the wire before calling it. Note however that when the
   * connection is closed or when a new
   * request on the same connection occurs, the clean method is automatically
   * called. The usage of a
   * HttpCleanChannelFutureListener on the last write might be useful.)
   *
   * @param ctx
   */
  protected abstract void finalGet(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPostUpload(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the post result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPost(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the put result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPut(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Validate all data as they should be all received (done before the
   * isRequestValid)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  public abstract void businessValidRequestAfterAllDataReceived(
      ChannelHandlerContext ctx) throws HttpIncorrectRequestException;

  /**
   * Method that get &quot;get&quot; data, answer has to be written in the business part
   * finalGet
   *
   * @param ctx
   */
  protected void getFile(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc" id="L772">    finalData(ctx);</span>
<span class="fc" id="L773">  }</span>

  /**
   * Method that get delete data
   *
   * @param ctx
   */
  protected void delete(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="fc" id="L782">    finalData(ctx);</span>
<span class="fc" id="L783">    writeSimplePage(ctx);</span>
<span class="fc" id="L784">    clean();</span>
<span class="fc" id="L785">  }</span>

  /**
   * Method that get post data
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void post(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="fc" id="L797">      decoder =</span>
          new HttpPostRequestDecoder(HttpBusinessFactory.factory, request);
<span class="nc" id="L799">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L800">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L801">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L802">    } catch (final Exception e1) {</span>
      // GETDOWNLOAD Method: should not try to create a HttpPostRequestDecoder
      // So OK but stop here
<span class="nc" id="L805">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L806">      throw new HttpIncorrectRequestException(e1);</span>
<span class="fc" id="L807">    }</span>

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">    if (request instanceof FullHttpRequest) {</span>
      // Not chunk version
<span class="nc" id="L811">      readHttpDataAllReceive(ctx);</span>
<span class="nc" id="L812">      finalData(ctx);</span>
<span class="nc" id="L813">      writeSimplePage(ctx);</span>
<span class="nc" id="L814">      clean();</span>
    }
<span class="fc" id="L816">  }</span>

  /**
   * Method that get a chunk of data
   *
   * @param ctx
   * @param chunk
   *
   * @throws HttpIncorrectRequestException
   */
  protected void postChunk(final ChannelHandlerContext ctx,
                           final HttpContent chunk)
      throws HttpIncorrectRequestException {
    // New chunk is received: only for Post!
<span class="fc bfc" id="L830" title="All 2 branches covered.">    if (decoder == null) {</span>
<span class="fc" id="L831">      finalData(ctx);</span>
<span class="fc" id="L832">      writeSimplePage(ctx);</span>
<span class="fc" id="L833">      clean();</span>
<span class="fc" id="L834">      return;</span>
    }
    try {
<span class="fc" id="L837">      decoder.offer(chunk);</span>
<span class="nc" id="L838">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L839">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L840">      throw new HttpIncorrectRequestException(e1);</span>
<span class="fc" id="L841">    }</span>
    // example of reading chunk by chunk (minimize memory usage due to
    // Factory)
<span class="fc" id="L844">    readHttpDataChunkByChunk(ctx);</span>
    // example of reading only if at the end
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">    if (chunk instanceof LastHttpContent) {</span>
<span class="fc" id="L847">      finalData(ctx);</span>
<span class="fc" id="L848">      writeSimplePage(ctx);</span>
<span class="fc" id="L849">      clean();</span>
    }
<span class="fc" id="L851">  }</span>

  @Override
  public void exceptionCaught(final ChannelHandlerContext ctx,
                              final Throwable cause) {
<span class="nc bnc" id="L856" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L857" title="All 4 branches missed.">      if (cause != null &amp;&amp; cause.getMessage() != null) {</span>
<span class="nc" id="L858">        logger.warn(&quot;Exception {}&quot;, cause.getMessage(), cause);</span>
      } else {
<span class="nc" id="L860">        logger.warn(&quot;Exception Received&quot;, cause);</span>
      }
<span class="nc bnc" id="L862" title="All 2 branches missed.">      if (cause instanceof ClosedChannelException) {</span>
<span class="nc" id="L863">        return;</span>
      }
<span class="nc" id="L865">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L866">      writeErrorPage(ctx);</span>
    }
<span class="nc" id="L868">  }</span>

  @Override
  public void channelInactive(final ChannelHandlerContext ctx)
      throws Exception {
<span class="fc" id="L873">    super.channelInactive(ctx);</span>
<span class="fc" id="L874">    clean();</span>
<span class="fc" id="L875">  }</span>

  /**
   * Read all InterfaceHttpData from finished transfer
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpDataAllReceive(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    final List&lt;InterfaceHttpData&gt; datas;
    try {
<span class="nc" id="L888">      datas = decoder.getBodyHttpDatas();</span>
<span class="nc" id="L889">    } catch (final NotEnoughDataDecoderException e1) {</span>
      // Should not be!
<span class="nc" id="L891">      logger.warn(&quot;decoder issue&quot;, e1);</span>
<span class="nc" id="L892">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L893">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L894">    }</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">    for (final InterfaceHttpData data : datas) {</span>
<span class="nc" id="L896">      readHttpData(data, ctx);</span>
<span class="nc" id="L897">    }</span>
<span class="nc" id="L898">  }</span>

  /**
   * Read request by chunk and getting values from chunk to chunk
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpDataChunkByChunk(final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">      while (decoder.hasNext()) {</span>
<span class="nc" id="L911">        final InterfaceHttpData data = decoder.next();</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (data != null) {</span>
          // new value
<span class="nc" id="L914">          readHttpData(data, ctx);</span>
        }
<span class="nc" id="L916">      }</span>
<span class="nc" id="L917">    } catch (final EndOfDataDecoderException e1) {</span>
      // end
<span class="fc" id="L919">    }</span>
<span class="fc" id="L920">  }</span>

  /**
   * Read one Data
   *
   * @param data
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpData(final InterfaceHttpData data,
                              final ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc bnc" id="L933" title="All 2 branches missed.">    if (data.getHttpDataType() == HttpDataType.Attribute) {</span>
<span class="nc" id="L934">      final Attribute attribute = (Attribute) data;</span>
<span class="nc" id="L935">      final String name = attribute.getName();</span>
      try {
<span class="nc" id="L937">        final String value = attribute.getValue();</span>
<span class="nc" id="L938">        httpPage.setValue(businessRequest, name, value, FieldPosition.BODY);</span>
<span class="nc" id="L939">      } catch (final IOException e) {</span>
        // Error while reading data from File, only print name and
        // error
<span class="nc" id="L942">        attribute.delete();</span>
<span class="nc" id="L943">        status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L944">        throw new HttpIncorrectRequestException(e);</span>
<span class="nc" id="L945">      }</span>
<span class="nc" id="L946">      attribute.delete();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">    } else if (data.getHttpDataType() == HttpDataType.FileUpload) {</span>
<span class="nc" id="L948">      final FileUpload fileUpload = (FileUpload) data;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">      if (fileUpload.isCompleted()) {</span>
<span class="nc" id="L950">        final AbstractHttpField field =</span>
<span class="nc" id="L951">            httpPage.getField(businessRequest, fileUpload.getName());</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (field != null &amp;&amp;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            field.getFieldtype() == FieldRole.BUSINESS_INPUT_FILE) {</span>
<span class="nc" id="L954">          httpPage.setValue(businessRequest, field.getFieldname(), fileUpload);</span>
        } else {
<span class="nc" id="L956">          logger.warn(&quot;File received but no variable for it&quot;);</span>
<span class="nc" id="L957">          fileUpload.delete();</span>
        }
<span class="nc" id="L959">      } else {</span>
<span class="nc" id="L960">        logger.warn(&quot;File still pending but should not&quot;);</span>
<span class="nc" id="L961">        fileUpload.delete();</span>
      }
<span class="nc" id="L963">    } else {</span>
<span class="nc" id="L964">      logger.warn(&quot;Unknown element: &quot; + data);</span>
    }
<span class="nc" id="L966">  }</span>

  /**
   * Default Session Cookie generator
   *
   * @return the new session cookie value
   */
  protected String getNewCookieSession() {
<span class="fc" id="L974">    return &quot;Waarp&quot; + Long.toHexString(random.nextLong());</span>
  }

  /**
   * Default session creation
   *
   * @param ctx
   */
  protected void createNewSessionAtConnection(final ChannelHandlerContext ctx) {
<span class="fc" id="L983">    session = new HttpSession();</span>
<span class="fc" id="L984">    session.setHttpAuth(new DefaultHttpAuth(session));</span>
<span class="fc" id="L985">    session.setCookieSession(getNewCookieSession());</span>
<span class="fc" id="L986">    session.setCurrentCommand(PageRole.HTML);</span>
<span class="fc" id="L987">  }</span>

  @Override
  public void channelActive(final ChannelHandlerContext ctx) throws Exception {
<span class="fc" id="L991">    super.channelActive(ctx);</span>
<span class="fc" id="L992">    createNewSessionAtConnection(ctx);</span>
<span class="fc" id="L993">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>