<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>R66Auth.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.context.authentication</a> &gt; <span class="el_source">R66Auth.java</span></div><h1>R66Auth.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.context.authentication;

import org.waarp.common.command.NextCommandReply;
import org.waarp.common.command.exception.Reply421Exception;
import org.waarp.common.command.exception.Reply530Exception;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.filesystembased.FilesystemBasedAuthImpl;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.protocol.configuration.Configuration;

import java.io.File;

/**
 *
 */
public class R66Auth extends FilesystemBasedAuthImpl {
  /**
   * Internal Logger
   */
<span class="fc" id="L45">  private static final WaarpLogger logger =</span>
<span class="fc" id="L46">      WaarpLoggerFactory.getLogger(R66Auth.class);</span>

  /**
   * Current authentication
   */
  private DbHostAuth currentAuth;
  /**
   * is Admin role
   */
  private boolean isAdmin;
  /**
   * Role set from configuration file only
   */
<span class="fc" id="L59">  private final RoleDefault role = new RoleDefault();</span>

  /**
   * @param session
   */
  public R66Auth(final R66Session session) {
<span class="fc" id="L65">    super(session);</span>
<span class="fc" id="L66">  }</span>

  @Override
  protected void businessClean() {
<span class="fc" id="L70">    currentAuth = null;</span>
<span class="fc" id="L71">    isAdmin = false;</span>
<span class="fc" id="L72">    role.clear();</span>
<span class="fc" id="L73">  }</span>

  @Override
  public String getBaseDirectory() {
<span class="fc" id="L77">    return Configuration.configuration.getBaseDirectory();</span>
  }

  @Override
  protected NextCommandReply setBusinessPassword(final String arg0)
      throws Reply421Exception, Reply530Exception {
<span class="nc" id="L83">    throw new Reply421Exception(&quot;Command not valid&quot;);</span>
  }

  /**
   * @param hostId
   * @param arg0
   *
   * @return True if the connection is OK (authentication is OK)
   *
   * @throws Reply530Exception if the authentication is wrong
   * @throws Reply421Exception If the service is not available
   */
  public boolean connection(final String hostId, final byte[] arg0,
                            final boolean isSsl)
      throws Reply530Exception, Reply421Exception {
    final DbHostAuth auth;
    try {
<span class="fc" id="L100">      auth = new DbHostAuth(hostId);</span>
<span class="nc" id="L101">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L102">      logger.error(&quot;Cannot find authentication for &quot; + hostId);</span>
<span class="nc" id="L103">      setIsIdentified(false);</span>
<span class="nc" id="L104">      currentAuth = null;</span>
<span class="nc" id="L105">      throw new Reply530Exception(&quot;HostId not allowed: &quot; + hostId);</span>
<span class="fc" id="L106">    }</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    if (auth.isSsl() != isSsl) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">      if (auth.isSsl()) {</span>
<span class="nc" id="L109">        logger.error(&quot;Hostid {} must use SSL&quot;, hostId);</span>
      } else {
<span class="nc" id="L111">        logger.error(&quot;Hostid {} cannot use SSL&quot;, hostId);</span>
      }
<span class="nc" id="L113">      setIsIdentified(false);</span>
<span class="nc" id="L114">      currentAuth = null;</span>
<span class="nc" id="L115">      throw new Reply530Exception(&quot;HostId not allowed: mixed Ssl&quot;);</span>
    }
<span class="fc" id="L117">    currentAuth = auth;</span>
<span class="fc" id="L118">    role.clear();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">    if (currentAuth.isKeyValid(arg0)) {</span>
<span class="fc" id="L120">      setIsIdentified(true);</span>
<span class="fc" id="L121">      user = hostId;</span>
<span class="fc" id="L122">      setRootFromAuth();</span>
<span class="fc" id="L123">      getSession().getDir().initAfterIdentification();</span>
<span class="fc" id="L124">      isAdmin = currentAuth.isAdminrole();</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">      if (Configuration.configuration.getRoles().isEmpty()) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (isAdmin) {</span>
<span class="fc" id="L127">          role.setRole(ROLE.FULLADMIN);</span>
        } else {
<span class="fc" id="L129">          role.setRole(ROLE.PARTNER);</span>
        }
      } else {
<span class="fc" id="L132">        final RoleDefault configRole =</span>
<span class="fc" id="L133">            Configuration.configuration.getRoles().get(hostId);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (configRole == null) {</span>
          // set to default PARTNER
<span class="fc" id="L136">          role.setRole(ROLE.PARTNER);</span>
        } else {
<span class="fc" id="L138">          role.setRoleDefault(configRole);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">          if (role.isContaining(ROLE.FULLADMIN)) {</span>
<span class="fc" id="L140">            isAdmin = true;</span>
          }
        }
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (isAdmin) {</span>
<span class="fc" id="L144">          role.setRole(ROLE.FULLADMIN);</span>
        }
      }
<span class="fc" id="L147">      logger.debug(role.toString());</span>
<span class="fc" id="L148">      return true;</span>
    }
<span class="nc" id="L150">    throw new Reply530Exception(&quot;Key is not valid for this HostId&quot;);</span>
  }

  /**
   * @param key
   *
   * @return True if the key is valid for the current user
   */
  public boolean isKeyValid(final byte[] key) {
<span class="nc" id="L159">    return currentAuth.isKeyValid(key);</span>
  }

  /**
   * Set the root relative Path from current status of Authentication (should
   * be
   * the highest level for the
   * current authentication). If setBusinessRootFromAuth returns null, by
   * default set /user.
   *
   * @throws Reply421Exception if the business root is not available
   */
  @Override
  protected void setRootFromAuth() throws Reply421Exception {
<span class="fc" id="L173">    rootFromAuth = setBusinessRootFromAuth();</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if (rootFromAuth == null) {</span>
<span class="fc" id="L175">      rootFromAuth = DirInterface.SEPARATOR;</span>
    }
<span class="fc" id="L177">  }</span>

  @Override
  protected String setBusinessRootFromAuth() throws Reply421Exception {
<span class="fc" id="L181">    final String path = null;</span>
<span class="fc" id="L182">    final String fullpath = getAbsolutePath(null);</span>
<span class="fc" id="L183">    final File file = new File(fullpath);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">    if (!file.isDirectory()) {</span>
<span class="nc" id="L185">      throw new Reply421Exception(&quot;Filesystem not ready&quot;);</span>
    }
<span class="fc" id="L187">    return path;</span>
  }

  @Override
  protected NextCommandReply setBusinessUser(final String arg0)
      throws Reply421Exception, Reply530Exception {
<span class="nc" id="L193">    throw new Reply421Exception(&quot;Command not valid&quot;);</span>
  }

  @Override
  public boolean isAdmin() {
<span class="nc" id="L198">    return isAdmin;</span>
  }

  /**
   * @param roleCheck
   *
   * @return True if the current role contains the specified role to check
   */
  public boolean isValidRole(final ROLE roleCheck) {
<span class="fc" id="L207">    final ROLE[] roles = roleCheck.getComposingRoles();</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">    for (final ROLE role1 : roles) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">      if (!role.isContaining(role1)) {</span>
<span class="fc" id="L210">        return false;</span>
      }
    }
<span class="fc" id="L213">    return true;</span>
  }

  /**
   * @return True if the associated host is using SSL
   */
  public boolean isSsl() {
<span class="fc" id="L220">    return currentAuth.isSsl();</span>
  }

  @Override
  public boolean isBusinessPathValid(final String newPath) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">    return newPath != null;</span>
  }

  @Override
  public String toString() {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    return &quot;Auth:&quot; + isIdentified + ' ' +</span>
<span class="pc" id="L231">           (currentAuth != null? currentAuth.toString() : &quot;no Internal Auth&quot;) +</span>
           ' ' + role;
  }

  /**
   * @param server
   *
   * @return the SimpleAuth if any for this user
   */
  public static DbHostAuth getServerAuth(final String server) {
    final DbHostAuth auth;
    try {
<span class="fc" id="L243">      auth = new DbHostAuth(server);</span>
<span class="fc" id="L244">    } catch (final WaarpDatabaseException e) {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">      if (!server.equals(Configuration.configuration.getHostId())) {</span>
<span class="nc" id="L246">        logger.warn(&quot;Cannot find the authentication &quot; + server, e);</span>
      }
<span class="fc" id="L248">      return null;</span>
<span class="fc" id="L249">    }</span>
<span class="fc" id="L250">    return auth;</span>
  }

  /**
   * Special Authentication for local execution
   *
   * @param isSSL
   * @param hostid
   */
  public void specialNoSessionAuth(final boolean isSSL, final String hostid) {
<span class="fc" id="L260">    isIdentified = true;</span>
<span class="fc" id="L261">    DbHostAuth auth = null;</span>
    try {
<span class="fc" id="L263">      auth = new DbHostAuth(hostid);</span>
<span class="fc" id="L264">    } catch (final WaarpDatabaseException ignored) {</span>
      // nothing
<span class="fc" id="L266">    }</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">    if (auth == null) {</span>
<span class="fc" id="L268">      auth =</span>
          new DbHostAuth(hostid, &quot;127.0.0.1&quot;, 6666, isSSL, null, true, false);
    }
<span class="fc" id="L271">    role.clear();</span>
<span class="fc" id="L272">    currentAuth = auth;</span>
<span class="fc" id="L273">    setIsIdentified(true);</span>
<span class="fc" id="L274">    user = auth.getHostid();</span>
    try {
<span class="fc" id="L276">      setRootFromAuth();</span>
<span class="nc" id="L277">    } catch (final Reply421Exception ignored) {</span>
      // nothing
<span class="fc" id="L279">    }</span>
<span class="fc" id="L280">    getSession().getDir().initAfterIdentification();</span>
<span class="fc" id="L281">    isAdmin = isSSL;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">    if (isSSL) {</span>
<span class="fc" id="L283">      role.setRole(ROLE.FULLADMIN);</span>
<span class="fc" id="L284">      user = Configuration.configuration.getAdminName();</span>
    }
<span class="fc" id="L286">  }</span>

  /**
   * connection from HTTPS (no default rights, must be set either as admin or
   * specifically through ROLEs). Only
   * &quot;false client&quot; with port with negative values are allowed.
   *
   * @param hostId
   * @param arg0
   *
   * @return True if the connection is OK (authentication is OK)
   *
   * @throws Reply530Exception if the authentication is wrong
   * @throws Reply421Exception If the service is not available
   */
  public boolean connectionHttps(final String hostId, final byte[] arg0)
      throws Reply530Exception, Reply421Exception {
<span class="fc" id="L303">    final DbHostAuth auth = getServerAuth(hostId);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">    if (auth == null) {</span>
<span class="nc" id="L305">      logger.error(&quot;Cannot find authentication for &quot; + hostId);</span>
<span class="nc" id="L306">      setIsIdentified(false);</span>
<span class="nc" id="L307">      currentAuth = null;</span>
<span class="nc" id="L308">      throw new Reply530Exception(&quot;HostId not allowed&quot;);</span>
    }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (auth.getPort() &gt;= 0) {</span>
<span class="nc" id="L311">      logger.error(&quot;Authentication is unacceptable for &quot; + hostId);</span>
<span class="nc" id="L312">      setIsIdentified(false);</span>
<span class="nc" id="L313">      currentAuth = null;</span>
<span class="nc" id="L314">      throw new Reply530Exception(&quot;HostId not allowed&quot;);</span>
    }
<span class="fc" id="L316">    role.clear();</span>
<span class="fc" id="L317">    currentAuth = auth;</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">    if (currentAuth.isKeyValid(arg0)) {</span>
<span class="fc" id="L319">      setIsIdentified(true);</span>
<span class="fc" id="L320">      user = hostId;</span>
<span class="fc" id="L321">      setRootFromAuth();</span>
<span class="fc" id="L322">      getSession().getDir().initAfterIdentification();</span>
<span class="fc" id="L323">      isAdmin = currentAuth.isAdminrole();</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">      if (!Configuration.configuration.getRoles().isEmpty()) {</span>
<span class="fc" id="L325">        final RoleDefault configRole =</span>
<span class="fc" id="L326">            Configuration.configuration.getRoles().get(hostId);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (configRole != null) {</span>
<span class="fc" id="L328">          role.setRoleDefault(configRole);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">          if (role.isContaining(ROLE.FULLADMIN)) {</span>
<span class="nc" id="L330">            isAdmin = true;</span>
          }
        }
      }
<span class="fc bfc" id="L334" title="All 2 branches covered.">      if (isAdmin) {</span>
<span class="fc" id="L335">        role.setRole(ROLE.FULLADMIN);</span>
      }
<span class="fc" id="L337">      logger.info(role + &quot;:&quot; + currentAuth);</span>
<span class="fc" id="L338">      return true;</span>
    }
<span class="nc" id="L340">    throw new Reply530Exception(&quot;Key is not valid for this HostId&quot;);</span>
  }

  /**
   * @return a copy of the Role of the current authenticated partner
   */
  public RoleDefault getRole() {
<span class="fc" id="L347">    return new RoleDefault().setRoleDefault(role);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>