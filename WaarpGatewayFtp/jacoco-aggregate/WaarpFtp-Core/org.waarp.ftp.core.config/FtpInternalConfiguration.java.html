<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FtpInternalConfiguration.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.config</a> &gt; <span class="el_source">FtpInternalConfiguration.java</span></div><h1>FtpInternalConfiguration.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.config;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelException;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.traffic.ChannelTrafficShapingHandler;
import io.netty.handler.traffic.GlobalChannelTrafficShapingHandler;
import io.netty.util.concurrent.EventExecutorGroup;
import org.waarp.common.command.exception.Reply425Exception;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.DetectionUtils;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpShutdownHook;
import org.waarp.common.utility.WaarpThreadFactory;
import org.waarp.ftp.core.control.FtpInitializer;
import org.waarp.ftp.core.control.ftps.FtpsInitializer;
import org.waarp.ftp.core.data.handler.FtpDataInitializer;
import org.waarp.ftp.core.data.handler.ftps.FtpsDataInitializer;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.session.FtpSession;
import org.waarp.ftp.core.session.FtpSessionReference;
import org.waarp.ftp.core.utils.FtpChannelUtils;
import org.waarp.ftp.core.utils.FtpShutdownHook;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Internal configuration of the FTP server, related to Netty
 */
public class FtpInternalConfiguration {
  // Static values
  /**
   * Internal Logger
   */
<span class="fc" id="L68">  private static final WaarpLogger logger =</span>
<span class="fc" id="L69">      WaarpLoggerFactory.getLogger(FtpInternalConfiguration.class);</span>

  // Network Internals
  /**
   * Time elapse for retry in ms
   */
  public static final long RETRYINMS = 10;

  /**
   * Number of retry before error
   */
  public static final int RETRYNB = 10;

  /**
   * Hack to say Windows or Unix (USR1 not OK on Windows)
   */
  static Boolean isUnix;

  // Dynamic values
  /**
   * List of all Command Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup commandChannelGroup;

  /**
   * ExecutorService Server
   */
  private final EventLoopGroup execServer;

  /**
   * ExecutorService Worker
   */
  private final EventLoopGroup execWorker;

  /**
   * List of all Data Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup dataChannelGroup;

  /**
   * ExecutorService Command Event Loop
   */
  private final EventLoopGroup execCommandEvent;

  /**
   * ExecutorService Data Event Loop
   */
  private final EventLoopGroup execDataEvent;

  /**
   * ExecutorService Data Active Server
   */
  private final EventLoopGroup execDataServer;

  /**
   * ExecutorService Data Active Worker
   */
  private final EventLoopGroup execDataWorker;

  /**
   * FtpSession references used by Data Connection process
   */
<span class="fc" id="L133">  private final FtpSessionReference ftpSessionReference =</span>
      new FtpSessionReference();

  /**
   * Bootstrap for Active connections
   */
  private Bootstrap activeBootstrap;

  /**
   * ServerBootStrap for Passive connections
   */
  private ServerBootstrap passiveBootstrap;

  /**
   * Scheduler for TrafficCounter
   */
<span class="fc" id="L149">  private final ScheduledExecutorService executorService =</span>
<span class="fc" id="L150">      Executors.newScheduledThreadPool(2,</span>
                                       new WaarpThreadFactory(&quot;TimerTrafficFtp&quot;,
                                                              false));

  /**
   * Global TrafficCounter (set from global configuration)
   */
  private FtpGlobalTrafficShapingHandler globalTrafficShapingHandler;

  /**
   * Does the FTP will be SSL native based (990 989 port)
   */
  private boolean usingNativeSsl;

  /**
   * Does the FTP accept AUTH and PROT
   */
  private boolean acceptAuthProt;
  /**
   * Bootstrap for Active Ssl connections
   */
  private Bootstrap activeSslBootstrap;

  /**
   * ServerBootStrap for Passive Ssl connections
   */
  private ServerBootstrap passiveSslBootstrap;

  /**
   * org.waarp.ftp.core.config BindAddress
   */
  public static class BindAddress {
    /**
     * Parent passive channel
     */
    public final Channel parent;

    /**
     * Number of binded Data connections
     */
<span class="fc" id="L190">    public final AtomicInteger nbBind = new AtomicInteger();</span>

    /**
     * Constructor
     *
     * @param channel
     */
<span class="fc" id="L197">    public BindAddress(final Channel channel) {</span>
<span class="fc" id="L198">      parent = channel;</span>
<span class="fc" id="L199">      nbBind.set(0);</span>
<span class="fc" id="L200">    }</span>
  }

  /**
   * List of already bind local addresses for Passive connections
   */
<span class="fc" id="L206">  private final ConcurrentHashMap&lt;InetSocketAddress, BindAddress&gt;</span>
      hashBindPassiveDataConn =
      new ConcurrentHashMap&lt;InetSocketAddress, BindAddress&gt;();

  /**
   * Global Configuration
   */
  private final FtpConfiguration configuration;

  /**
   * Constructor
   *
   * @param configuration
   */
<span class="fc" id="L220">  public FtpInternalConfiguration(final FtpConfiguration configuration) {</span>
<span class="fc" id="L221">    this.configuration = configuration;</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    isUnix = !DetectionUtils.isWindows();</span>
<span class="fc" id="L223">    configuration.getShutdownConfiguration().timeout =</span>
<span class="fc" id="L224">        configuration.getTimeoutCon();</span>
<span class="fc" id="L225">    new FtpShutdownHook(configuration.getShutdownConfiguration(),</span>
                        configuration);
<span class="fc" id="L227">    execCommandEvent = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                             new WaarpThreadFactory(&quot;Command&quot;));
<span class="fc" id="L229">    execDataEvent = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                          new WaarpThreadFactory(&quot;Data&quot;));
<span class="fc" id="L231">    execServer = new NioEventLoopGroup(configuration.getServerThread(),</span>
                                       new WaarpThreadFactory(&quot;CommandServer&quot;));
<span class="fc" id="L233">    execWorker = new NioEventLoopGroup(configuration.getClientThread(),</span>
                                       new WaarpThreadFactory(&quot;CommandWorker&quot;));
<span class="fc" id="L235">    execDataServer = new NioEventLoopGroup(configuration.getServerThread(),</span>
                                           new WaarpThreadFactory(
                                               &quot;DataServer&quot;));
<span class="fc" id="L238">    execDataWorker = new NioEventLoopGroup(configuration.getClientThread() * 2,</span>
                                           new WaarpThreadFactory(
                                               &quot;DataWorker&quot;));
<span class="fc" id="L241">  }</span>

  /**
   * Startup the server
   *
   * @throws FtpNoConnectionException
   */
  public final void serverStartup() throws FtpNoConnectionException {
<span class="fc" id="L249">    logger.debug(&quot;Start groups&quot;);</span>
    // Command
<span class="fc" id="L251">    commandChannelGroup =</span>
<span class="fc" id="L252">        new DefaultChannelGroup(configuration.fromClass.getName(),</span>
<span class="fc" id="L253">                                execWorker.next());</span>
    // Data
<span class="fc" id="L255">    dataChannelGroup =</span>
<span class="fc" id="L256">        new DefaultChannelGroup(configuration.fromClass.getName() + &quot;.data&quot;,</span>
<span class="fc" id="L257">                                execWorker.next());</span>

<span class="fc" id="L259">    logger.debug(&quot;Start data connections&quot;);</span>
    // Passive Data Connections
<span class="fc" id="L261">    passiveBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L262">    WaarpNettyUtil.setServerBootstrap(passiveBootstrap, execDataServer,</span>
                                      execDataWorker,
<span class="fc" id="L264">                                      (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L265">                                      configuration.getBlocksize() + 1024,</span>
                                      true);
<span class="fc bfc" id="L267" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L268">      passiveBootstrap.childHandler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, false));
    } else {
<span class="fc" id="L272">      passiveBootstrap.childHandler(</span>
          new FtpDataInitializer(configuration.dataBusinessHandler,
                                 configuration, false));
    }
<span class="fc bfc" id="L276" title="All 2 branches covered.">    if (acceptAuthProt) {</span>
<span class="fc" id="L277">      passiveSslBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L278">      WaarpNettyUtil.setServerBootstrap(passiveSslBootstrap, execDataServer,</span>
                                        execDataWorker,
<span class="fc" id="L280">                                        (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L281">                                        configuration.getBlocksize() + 1024,</span>
                                        true);
<span class="fc" id="L283">      passiveSslBootstrap.childHandler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, false));
    } else {
<span class="fc" id="L287">      passiveSslBootstrap = passiveBootstrap;</span>
    }

    // Active Data Connections
<span class="fc" id="L291">    activeBootstrap = new Bootstrap();</span>
<span class="fc" id="L292">    WaarpNettyUtil.setBootstrap(activeBootstrap, execDataWorker,</span>
<span class="fc" id="L293">                                (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L294">                                configuration.getBlocksize() + 1024, true);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L296">      activeBootstrap.handler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, true));
    } else {
<span class="fc" id="L300">      activeBootstrap.handler(</span>
          new FtpDataInitializer(configuration.dataBusinessHandler,
                                 configuration, true));
    }
<span class="fc bfc" id="L304" title="All 2 branches covered.">    if (acceptAuthProt) {</span>
<span class="fc" id="L305">      activeSslBootstrap = new Bootstrap();</span>
<span class="fc" id="L306">      WaarpNettyUtil.setBootstrap(activeSslBootstrap, execDataWorker,</span>
<span class="fc" id="L307">                                  (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L308">                                  configuration.getBlocksize() + 1024, true);</span>
<span class="fc" id="L309">      activeSslBootstrap.handler(</span>
          new FtpsDataInitializer(configuration.dataBusinessHandler,
                                  configuration, true));
    } else {
<span class="fc" id="L313">      activeSslBootstrap = activeBootstrap;</span>
    }

<span class="fc" id="L316">    logger.debug(&quot;Start command connections {}&quot;, configuration.getServerPort());</span>
    // Main Command server
    /*
     * Bootstrap for Command server
     */
<span class="fc" id="L321">    final ServerBootstrap serverBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L322">    WaarpNettyUtil.setServerBootstrap(serverBootstrap, execServer, execWorker,</span>
<span class="fc" id="L323">                                      (int) configuration.getTimeoutCon(),</span>
<span class="fc" id="L324">                                      configuration.getBlocksize(), true);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (usingNativeSsl) {</span>
<span class="fc" id="L326">      serverBootstrap.childHandler(</span>
          new FtpsInitializer(configuration.businessHandler, configuration));
    } else {
<span class="fc" id="L329">      serverBootstrap.childHandler(</span>
          new FtpInitializer(configuration.businessHandler, configuration));
    }
<span class="fc" id="L332">    final InetSocketAddress socketAddress =</span>
<span class="fc" id="L333">        new InetSocketAddress(configuration.getServerPort());</span>
<span class="fc" id="L334">    ChannelFuture future = serverBootstrap.bind(socketAddress);</span>
    try {
<span class="fc" id="L336">      future = future.sync();</span>
<span class="nc" id="L337">    } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L338">      logger.error(&quot;Cannot start command conections: {}&quot;, e.getMessage());</span>
<span class="nc" id="L339">      throw new FtpNoConnectionException(&quot;Can't initiate the FTP server&quot;, e);</span>
<span class="fc" id="L340">    }</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    if (!future.isSuccess()) {</span>
<span class="nc" id="L342">      logger.error(&quot;Cannot start command conections&quot;);</span>
<span class="nc" id="L343">      throw new FtpNoConnectionException(&quot;Can't initiate the FTP server&quot;);</span>
    }
<span class="fc" id="L345">    FtpChannelUtils.addCommandChannel(future.channel(), configuration);</span>

    // Init Shutdown Hook handler
<span class="fc" id="L348">    configuration.getShutdownConfiguration().timeout =</span>
<span class="fc" id="L349">        configuration.getTimeoutCon();</span>
<span class="fc" id="L350">    WaarpShutdownHook.addShutdownHook();</span>
    // Factory for TrafficShapingHandler
<span class="fc" id="L352">    globalTrafficShapingHandler =</span>
        new FtpGlobalTrafficShapingHandler(executorService,
<span class="fc" id="L354">                                           configuration.getServerGlobalWriteLimit(),</span>
<span class="fc" id="L355">                                           configuration.getServerGlobalReadLimit(),</span>
<span class="fc" id="L356">                                           configuration.getServerChannelWriteLimit(),</span>
<span class="fc" id="L357">                                           configuration.getServerChannelReadLimit(),</span>
<span class="fc" id="L358">                                           configuration.getDelayLimit());</span>
<span class="fc" id="L359">  }</span>

  /**
   * @return an ExecutorService
   */
  public final ExecutorService getWorker() {
<span class="nc" id="L365">    return execWorker;</span>
  }

  /**
   * Add a session from a couple of addresses
   *
   * @param ipOnly
   * @param fullIp
   * @param session
   */
  public final void setNewFtpSession(final InetAddress ipOnly,
                                     final InetSocketAddress fullIp,
                                     final FtpSession session) {
<span class="fc" id="L378">    ftpSessionReference.setNewFtpSession(ipOnly, fullIp, session);</span>
<span class="fc" id="L379">  }</span>

  /**
   * Return and remove the FtpSession
   *
   * @param channel
   *
   * @return the FtpSession if it exists associated to this channel
   */
  public final FtpSession getFtpSession(final Channel channel) {
<span class="fc" id="L389">    return ftpSessionReference.getPassiveFtpSession(channel);</span>
  }

  /**
   * Remove the FtpSession
   *
   * @param ipOnly
   * @param fullIp
   */
  public final void delFtpSession(final InetAddress ipOnly,
                                  final InetSocketAddress fullIp) {
<span class="fc" id="L400">    ftpSessionReference.delFtpSession(ipOnly, fullIp);</span>
<span class="fc" id="L401">  }</span>

  /**
   * @return the number of Active Sessions
   */
  public final int getNumberSessions() {
<span class="fc" id="L407">    return ftpSessionReference.sessionsNumber();</span>
  }

  /**
   * @param channel
   *
   * @return the FtpSession if found
   */
  public final FtpSession findPassiveFtpSession(final Channel channel) {
<span class="nc" id="L416">    return ftpSessionReference.findPassive(channel);</span>
  }

  /**
   * Try to add a Passive Channel listening to the specified local address
   *
   * @param address
   * @param ssl
   *
   * @throws Reply425Exception in case the channel cannot be opened
   */
  public final void bindPassive(final InetSocketAddress address,
                                final boolean ssl) throws Reply425Exception {
<span class="fc" id="L429">    configuration.bindLock();</span>
    try {
<span class="fc" id="L431">      BindAddress bindAddress = hashBindPassiveDataConn.get(address);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">      if (bindAddress == null) {</span>
<span class="fc" id="L433">        logger.debug(&quot;Bind really to {}&quot;, address);</span>
        final Channel parentChannel;
        try {
          final ChannelFuture future;
<span class="fc bfc" id="L437" title="All 2 branches covered.">          if (ssl) {</span>
<span class="fc" id="L438">            future = passiveSslBootstrap.bind(address);</span>
          } else {
<span class="fc" id="L440">            future = passiveBootstrap.bind(address);</span>
          }
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">          if (future.await(configuration.getTimeoutCon())) {</span>
<span class="fc" id="L443">            parentChannel = future.sync().channel();</span>
          } else {
<span class="nc" id="L445">            logger.warn(&quot;Cannot open passive connection due to Timeout&quot;);</span>
<span class="nc" id="L446">            throw new Reply425Exception(</span>
                &quot;Cannot open a Passive Connection due to Timeout&quot;);
          }
<span class="nc" id="L449">        } catch (final ChannelException e) {</span>
<span class="nc" id="L450">          logger.warn(&quot;Cannot open passive connection {}&quot;, e.getMessage());</span>
<span class="nc" id="L451">          throw new Reply425Exception(&quot;Cannot open a Passive Connection&quot;);</span>
<span class="nc" id="L452">        } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L453">          logger.warn(&quot;Cannot open passive connection {}&quot;, e.getMessage());</span>
<span class="nc" id="L454">          throw new Reply425Exception(&quot;Cannot open a Passive Connection&quot;);</span>
<span class="fc" id="L455">        }</span>
<span class="fc" id="L456">        bindAddress = new BindAddress(parentChannel);</span>
<span class="fc" id="L457">        FtpChannelUtils.addDataChannel(parentChannel, configuration);</span>
<span class="fc" id="L458">        hashBindPassiveDataConn.put(address, bindAddress);</span>
      }
<span class="fc" id="L460">      bindAddress.nbBind.getAndIncrement();</span>
<span class="fc" id="L461">      logger.debug(&quot;Bind number to {} is {}&quot;, address, bindAddress.nbBind);</span>
    } finally {
<span class="fc" id="L463">      configuration.bindUnlock();</span>
    }
<span class="fc" id="L465">  }</span>

  /**
   * Try to unbind (closing the parent channel) the Passive Channel listening
   * to
   * the specified local address if
   * the last one. It returns only when the underlying parent channel is
   * closed
   * if this was the last session
   * that wants to open on this local address.
   *
   * @param address
   */
  public final void unbindPassive(final InetSocketAddress address) {
<span class="fc" id="L479">    configuration.bindLock();</span>
    try {
<span class="fc" id="L481">      final BindAddress bindAddress = hashBindPassiveDataConn.get(address);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">      if (bindAddress != null) {</span>
<span class="fc" id="L483">        bindAddress.nbBind.getAndDecrement();</span>
<span class="fc" id="L484">        logger.debug(&quot;Bind number to {} left is {}&quot;, address,</span>
                     bindAddress.nbBind);
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (bindAddress.nbBind.get() == 0) {</span>
<span class="fc" id="L487">          final ChannelFuture future =</span>
<span class="fc" id="L488">              WaarpSslUtility.closingSslChannel(bindAddress.parent);</span>
<span class="fc" id="L489">          hashBindPassiveDataConn.remove(address);</span>
<span class="fc" id="L490">          future.awaitUninterruptibly();</span>
<span class="fc" id="L491">        }</span>
      } else {
<span class="nc" id="L493">        logger.warn(&quot;No Bind to {}&quot;, address);</span>
      }
    } finally {
<span class="fc" id="L496">      configuration.bindUnlock();</span>
    }
<span class="fc" id="L498">  }</span>

  /**
   * @return the number of Binded Passive Connections
   */
  public final int getNbBindedPassive() {
<span class="nc" id="L504">    return hashBindPassiveDataConn.size();</span>
  }

  /**
   * Return the associated Executor for Command Event
   *
   * @return the Command Event Executor
   */
  public final EventExecutorGroup getExecutor() {
<span class="fc" id="L513">    return execCommandEvent;</span>
  }

  /**
   * Return the associated Executor for Data Event
   *
   * @return the Data Event Executor
   */
  public final EventExecutorGroup getDataExecutor() {
<span class="fc" id="L522">    return execDataEvent;</span>
  }

  /**
   * @param ssl
   *
   * @return the ActiveBootstrap
   */
  public final Bootstrap getActiveBootstrap(final boolean ssl) {
<span class="fc bfc" id="L531" title="All 2 branches covered.">    if (ssl) {</span>
<span class="fc" id="L532">      return activeSslBootstrap;</span>
    } else {
<span class="fc" id="L534">      return activeBootstrap;</span>
    }
  }

  /**
   * @return the commandChannelGroup
   */
  public final ChannelGroup getCommandChannelGroup() {
<span class="fc" id="L542">    return commandChannelGroup;</span>
  }

  /**
   * @return the dataChannelGroup
   */
  public final ChannelGroup getDataChannelGroup() {
<span class="fc" id="L549">    return dataChannelGroup;</span>
  }

  /**
   * @return The TrafficCounterFactory
   */
  public final FtpGlobalTrafficShapingHandler getGlobalTrafficShapingHandler() {
<span class="fc" id="L556">    return globalTrafficShapingHandler;</span>
  }

  /**
   * @return a new ChannelTrafficShapingHandler
   */
  public final ChannelTrafficShapingHandler newChannelTrafficShapingHandler() {
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">    if (configuration.getServerChannelWriteLimit() == 0 &amp;&amp;</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        configuration.getServerChannelReadLimit() == 0) {</span>
<span class="fc" id="L565">      return null;</span>
    }
<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (globalTrafficShapingHandler instanceof GlobalChannelTrafficShapingHandler) {</span>
<span class="nc" id="L568">      return null;</span>
    }
<span class="nc" id="L570">    return new FtpChannelTrafficShapingHandler(</span>
<span class="nc" id="L571">        configuration.getServerChannelWriteLimit(),</span>
<span class="nc" id="L572">        configuration.getServerChannelReadLimit(),</span>
<span class="nc" id="L573">        configuration.getDelayLimit());</span>
  }

  public final void releaseResources() {
<span class="fc" id="L577">    WaarpSslUtility.forceCloseAllSslChannels();</span>
<span class="fc" id="L578">    execWorker.shutdownGracefully();</span>
<span class="fc" id="L579">    execDataWorker.shutdownGracefully();</span>
<span class="fc" id="L580">    execServer.shutdownGracefully();</span>
<span class="fc" id="L581">    execDataServer.shutdownGracefully();</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    if (globalTrafficShapingHandler != null) {</span>
<span class="fc" id="L583">      globalTrafficShapingHandler.release();</span>
    }
<span class="fc" id="L585">    executorService.shutdown();</span>
<span class="fc" id="L586">  }</span>

  public final boolean isAcceptAuthProt() {
<span class="fc" id="L589">    return acceptAuthProt;</span>
  }

  /**
   * @return the usingNativeSsl
   */
  public final boolean isUsingNativeSsl() {
<span class="fc" id="L596">    return usingNativeSsl;</span>
  }

  /**
   * @param usingNativeSsl the usingNativeSsl to set
   */
  public final void setUsingNativeSsl(final boolean usingNativeSsl) {
<span class="fc" id="L603">    this.usingNativeSsl = usingNativeSsl;</span>
<span class="fc" id="L604">  }</span>

  /**
   * @param acceptAuthProt the acceptAuthProt to set
   */
  public final void setAcceptAuthProt(final boolean acceptAuthProt) {
<span class="fc" id="L610">    this.acceptAuthProt = acceptAuthProt;</span>
<span class="fc" id="L611">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>