<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.ftp.exec</a> &gt; <span class="el_source">AbstractExecutor.java</span></div><h1>AbstractExecutor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.gateway.ftp.exec;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.future.WaarpFuture;
import org.waarp.common.guid.GUID;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.gateway.kernel.session.CommandExecutorInterface;
import org.waarp.gateway.kernel.session.HttpAuthInterface;

import java.util.regex.Pattern;

/**
 * Abstract Executor class. If the command starts with &quot;REFUSED&quot;, the command
 * will be refused for execution.
 * If &quot;REFUSED&quot; is set, the command &quot;RETR&quot; or &quot;STOR&quot; like operations will be
 * stopped at starting of
 * command.&lt;br&gt;
 * If the command starts with &quot;EXECUTE&quot;, the following will be a command to be
 * executed.&lt;br&gt;
 * If the command starts with &quot;JAVAEXECUTE&quot;, the following will be a command
 * through Java class to be
 * executed.&lt;br&gt;
 * If the command starts with &quot;R66PREPARETRANSFER&quot;, the following will be a r66
 * prepare transfer execution
 * (asynchronous operation only).&lt;br&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The following replacement are done dynamically before the command is
 * executed:&lt;br&gt;
 * - #BASEPATH# is replaced by the full path for the root of FTP Directory&lt;br&gt;
 * - #FILE# is replaced by the current file path relative to FTP Directory (so
 * #BASEPATH##FILE# is the full
 * path of the file)&lt;br&gt;
 * - #USER# is replaced by the username&lt;br&gt;
 * - #ACCOUNT# is replaced by the account&lt;br&gt;
 * - #COMMAND# is replaced by the command issued for the file&lt;br&gt;
 * - #SPECIALID# is replaced by the FTP id of the transfer (whatever in or
 * out)&lt;br&gt;
 * - #UUID# is replaced by a special UUID globally unique for the transfer, in
 * general to be placed in -info
 * part (for instance ##UUID## giving #uuid#)&lt;br&gt;
 */
<span class="fc" id="L64">public abstract class AbstractExecutor {</span>
  /**
   * Internal Logger
   */
<span class="fc" id="L68">  private static final WaarpLogger logger =</span>
<span class="fc" id="L69">      WaarpLoggerFactory.getLogger(AbstractExecutor.class);</span>
<span class="fc" id="L70">  protected static final Pattern BLANK = WaarpStringUtils.BLANK;</span>

  protected static final String USER = &quot;#USER#&quot;;
  protected static final String ACCOUNT = &quot;#ACCOUNT#&quot;;
  protected static final String BASEPATH = &quot;#BASEPATH#&quot;;
  protected static final String FILE = &quot;#FILE#&quot;;
  protected static final String COMMAND = &quot;#COMMAND#&quot;;
  protected static final String SPECIALID = &quot;#SPECIALID#&quot;;
  protected static final String sUUID = &quot;#sUUID#&quot;;

  protected static final String REFUSED = &quot;REFUSED&quot;;
  protected static final String NONE = &quot;NONE&quot;;
  protected static final String EXECUTE = &quot;EXECUTE&quot;;
  protected static final String JAVAEXECUTE = &quot;JAVAEXECUTE&quot;;
  protected static final String R66PREPARETRANSFER = &quot;R66PREPARETRANSFER&quot;;

  protected static final int tREFUSED = -1;
  protected static final int tNONE = 0;
  protected static final int tEXECUTE = 1;
  protected static final int tR66PREPARETRANSFER = 2;
  protected static final int tJAVAEXECUTE = 3;

  protected static CommandExecutor commandExecutor;

  /**
   * For OpenR66 access
   */
  public static boolean useDatabase;

  /**
   * Local Exec Daemon is used or not for execution of external commands
   */
  public static boolean useLocalExec;

  public static class CommandExecutor implements CommandExecutorInterface {
    /**
     * Retrieve External Command
     */
    public final String pretrCMD;
    public final int pretrType;
    private boolean pretrRefused;
    /**
     * Retrieve Delay (0 = unlimited)
     */
    private long pretrDelay;
    /**
     * Store External Command
     */
    public final String pstorCMD;
    public final int pstorType;
    private boolean pstorRefused;
    /**
     * Store Delay (0 = unlimited)
     */
    private long pstorDelay;

    /**
     * @param retrieve
     * @param retrDelay
     * @param store
     * @param storDelay
     */
    public CommandExecutor(String retrieve, long retrDelay, String store,
<span class="fc" id="L133">                           long storDelay) {</span>
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">      if (retrieve == null || retrieve.trim().length() == 0) {</span>
<span class="fc" id="L135">        pretrCMD = commandExecutor.pretrCMD;</span>
<span class="fc" id="L136">        pretrType = commandExecutor.pretrType;</span>
<span class="fc" id="L137">        setPretrRefused(commandExecutor.isPretrRefused());</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">      } else if (isRefused(retrieve)) {</span>
<span class="nc" id="L139">        pretrCMD = REFUSED;</span>
<span class="nc" id="L140">        pretrType = tREFUSED;</span>
<span class="nc" id="L141">        setPretrRefused(true);</span>
      } else {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (isExecute(retrieve)) {</span>
<span class="fc" id="L144">          pretrCMD = getExecuteCmd(retrieve);</span>
<span class="fc" id="L145">          pretrType = tEXECUTE;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        } else if (isR66PrepareTransfer(retrieve)) {</span>
<span class="nc" id="L147">          pretrCMD = getR66PrepareTransferCmd(retrieve);</span>
<span class="nc" id="L148">          pretrType = tR66PREPARETRANSFER;</span>
<span class="nc" id="L149">          useDatabase = true;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        } else if (isJavaExecute(retrieve)) {</span>
<span class="nc" id="L151">          pretrCMD = getJavaExecuteCmd(retrieve);</span>
<span class="nc" id="L152">          pretrType = tJAVAEXECUTE;</span>
        } else {
          // Default NONE
<span class="nc" id="L155">          pretrCMD = getNone(retrieve);</span>
<span class="nc" id="L156">          pretrType = tNONE;</span>
        }
      }
<span class="fc" id="L159">      setPretrDelay(retrDelay);</span>
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">      if (store == null || store.trim().length() == 0) {</span>
<span class="fc" id="L161">        pstorCMD = commandExecutor.pstorCMD;</span>
<span class="fc" id="L162">        setPstorRefused(commandExecutor.isPstorRefused());</span>
<span class="fc" id="L163">        pstorType = commandExecutor.pstorType;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">      } else if (isRefused(store)) {</span>
<span class="nc" id="L165">        pstorCMD = REFUSED;</span>
<span class="nc" id="L166">        setPstorRefused(true);</span>
<span class="nc" id="L167">        pstorType = tREFUSED;</span>
      } else {
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (isExecute(store)) {</span>
<span class="fc" id="L170">          pstorCMD = getExecuteCmd(store);</span>
<span class="fc" id="L171">          pstorType = tEXECUTE;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        } else if (isR66PrepareTransfer(store)) {</span>
<span class="nc" id="L173">          pstorCMD = getR66PrepareTransferCmd(store);</span>
<span class="nc" id="L174">          pstorType = tR66PREPARETRANSFER;</span>
<span class="nc" id="L175">          useDatabase = true;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        } else if (isJavaExecute(store)) {</span>
<span class="nc" id="L177">          pstorCMD = getJavaExecuteCmd(store);</span>
<span class="nc" id="L178">          pstorType = tJAVAEXECUTE;</span>
        } else {
          // Default NONE
<span class="nc" id="L181">          pstorCMD = getNone(store);</span>
<span class="nc" id="L182">          pstorType = tNONE;</span>
        }
      }
<span class="fc" id="L185">      setPstorDelay(storDelay);</span>
<span class="fc" id="L186">    }</span>

    private static String getNone(String cmd) {
<span class="nc" id="L189">      return cmd.substring(NONE.length()).trim();</span>
    }

    private static String getExecuteCmd(String cmd) {
<span class="fc" id="L193">      return cmd.substring(EXECUTE.length()).trim();</span>
    }

    private static String getJavaExecuteCmd(String cmd) {
<span class="nc" id="L197">      return cmd.substring(JAVAEXECUTE.length()).trim();</span>
    }

    private static String getR66PrepareTransferCmd(String cmd) {
<span class="nc" id="L201">      return cmd.substring(R66PREPARETRANSFER.length()).trim();</span>
    }

    private static boolean isRefused(String cmd) {
<span class="fc" id="L205">      return cmd.startsWith(REFUSED);</span>
    }

    private static boolean isExecute(String cmd) {
<span class="fc" id="L209">      return cmd.startsWith(EXECUTE);</span>
    }

    private static boolean isJavaExecute(String cmd) {
<span class="nc" id="L213">      return cmd.startsWith(JAVAEXECUTE);</span>
    }

    private static boolean isR66PrepareTransfer(String cmd) {
<span class="nc" id="L217">      return cmd.startsWith(R66PREPARETRANSFER);</span>
    }

    @Override
    public boolean isValidOperation(boolean isStore) {
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">      if (isStore &amp;&amp; isPstorRefused()) {</span>
<span class="nc" id="L223">        logger.info(&quot;STORe like operations REFUSED&quot;);</span>
<span class="nc" id="L224">        return false;</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">      } else if (!isStore &amp;&amp; isPretrRefused()) {</span>
<span class="nc" id="L226">        logger.info(&quot;RETRieve operations REFUSED&quot;);</span>
<span class="nc" id="L227">        return false;</span>
      }
<span class="fc" id="L229">      return true;</span>
    }

    @Override
    public String getRetrType() {
<span class="pc bpc" id="L234" title="4 of 5 branches missed.">      switch (pretrType) {</span>
        case tREFUSED:
<span class="nc" id="L236">          return REFUSED;</span>
        case tEXECUTE:
<span class="fc" id="L238">          return EXECUTE;</span>
        case tR66PREPARETRANSFER:
<span class="nc" id="L240">          return R66PREPARETRANSFER;</span>
        case tJAVAEXECUTE:
<span class="nc" id="L242">          return JAVAEXECUTE;</span>
        default:
<span class="nc" id="L244">          return NONE;</span>
      }
    }

    @Override
    public String getStorType() {
<span class="pc bpc" id="L250" title="4 of 5 branches missed.">      switch (pstorType) {</span>
        case tREFUSED:
<span class="nc" id="L252">          return REFUSED;</span>
        case tEXECUTE:
<span class="fc" id="L254">          return EXECUTE;</span>
        case tR66PREPARETRANSFER:
<span class="nc" id="L256">          return R66PREPARETRANSFER;</span>
        case tJAVAEXECUTE:
<span class="nc" id="L258">          return JAVAEXECUTE;</span>
        default:
<span class="nc" id="L260">          return NONE;</span>
      }
    }

    /**
     * @return the pretrRefused
     */
    public boolean isPretrRefused() {
<span class="fc" id="L268">      return pretrRefused;</span>
    }

    /**
     * @param pretrRefused the pretrRefused to set
     */
    public void setPretrRefused(boolean pretrRefused) {
<span class="fc" id="L275">      this.pretrRefused = pretrRefused;</span>
<span class="fc" id="L276">    }</span>

    /**
     * @return the pretrDelay
     */
    public long getPretrDelay() {
<span class="fc" id="L282">      return pretrDelay;</span>
    }

    /**
     * @param pretrDelay the pretrDelay to set
     */
    public void setPretrDelay(long pretrDelay) {
<span class="fc" id="L289">      this.pretrDelay = pretrDelay;</span>
<span class="fc" id="L290">    }</span>

    /**
     * @return the pstorRefused
     */
    public boolean isPstorRefused() {
<span class="fc" id="L296">      return pstorRefused;</span>
    }

    /**
     * @param pstorRefused the pstorRefused to set
     */
    public void setPstorRefused(boolean pstorRefused) {
<span class="fc" id="L303">      this.pstorRefused = pstorRefused;</span>
<span class="fc" id="L304">    }</span>

    /**
     * @return the pstorDelay
     */
    public long getPstorDelay() {
<span class="fc" id="L310">      return pstorDelay;</span>
    }

    /**
     * @param pstorDelay the pstorDelay to set
     */
    public void setPstorDelay(long pstorDelay) {
<span class="fc" id="L317">      this.pstorDelay = pstorDelay;</span>
<span class="fc" id="L318">    }</span>
  }

  /**
   * Initialize the Executor with the correct command and delay
   *
   * @param retrieve
   * @param retrDelay
   * @param store
   * @param storDelay
   */
  public static void initializeExecutor(String retrieve, long retrDelay,
                                        String store, long storDelay) {
<span class="fc" id="L331">    commandExecutor =</span>
        new CommandExecutor(retrieve, retrDelay, store, storDelay);
<span class="fc" id="L333">    logger.info(</span>
<span class="fc" id="L334">        &quot;Executor configured as [RETR: &quot; + commandExecutor.getRetrType() + ':' +</span>
<span class="fc" id="L335">        commandExecutor.pretrCMD + ':' + commandExecutor.getPretrDelay() + ':' +</span>
<span class="fc" id="L336">        commandExecutor.isPretrRefused() + &quot;] [STOR: &quot; +</span>
<span class="fc" id="L337">        commandExecutor.getStorType() + ':' + commandExecutor.pstorCMD + ':' +</span>
<span class="fc" id="L338">        commandExecutor.getPstorDelay() + ':' +</span>
<span class="fc" id="L339">        commandExecutor.isPstorRefused() + ']');</span>
<span class="fc" id="L340">  }</span>

  /**
   * Check if the given operation is allowed Globally
   *
   * @param isStore
   *
   * @return True if allowed, else False
   */
  public static boolean isValidOperation(boolean isStore) {
<span class="nc" id="L350">    return commandExecutor.isValidOperation(isStore);</span>
  }

  /**
   * @param auth the current Authentication
   * @param args containing in that order &quot;User Account BaseDir
   *     FilePath(relative to BaseDir)
   *     Command&quot;
   * @param isStore True for a STORE like operation, else False
   * @param futureCompletion
   */
  public static AbstractExecutor createAbstractExecutor(HttpAuthInterface auth,
                                                        String[] args,
                                                        boolean isStore,
                                                        WaarpFuture futureCompletion) {
<span class="fc bfc" id="L365" title="All 2 branches covered.">    if (isStore) {</span>
<span class="fc" id="L366">      CommandExecutor executor = (CommandExecutor) auth.getCommandExecutor();</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">      if (executor == null) {</span>
<span class="nc" id="L368">        executor = commandExecutor;</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">      } else if (executor.pstorType == tNONE) {</span>
<span class="nc" id="L370">        final String replaced = getPreparedCommand(executor.pstorCMD, args);</span>
<span class="nc" id="L371">        return new NoTaskExecutor(replaced, executor.getPstorDelay(),</span>
                                  futureCompletion);
      }
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">      if (executor.isPstorRefused()) {</span>
<span class="nc" id="L375">        logger.error(&quot;STORe like operation REFUSED&quot;);</span>
<span class="nc" id="L376">        futureCompletion.cancel();</span>
<span class="nc" id="L377">        return null;</span>
      }
<span class="fc" id="L379">      final String replaced = getPreparedCommand(executor.pstorCMD, args);</span>
<span class="pc bpc" id="L380" title="4 of 5 branches missed.">      switch (executor.pstorType) {</span>
        case tREFUSED:
<span class="nc" id="L382">          logger.error(&quot;STORe like operation REFUSED&quot;);</span>
<span class="nc" id="L383">          futureCompletion.cancel();</span>
<span class="nc" id="L384">          return null;</span>
        case tEXECUTE:
<span class="fc" id="L386">          return new ExecuteExecutor(replaced, executor.getPstorDelay(),</span>
                                     futureCompletion);
        case tJAVAEXECUTE:
<span class="nc" id="L389">          return new JavaExecutor(replaced, executor.getPstorDelay(),</span>
                                  futureCompletion);
        case tR66PREPARETRANSFER:
<span class="nc" id="L392">          return new R66PreparedTransferExecutor(replaced,</span>
<span class="nc" id="L393">                                                 executor.getPstorDelay(),</span>
                                                 futureCompletion);
        default:
<span class="nc" id="L396">          return new NoTaskExecutor(replaced, executor.getPstorDelay(),</span>
                                    futureCompletion);
      }
    } else {
<span class="fc" id="L400">      CommandExecutor executor = (CommandExecutor) auth.getCommandExecutor();</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">      if (executor == null) {</span>
<span class="nc" id="L402">        executor = commandExecutor;</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">      } else if (executor.pretrType == tNONE) {</span>
<span class="nc" id="L404">        final String replaced = getPreparedCommand(executor.pretrCMD, args);</span>
<span class="nc" id="L405">        return new NoTaskExecutor(replaced, executor.getPretrDelay(),</span>
                                  futureCompletion);
      }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">      if (executor.isPretrRefused()) {</span>
<span class="nc" id="L409">        logger.error(&quot;RETRieve operation REFUSED&quot;);</span>
<span class="nc" id="L410">        futureCompletion.cancel();</span>
<span class="nc" id="L411">        return null;</span>
      }
<span class="fc" id="L413">      final String replaced = getPreparedCommand(executor.pretrCMD, args);</span>
<span class="pc bpc" id="L414" title="4 of 5 branches missed.">      switch (executor.pretrType) {</span>
        case tREFUSED:
<span class="nc" id="L416">          logger.error(&quot;RETRieve operation REFUSED&quot;);</span>
<span class="nc" id="L417">          futureCompletion.cancel();</span>
<span class="nc" id="L418">          return null;</span>
        case tEXECUTE:
<span class="fc" id="L420">          return new ExecuteExecutor(replaced, executor.getPretrDelay(),</span>
                                     futureCompletion);
        case tJAVAEXECUTE:
<span class="nc" id="L423">          return new JavaExecutor(replaced, executor.getPretrDelay(),</span>
                                  futureCompletion);
        case tR66PREPARETRANSFER:
<span class="nc" id="L426">          return new R66PreparedTransferExecutor(replaced,</span>
<span class="nc" id="L427">                                                 executor.getPretrDelay(),</span>
                                                 futureCompletion);
        default:
<span class="nc" id="L430">          return new NoTaskExecutor(replaced, executor.getPretrDelay(),</span>
                                    futureCompletion);
      }
    }
  }

  /**
   * @param command
   * @param args as {User, Account, BaseDir, FilePath(relative to
   *     BaseDir),
   *     Command}
   *
   * @return the prepared command
   */
  public static String getPreparedCommand(String command, String[] args) {
<span class="fc" id="L445">    final StringBuilder builder = new StringBuilder(command);</span>
<span class="fc" id="L446">    logger.debug(&quot;Will replace value in &quot; + command + &quot; with User=&quot; + args[0] +</span>
                 &quot;:Acct=&quot; + args[1] + &quot;:Base=&quot; + args[2] + &quot;:File=&quot; + args[3] +
                 &quot;:Cmd=&quot; + args[4]);
<span class="fc" id="L449">    replaceAll(builder, USER, args[0]);</span>
<span class="fc" id="L450">    replaceAll(builder, ACCOUNT, args[1]);</span>
<span class="fc" id="L451">    replaceAll(builder, BASEPATH, args[2]);</span>
<span class="fc" id="L452">    replaceAll(builder, FILE, args[3]);</span>
<span class="fc" id="L453">    replaceAll(builder, COMMAND, args[4]);</span>
<span class="fc" id="L454">    replaceAll(builder, SPECIALID, args[5]);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    if (builder.indexOf(sUUID) &gt; 0) {</span>
<span class="nc" id="L456">      replaceAll(builder, sUUID, new GUID().toString());</span>
    }
<span class="fc" id="L458">    logger.debug(&quot;Result: {}&quot;, builder);</span>
<span class="fc" id="L459">    return builder.toString();</span>
  }

  /**
   * Make a replacement of first &quot;find&quot; string by &quot;replace&quot; string into the
   * StringBuilder
   *
   * @param builder
   * @param find
   * @param replace
   */
  public static boolean replace(StringBuilder builder, String find,
                                String replace) {
<span class="fc" id="L472">    final int start = builder.indexOf(find);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">    if (start == -1) {</span>
<span class="fc" id="L474">      return false;</span>
    }
<span class="nc" id="L476">    final int end = start + find.length();</span>
<span class="nc" id="L477">    builder.replace(start, end, replace);</span>
<span class="nc" id="L478">    return true;</span>
  }

  /**
   * Make replacement of all &quot;find&quot; string by &quot;replace&quot; string into the
   * StringBuilder
   *
   * @param builder
   * @param find
   * @param replace
   */
  public static void replaceAll(StringBuilder builder, String find,
                                String replace) {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    while (replace(builder, find, replace)) {</span>
      // nothing
    }
<span class="fc" id="L494">  }</span>

  public static CommandExecutor getCommandExecutor() {
<span class="fc" id="L497">    return commandExecutor;</span>
  }

  public abstract void run() throws CommandAbstractException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>