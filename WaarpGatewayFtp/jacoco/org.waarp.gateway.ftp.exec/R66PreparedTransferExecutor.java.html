<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>R66PreparedTransferExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.ftp.exec</a> &gt; <span class="el_source">R66PreparedTransferExecutor.java</span></div><h1>R66PreparedTransferExecutor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */


package org.waarp.gateway.ftp.exec;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.command.exception.Reply421Exception;
import org.waarp.common.database.DbSession;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.future.WaarpFuture;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.openr66.client.TransferArgs;
import org.waarp.openr66.database.data.DbRule;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.PartnerConfiguration;
import org.waarp.openr66.protocol.localhandler.packet.RequestPacket;

import java.io.File;

import static org.waarp.common.database.DbConstant.*;

/**
 * R66PreparedTransferExecutor class. If the command starts with &quot;REFUSED&quot;, the
 * command will be refused for
 * execution. If &quot;REFUSED&quot; is set, the command &quot;RETR&quot; or &quot;STOR&quot; like operations
 * will be stopped at starting of
 * command.
 * &lt;p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * Format is like r66send command in any order except &quot;-info&quot; which should be
 * the last item:&lt;br&gt;
 * &quot;-to Host -file FILE -rule RULE [-md5] [-nolog] [-start yyyyMMddHHmmss or
 * -delay (delay or +delay)] [-info INFO]&quot; &lt;br&gt;
 * &lt;br&gt;
 * INFO is the only one field that can contains blank character and MUST be
 * the last argument.&lt;br&gt;
 * &lt;br&gt;
 * The following replacement are done dynamically before the command is
 * executed:&lt;br&gt;
 * - #BASEPATH# is replaced by the full path for the root of FTP Directory&lt;br&gt;
 * - #FILE# is replaced by the current file path relative to FTP Directory (so
 * #BASEPATH##FILE# is the full
 * path of the file)&lt;br&gt;
 * - #USER# is replaced by the username&lt;br&gt;
 * - #ACCOUNT# is replaced by the account&lt;br&gt;
 * - #COMMAND# is replaced by the command issued for the file&lt;br&gt;
 * - #SPECIALID# is replaced by the FTP id of the transfer (whatever in or
 * out)&lt;br&gt;
 * - #UUID# is replaced by a special UUID globally unique for the transfer, in
 * general to be placed in -info
 * part (for instance ##UUID## giving #uuid#)&lt;br&gt;
 * &lt;br&gt;
 * So for instance &quot;-to Host -file #BASEPATH##FILE# -rule RULE [-md5] [-nolog]
 * [-delay +delay] [-info ##UUID##
 * #USER# #ACCOUNT# #COMMAND# INFO]&quot; &lt;br&gt;
 * will be a standard use of this function.
 */
public class R66PreparedTransferExecutor extends AbstractExecutor {
  private static final String CANNOT_GET_NEW_TASK = &quot;Cannot get new task\n    &quot;;

  /**
   * Internal Logger
   */
<span class="nc" id="L85">  private static final WaarpLogger logger =</span>
<span class="nc" id="L86">      WaarpLoggerFactory.getLogger(R66PreparedTransferExecutor.class);</span>

  protected final WaarpFuture future;
  protected final TransferArgs transferArgs;

  protected boolean nolog;

  protected DbSession dbsession;

  /**
   * Transfer arguments:&lt;br&gt;
   * &lt;br&gt;
   * -to &lt;arg&gt;        Specify the requested Host&lt;br&gt;
   * (-id &lt;arg&gt;|      Specify the id of transfer&lt;br&gt;
   * (-file &lt;arg&gt;     Specify the file path to operate on&lt;br&gt;
   * -rule &lt;arg&gt;))    Specify the Rule&lt;br&gt;
   * [-block &lt;arg&gt;]   Specify the block size&lt;br&gt;
   * [-nofollow]      Specify the transfer should not integrate a FOLLOW id&lt;br&gt;
   * [-md5]           Specify the option to have a hash computed for the
   * transfer&lt;br&gt;
   * [-delay &lt;arg&gt;]   Specify the delay time as an epoch time or '+' a delay in ms&lt;br&gt;
   * [-start &lt;arg&gt;]   Specify the start time as yyyyMMddHHmmss&lt;br&gt;
   * [-info &lt;arg&gt;)    Specify the transfer information (generally in last position)&lt;br&gt;
   * [-nolog]         Specify to not log anything included database once the
   * transfer is done&lt;br&gt;
   * [-notlogWarn |   Specify to log final result as Info if OK&lt;br&gt;
   * -logWarn]        Specify to log final result as Warn if OK&lt;br&gt;
   *
   * @param command transfer arguments
   * @param delay delay
   * @param futureCompletion future for completion
   */
  public R66PreparedTransferExecutor(String command, long delay,
<span class="nc" id="L119">                                     WaarpFuture futureCompletion) {</span>
<span class="nc" id="L120">    final String[] args = BLANK.split(command);</span>
<span class="nc" id="L121">    transferArgs = TransferArgs.getParamsInternal(0, args, false);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (transferArgs != null) {</span>
<span class="nc" id="L123">      TransferArgs.getAllInfo(transferArgs, 0, args, null);</span>
<span class="nc" id="L124">      nolog = transferArgs.isNolog();</span>
    }
<span class="nc" id="L126">    future = futureCompletion;</span>
<span class="nc" id="L127">  }</span>

  /**
   * @param dbsession the dbsession to set
   */
  public void setDbsession(DbSession dbsession) {
<span class="nc" id="L133">    this.dbsession = dbsession;</span>
<span class="nc" id="L134">  }</span>

  @Override
  public void run() throws CommandAbstractException {
<span class="nc bnc" id="L138" title="All 2 branches missed.">    if (transferArgs == null) {</span>
<span class="nc" id="L139">      logger</span>
<span class="nc" id="L140">          .error(&quot;Mandatory argument is missing: -to  -rule  -file or -to -id&quot;);</span>
<span class="nc" id="L141">      throw new Reply421Exception(</span>
          &quot;Mandatory argument is missing: -to  -rule  -file or -to -id&quot;);
    }
<span class="nc bnc" id="L144" title="All 2 branches missed.">    if (transferArgs.getRemoteHost() == null ||</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        transferArgs.getRulename() == null ||</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        transferArgs.getFilename() == null) {</span>
<span class="nc" id="L147">      logger.error(</span>
<span class="nc" id="L148">          &quot;Mandatory argument is missing: -to &quot; + transferArgs.getRemoteHost() +</span>
<span class="nc" id="L149">          &quot; -rule &quot; + transferArgs.getRulename() + &quot; -file &quot; +</span>
<span class="nc" id="L150">          transferArgs.getFilename());</span>
<span class="nc" id="L151">      throw new Reply421Exception(&quot;Mandatory argument is missing&quot;);</span>
    }
<span class="nc" id="L153">    final String message =</span>
<span class="nc" id="L154">        &quot;R66Prepared with -to &quot; + transferArgs.getRemoteHost() + &quot; -rule &quot; +</span>
<span class="nc" id="L155">        transferArgs.getRulename() + &quot; -file &quot; + transferArgs.getFilename() +</span>
<span class="nc" id="L156">        &quot; -nolog: &quot; + nolog + &quot; -isMD5: &quot; + transferArgs.isMD5() + &quot; -info &quot; +</span>
<span class="nc" id="L157">        transferArgs.getTransferInfo();</span>
<span class="nc" id="L158">    logger.debug(message);</span>
    DbRule rule;
    try {
<span class="nc" id="L161">      rule = new DbRule(transferArgs.getRulename());</span>
<span class="nc" id="L162">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L163">      logger.error(</span>
<span class="nc" id="L164">          &quot;Cannot get Rule: &quot; + transferArgs.getRulename() + &quot; since {}\n    &quot; +</span>
<span class="nc" id="L165">          message, e.getMessage());</span>
<span class="nc" id="L166">      throw new Reply421Exception(</span>
<span class="nc" id="L167">          &quot;Cannot get Rule: &quot; + transferArgs.getRulename() + &quot;\n    &quot; +</span>
          message);
<span class="nc" id="L169">    }</span>
<span class="nc" id="L170">    int mode = rule.getMode();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (transferArgs.isMD5()) {</span>
<span class="nc" id="L172">      mode = RequestPacket.getModeMD5(mode);</span>
    }
<span class="nc" id="L174">    final String sep =</span>
<span class="nc" id="L175">        PartnerConfiguration.getSeparator(transferArgs.getRemoteHost());</span>
<span class="nc" id="L176">    long originalSize = -1;</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">    if (RequestPacket.isSendMode(mode) &amp;&amp; !RequestPacket.isThroughMode(mode)) {</span>
<span class="nc" id="L178">      final File file = new File(transferArgs.getFilename());</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (file.canRead()) {</span>
<span class="nc" id="L180">        originalSize = file.length();</span>
      }
    }
<span class="nc" id="L183">    final RequestPacket request =</span>
<span class="nc" id="L184">        new RequestPacket(transferArgs.getRulename(), mode,</span>
<span class="nc" id="L185">                          transferArgs.getFilename(),</span>
<span class="nc" id="L186">                          transferArgs.getBlockSize(), 0, ILLEGALVALUE,</span>
<span class="nc" id="L187">                          transferArgs.getTransferInfo(), originalSize, sep);</span>
    // Not isRecv since it is the requester, so send =&gt; isRetrieve is true
<span class="nc bnc" id="L189" title="All 2 branches missed.">    final boolean isRetrieve = !RequestPacket.isRecvMode(request.getMode());</span>
<span class="nc" id="L190">    logger.debug(&quot;Will prepare: {}&quot;, request);</span>
    DbTaskRunner taskRunner;
    try {
<span class="nc" id="L193">      taskRunner = new DbTaskRunner(rule, isRetrieve, request,</span>
<span class="nc" id="L194">                                    transferArgs.getRemoteHost(),</span>
<span class="nc" id="L195">                                    transferArgs.getStartTime());</span>
<span class="nc" id="L196">    } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L197">      logger.error(&quot;Cannot get new task since {}\n    &quot; + message,</span>
<span class="nc" id="L198">                   e.getMessage());</span>
<span class="nc" id="L199">      throw new Reply421Exception(CANNOT_GET_NEW_TASK + message);</span>
<span class="nc" id="L200">    }</span>
<span class="nc" id="L201">    taskRunner.changeUpdatedInfo(UpdatedInfo.TOSUBMIT);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">    if (!taskRunner.forceSaveStatus()) {</span>
      try {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (!taskRunner.specialSubmit()) {</span>
<span class="nc" id="L205">          logger.error(&quot;Cannot prepare task: &quot; + message);</span>
<span class="nc" id="L206">          throw new Reply421Exception(CANNOT_GET_NEW_TASK + message);</span>
        }
<span class="nc" id="L208">      } catch (final WaarpDatabaseException e) {</span>
<span class="nc" id="L209">        logger.error(&quot;Cannot prepare task since {}\n    &quot; + message,</span>
<span class="nc" id="L210">                     e.getMessage());</span>
<span class="nc" id="L211">        throw new Reply421Exception(CANNOT_GET_NEW_TASK + message);</span>
<span class="nc" id="L212">      }</span>
    }
<span class="nc" id="L214">    logger.debug(&quot;R66PreparedTransfer prepared: {}&quot;, request);</span>
<span class="nc" id="L215">    future.setSuccess();</span>
<span class="nc" id="L216">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>