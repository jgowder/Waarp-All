<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileBasedConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.ftp.config</a> &gt; <span class="el_source">FileBasedConfiguration.java</span></div><h1>FileBasedConfiguration.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.gateway.ftp.config;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.ChannelGroupFuture;
import io.netty.channel.group.ChannelGroupFutureListener;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.traffic.AbstractTrafficShapingHandler;
import io.netty.util.concurrent.EventExecutorGroup;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.waarp.common.crypto.Des;
import org.waarp.common.crypto.ssl.WaarpSecureKeyStore;
import org.waarp.common.crypto.ssl.WaarpSslContextFactory;
import org.waarp.common.database.DbAdmin;
import org.waarp.common.database.DbPreparedStatement;
import org.waarp.common.database.exception.WaarpDatabaseNoConnectionException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.exception.CryptoException;
import org.waarp.common.exception.InvalidArgumentException;
import org.waarp.common.file.AbstractDir;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.FileParameterInterface;
import org.waarp.common.file.filesystembased.FilesystemBasedFileParameterImpl;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedDirJdkAbstract;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.common.utility.WaarpThreadFactory;
import org.waarp.common.xml.XmlDecl;
import org.waarp.common.xml.XmlHash;
import org.waarp.common.xml.XmlType;
import org.waarp.common.xml.XmlUtil;
import org.waarp.common.xml.XmlValue;
import org.waarp.ftp.core.config.FtpConfiguration;
import org.waarp.ftp.core.control.BusinessHandler;
import org.waarp.ftp.core.control.ftps.FtpsInitializer;
import org.waarp.ftp.core.data.handler.DataBusinessHandler;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.exception.FtpUnknownFieldException;
import org.waarp.gateway.ftp.adminssl.HttpSslInitializer;
import org.waarp.gateway.ftp.control.FtpConstraintLimitHandler;
import org.waarp.gateway.ftp.database.DbConstantFtp;
import org.waarp.gateway.ftp.database.data.DbTransferLog;
import org.waarp.gateway.ftp.database.model.DbModelFactoryFtp;
import org.waarp.gateway.ftp.exec.AbstractExecutor;
import org.waarp.gateway.ftp.exec.LocalExecClient;
import org.waarp.gateway.ftp.file.SimpleAuth;
import org.waarp.gateway.ftp.snmp.FtpMonitoring;
import org.waarp.gateway.ftp.snmp.FtpPrivateMib;
import org.waarp.gateway.ftp.snmp.FtpVariableFactory;
import org.waarp.snmp.SnmpConfiguration;
import org.waarp.snmp.WaarpMOFactory;
import org.waarp.snmp.WaarpSnmpAgent;

import java.io.File;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * FtpConfiguration based on a XML file
 */
public class FileBasedConfiguration extends FtpConfiguration {
  private static final String ERROR_DURING_WRITE_AUTHENTICATION_FILE =
      &quot;Error during Write Authentication file&quot;;

  private static final String UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE =
      &quot;Unable to find LocalExec Address in Config file&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L105">  private static final WaarpLogger logger =</span>
<span class="fc" id="L106">      WaarpLoggerFactory.getLogger(FileBasedConfiguration.class);</span>

  /**
   * SERVER HOSTID
   */
  private static final String XML_SERVER_HOSTID = &quot;hostid&quot;;
  /**
   * Authentication
   */
  private static final String XML_AUTHENTIFICATION_FILE = &quot;authentfile&quot;;
  /**
   * SERVER CRYPTO for Password
   */
  private static final String XML_PATH_CRYPTOKEY = &quot;cryptokey&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L124">  private static final XmlDecl[] configIdentityDecls = {</span>
      // identity
      new XmlDecl(XmlType.STRING, XML_SERVER_HOSTID),
      new XmlDecl(XmlType.STRING, XML_PATH_CRYPTOKEY),
      new XmlDecl(XmlType.STRING, XML_AUTHENTIFICATION_FILE)
  };
  /**
   * Use HTTP compression for R66 HTTP connection
   */
  private static final String XML_USEHTTPCOMP = &quot;usehttpcomp&quot;;
  /**
   * Use external Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_USELOCALEXEC = &quot;uselocalexec&quot;;

  /**
   * Address of Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_LEXECADDR = &quot;lexecaddr&quot;;

  /**
   * Port of Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_LEXECPORT = &quot;lexecport&quot;;
  /**
   * ADMINISTRATOR SERVER NAME (shutdown)
   */
  private static final String XML_SERVER_ADMIN = &quot;serveradmin&quot;;
  /**
   * SERVER PASSWORD (shutdown)
   */
  private static final String XML_SERVER_PASSWD = &quot;serverpasswd&quot;; //NOSONAR
  /**
   * SERVER SSL STOREKEY PATH ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYPATH = &quot;admkeypath&quot;;

  /**
   * SERVER SSL KEY PASS ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYPASS = &quot;admkeypass&quot;;

  /**
   * SERVER SSL STOREKEY PASS ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYSTOREPASS = &quot;admkeystorepass&quot;;
  /**
   * HTTP Admin Directory
   */
  private static final String XML_HTTPADMINPATH = &quot;httpadmin&quot;;
  /**
   * Monitoring: snmp configuration file (if empty, no snmp support)
   */
  private static final String XML_MONITOR_SNMP_CONFIG = &quot;snmpconfig&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L182">  private static final XmlDecl[] configServerParamDecls = {</span>
      // server
      new XmlDecl(XmlType.BOOLEAN, XML_USELOCALEXEC),
      new XmlDecl(XmlType.STRING, XML_LEXECADDR),
      new XmlDecl(XmlType.INTEGER, XML_LEXECPORT),
      new XmlDecl(XmlType.STRING, XML_SERVER_ADMIN),
      new XmlDecl(XmlType.STRING, XML_SERVER_PASSWD),
      new XmlDecl(XmlType.BOOLEAN, XML_USEHTTPCOMP),
      new XmlDecl(XmlType.STRING, XML_HTTPADMINPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYSTOREPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYPASS),
      new XmlDecl(XmlType.STRING, XML_MONITOR_SNMP_CONFIG)
  };
  /**
   * SERVER PORT
   */
  private static final String XML_SERVER_PORT = &quot;serverport&quot;;
  /**
   * SERVER ADDRESS if any
   */
  private static final String XML_SERVER_ADDRESS = &quot;serveraddress&quot;;
  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String XML_RANGE_PORT_MIN = &quot;portmin&quot;;

  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String XML_RANGE_PORT_MAX = &quot;portmax&quot;;
  /**
   * SERVER HTTP PORT MONITORING
   */
  private static final String XML_SERVER_HTTP_PORT = &quot;serverhttpport&quot;;
  /**
   * SERVER HTTPS PORT ADMINISTRATION
   */
  private static final String XML_SERVER_HTTPS_PORT = &quot;serverhttpsport&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L225">  private static final XmlDecl[] configNetworkServerDecls = {</span>
      // network
      new XmlDecl(XmlType.INTEGER, XML_SERVER_PORT),
      new XmlDecl(XmlType.STRING, XML_SERVER_ADDRESS),
      new XmlDecl(XmlType.INTEGER, XML_RANGE_PORT_MIN),
      new XmlDecl(XmlType.INTEGER, XML_RANGE_PORT_MAX),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_HTTP_PORT),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_HTTPS_PORT)
  };
  /**
   * Database Driver as of oracle, mysql, postgresql, h2
   */
  private static final String XML_DBDRIVER = &quot;dbdriver&quot;;

  /**
   * Database Server connection string as of jdbc:type://[host:port],[failoverhost:port]
   * .../[database][?propertyName1][ =propertyValue1][&amp;propertyName2][=propertyValue2]...
   */
  private static final String XML_DBSERVER = &quot;dbserver&quot;;

  /**
   * Database User
   */
  private static final String XML_DBUSER = &quot;dbuser&quot;;

  /**
   * Database Password
   */
  private static final String XML_DBPASSWD = &quot;dbpasswd&quot;;//NOSONAR
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L257">  private static final XmlDecl[] configDbDecls = {</span>
      // db
      new XmlDecl(XmlType.STRING, XML_DBDRIVER),
      new XmlDecl(XmlType.STRING, XML_DBSERVER),
      new XmlDecl(XmlType.STRING, XML_DBUSER),
      new XmlDecl(XmlType.STRING, XML_DBPASSWD)
  };
  /**
   * Should a file be deleted when a Store like command is aborted
   */
  private static final String XML_DELETEONABORT = &quot;deleteonabort&quot;;
  /**
   * Default number of threads in pool for Server.
   */
  private static final String XML_SERVER_THREAD = &quot;serverthread&quot;;

  /**
   * Default number of threads in pool for Client.
   */
  private static final String XML_CLIENT_THREAD = &quot;clientthread&quot;;
  /**
   * Memory Limit to use.
   */
  private static final String XML_MEMORY_LIMIT = &quot;memorylimit&quot;;

  /**
   * Limit for Session
   */
  private static final String XML_LIMITSESSION = &quot;sessionlimit&quot;;

  /**
   * Limit for Global
   */
  private static final String XML_LIMITGLOBAL = &quot;globallimit&quot;;
  /**
   * Delay between two checks for Limit
   */
  private static final String XML_LIMITDELAY = &quot;delaylimit&quot;;
  /**
   * Nb of milliseconds after connection is in timeout
   */
  private static final String XML_TIMEOUTCON = &quot;timeoutcon&quot;;
  /**
   * Size by default of block size for receive/sending files. Should be a
   * multiple of 8192 (maximum = 64K due to
   * block limitation to 2 bytes)
   */
  private static final String XML_BLOCKSIZE = &quot;blocksize&quot;;
  /**
   * Should a file MD5 SHA1 be computed using NIO
   */
  private static final String XML_USENIO = &quot;usenio&quot;;

  /**
   * Should a file MD5 be computed using FastMD5
   */
  private static final String XML_USEFASTMD5 = &quot;usefastmd5&quot;;

  /**
   * If using Fast MD5, should we used the binary JNI library, empty meaning
   * no
   */
  private static final String XML_FASTMD5 = &quot;fastmd5&quot;;
  /**
   * Usage of CPU Limit
   */
  private static final String XML_CSTRT_USECPULIMIT = &quot;usecpulimit&quot;;

  /**
   * Usage of JDK CPU Limit (True) or SysMon CPU Limit
   */
  private static final String XML_CSTRT_USECPUJDKLIMIT = &quot;usejdkcpulimit&quot;;

  /**
   * CPU LIMIT between 0 and 1, where 1 stands for no limit
   */
  private static final String XML_CSTRT_CPULIMIT = &quot;cpulimit&quot;;
  /**
   * Connection limit where 0 stands for no limit
   */
  private static final String XML_CSTRT_CONNLIMIT = &quot;connlimit&quot;;
  /**
   * CPU LOW limit to apply increase of throttle
   */
  private static final String XML_CSTRT_LOWCPULIMIT = &quot;lowcpulimit&quot;;
  /**
   * CPU HIGH limit to apply decrease of throttle, 0 meaning no throttle
   * activated
   */
  private static final String XML_CSTRT_HIGHCPULIMIT = &quot;highcpulimit&quot;;
  /**
   * PERCENTAGE DECREASE of Bandwidth
   */
  private static final String XML_CSTRT_PERCENTDECREASE = &quot;percentdecrease&quot;;
  /**
   * Delay between 2 checks of throttle test
   */
  private static final String XML_CSTRT_DELAYTHROTTLE = &quot;delaythrottle&quot;;
  /**
   * Bandwidth low limit to not got below
   */
  private static final String XML_CSTRT_LIMITLOWBANDWIDTH = &quot;limitlowbandwidth&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L362">  private static final XmlDecl[] configLimitDecls = {</span>
      // limit
      new XmlDecl(XmlType.BOOLEAN, XML_DELETEONABORT),
      new XmlDecl(XmlType.LONG, XML_LIMITSESSION),
      new XmlDecl(XmlType.LONG, XML_LIMITGLOBAL),
      new XmlDecl(XmlType.LONG, XML_LIMITDELAY),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_THREAD),
      new XmlDecl(XmlType.INTEGER, XML_CLIENT_THREAD),
      new XmlDecl(XmlType.LONG, XML_MEMORY_LIMIT),
      new XmlDecl(XmlType.BOOLEAN, XML_CSTRT_USECPULIMIT),
      new XmlDecl(XmlType.BOOLEAN, XML_CSTRT_USECPUJDKLIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_CPULIMIT),
      new XmlDecl(XmlType.INTEGER, XML_CSTRT_CONNLIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_LOWCPULIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_HIGHCPULIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_PERCENTDECREASE),
      new XmlDecl(XmlType.LONG, XML_CSTRT_LIMITLOWBANDWIDTH),
      new XmlDecl(XmlType.LONG, XML_CSTRT_DELAYTHROTTLE),
      new XmlDecl(XmlType.LONG, XML_TIMEOUTCON),
      new XmlDecl(XmlType.BOOLEAN, XML_USENIO),
      new XmlDecl(XmlType.BOOLEAN, XML_USEFASTMD5),
      new XmlDecl(XmlType.STRING, XML_FASTMD5),
      new XmlDecl(XmlType.INTEGER, XML_BLOCKSIZE)
  };

  /**
   * RETRIEVE COMMAND
   */
  public static final String XML_RETRIEVE_COMMAND = &quot;retrievecmd&quot;;

  /**
   * STORE COMMAND
   */
  public static final String XML_STORE_COMMAND = &quot;storecmd&quot;;

  /**
   * DELAY RETRIEVE COMMAND
   */
  public static final String XML_DELAYRETRIEVE_COMMAND = &quot;retrievedelay&quot;;

  /**
   * DELAY STORE COMMAND
   */
  public static final String XML_DELAYSTORE_COMMAND = &quot;storedelay&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L409">  private static final XmlDecl[] configExecDecls = {</span>
      // Exec
      new XmlDecl(XmlType.STRING, XML_RETRIEVE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYRETRIEVE_COMMAND),
      new XmlDecl(XmlType.STRING, XML_STORE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYSTORE_COMMAND)
  };
  /**
   * Base Directory
   */
  private static final String XML_SERVER_HOME = &quot;serverhome&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L423">  private static final XmlDecl[] configDirectoryDecls = {</span>
      // directory
      new XmlDecl(XmlType.STRING, XML_SERVER_HOME)
  };
  /**
   * SERVER SSL STOREKEY PATH
   */
  private static final String XML_PATH_KEYPATH = &quot;keypath&quot;;

  /**
   * SERVER SSL KEY PASS
   */
  private static final String XML_PATH_KEYPASS = &quot;keypass&quot;;

  /**
   * SERVER SSL STOREKEY PASS
   */
  private static final String XML_PATH_KEYSTOREPASS = &quot;keystorepass&quot;;

  /**
   * SERVER SSL TRUSTSTOREKEY PATH
   */
  private static final String XML_PATH_TRUSTKEYPATH = &quot;trustkeypath&quot;;

  /**
   * SERVER SSL TRUSTSTOREKEY PASS
   */
  private static final String XML_PATH_TRUSTKEYSTOREPASS = &quot;trustkeystorepass&quot;;

  /**
   * SERVER SSL Use TrustStore for Client Authentication
   */
  private static final String XML_USECLIENT_AUTHENT =
      &quot;trustuseclientauthenticate&quot;;
  /**
   * SERVER SSL Use Implicit FTPS
   */
  private static final String XML_IMPLICIT_FTPS = &quot;useimplicitftps&quot;;
  /**
   * SERVER SSL Use Explicit FTPS
   */
  private static final String XML_EXPLICIT_FTPS = &quot;useexplicitftps&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L469">  private static final XmlDecl[] configSslDecls = {</span>
      // ssl
      new XmlDecl(XmlType.STRING, XML_PATH_KEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_KEYSTOREPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_KEYPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_TRUSTKEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_TRUSTKEYSTOREPASS),
      new XmlDecl(XmlType.BOOLEAN, XML_USECLIENT_AUTHENT),
      new XmlDecl(XmlType.BOOLEAN, XML_IMPLICIT_FTPS),
      new XmlDecl(XmlType.BOOLEAN, XML_EXPLICIT_FTPS)
  };
  /**
   * Overall structure of the Configuration file
   */
  private static final String XML_ROOT = &quot;/config/&quot;;
  private static final String XML_IDENTITY = &quot;identity&quot;;
  private static final String XML_SERVER = &quot;server&quot;;
  private static final String XML_DIRECTORY = &quot;directory&quot;;
  private static final String XML_LIMIT = &quot;limit&quot;;
  private static final String XML_NETWORK = &quot;network&quot;;
  private static final String XML_EXEC = &quot;exec&quot;;
  private static final String XML_DB = &quot;db&quot;;
  private static final String XML_SSL = &quot;ssl&quot;;
  /**
   * Global Structure for Server Configuration
   */
<span class="fc" id="L495">  private static final XmlDecl[] configServer = {</span>
      new XmlDecl(XML_IDENTITY, XmlType.XVAL, XML_ROOT + XML_IDENTITY,
                  configIdentityDecls, false),
      new XmlDecl(XML_SERVER, XmlType.XVAL, XML_ROOT + XML_SERVER,
                  configServerParamDecls, false),
      new XmlDecl(XML_NETWORK, XmlType.XVAL, XML_ROOT + XML_NETWORK,
                  configNetworkServerDecls, false),
      new XmlDecl(XML_EXEC, XmlType.XVAL, XML_ROOT + XML_EXEC, configExecDecls,
                  false),
      new XmlDecl(XML_DIRECTORY, XmlType.XVAL, XML_ROOT + XML_DIRECTORY,
                  configDirectoryDecls, false),
      new XmlDecl(XML_LIMIT, XmlType.XVAL, XML_ROOT + XML_LIMIT,
                  configLimitDecls, false),
      new XmlDecl(XML_DB, XmlType.XVAL, XML_ROOT + XML_DB, configDbDecls,
                  false),
      new XmlDecl(XML_SSL, XmlType.XVAL, XML_ROOT + XML_SSL, configSslDecls,
                  false)
  };

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_ROOT = &quot;authent&quot;;
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_ENTRY = &quot;entry&quot;;
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_BASED =
      '/' + XML_AUTHENTIFICATION_ROOT + '/' + XML_AUTHENTIFICATION_ENTRY;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_USER = &quot;user&quot;;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_PASSWD = &quot;passwd&quot;;//NOSONAR
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_PASSWDFILE = //NOSONAR
      &quot;passwdfile&quot;;//NOSONAR

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_ACCOUNT = &quot;account&quot;;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_ADMIN = &quot;admin&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L555">  private static final XmlDecl[] configAuthenticationDecls = {</span>
      // identity
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_USER),
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_PASSWDFILE),
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_PASSWD),
      new XmlDecl(XML_AUTHENTICATION_ACCOUNT, XmlType.STRING,
                  XML_AUTHENTICATION_ACCOUNT, true),
      new XmlDecl(XmlType.BOOLEAN, XML_AUTHENTICATION_ADMIN),
      // Exec
      new XmlDecl(XmlType.STRING, XML_RETRIEVE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYRETRIEVE_COMMAND),
      new XmlDecl(XmlType.STRING, XML_STORE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYSTORE_COMMAND)
  };
  /**
   * Global Structure for Server Configuration
   */
<span class="fc" id="L572">  private static final XmlDecl[] authentElements = {</span>
      new XmlDecl(XML_AUTHENTIFICATION_ENTRY, XmlType.XVAL,
                  XML_AUTHENTIFICATION_BASED, configAuthenticationDecls, true)
  };

  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String RANGE_PORT = &quot;FTP_RANGE_PORT&quot;;
  /**
   * Use to access directly the configuration
   */
  public static FileBasedConfiguration fileBasedConfiguration;
  /**
   * All authentications
   */
<span class="fc" id="L588">  private final ConcurrentHashMap&lt;String, SimpleAuth&gt; authentications =</span>
      new ConcurrentHashMap&lt;String, SimpleAuth&gt;();

  /**
   * File containing the authentications
   */
  private String authenticationFile;

  /**
   * Default HTTP server port
   */
<span class="fc" id="L599">  private int serverHttpsPort = 8067;</span>
  /**
   * Http Admin base
   */
<span class="fc" id="L603">  private String httpBasePath = &quot;src/main/admin/&quot;;</span>
  /**
   * Does this server will try to compress HTTP connections
   */
  private boolean useHttpCompression;

  /**
   * Does this server will use Waarp LocalExec Daemon for Execute
   */
  private boolean useLocalExec;

  /**
   * Crypto Key
   */
  private Des cryptoKey;
  /**
   * Server Administration Key
   */
  private byte[] serverAdminKey;
  /**
   * FTP server ID
   */
<span class="fc" id="L625">  private String hostId = &quot;noId&quot;;</span>
  /**
   * Admin name Id
   */
<span class="fc" id="L629">  private String adminName = &quot;noAdmin&quot;;</span>
  /**
   * Limit on CPU and Connection
   */
  private FtpConstraintLimitHandler constraintLimitHandler;

  /**
   * List of all Http Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup httpChannelGroup;
  /**
   * Worker Group for Http
   */
  private EventLoopGroup workerGroup;

  /**
   * ThreadPoolExecutor for Http and Https Server
   */
  private EventExecutorGroup httpExecutor;
  /**
   * Monitoring: snmp configuration file (empty means no snmp support)
   */
  private String snmpConfig;
  /**
   * SNMP Agent (if any)
   */
  private WaarpSnmpAgent agentSnmp;
  /**
   * Associated MIB
   */
  private FtpPrivateMib ftpMib;
  /**
   * Monitoring object
   */
  private FtpMonitoring monitoring;

  /**
   * @param classtype
   * @param businessHandler class that will be used for
   *     BusinessHandler
   * @param dataBusinessHandler class that will be used for
   *     DataBusinessHandler
   * @param fileParameter the FileParameter to use
   */
  public FileBasedConfiguration(final Class&lt;?&gt; classtype,
                                final Class&lt;? extends BusinessHandler&gt; businessHandler,
                                final Class&lt;? extends DataBusinessHandler&gt; dataBusinessHandler,
                                final FileParameterInterface fileParameter) {
<span class="fc" id="L678">    super(classtype, businessHandler, dataBusinessHandler, fileParameter);</span>
<span class="fc" id="L679">    computeNbThreads();</span>
<span class="fc" id="L680">  }</span>

  private static XmlHash hashConfig;

  private boolean loadIdentity() {
<span class="fc" id="L685">    final XmlValue value = hashConfig.get(XML_SERVER_HOSTID);</span>
<span class="pc bpc" id="L686" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L687">      setHostId(value.getString());</span>
    } else {
<span class="nc" id="L689">      logger.error(&quot;Unable to find Host ID in Config file&quot;);</span>
<span class="nc" id="L690">      return false;</span>
    }
<span class="fc" id="L692">    return setCryptoKey();</span>
  }

  private boolean loadAuthentication() {
    // if no database, must load authentication from file
<span class="fc" id="L697">    final XmlValue value = hashConfig.get(XML_AUTHENTIFICATION_FILE);</span>
<span class="pc bpc" id="L698" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L699">      setAuthenticationFile(value.getString());</span>
<span class="fc" id="L700">      return initializeAuthent(getAuthenticationFile(), false);</span>
    } else {
<span class="nc" id="L702">      logger.warn(&quot;Unable to find Authentication file in Config file&quot;);</span>
<span class="nc" id="L703">      return false;</span>
    }
  }

  private boolean loadServerParam() {
<span class="fc" id="L708">    XmlValue value = hashConfig.get(XML_USEHTTPCOMP);</span>
<span class="pc bpc" id="L709" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L710">      setUseHttpCompression(value.getBoolean());</span>
    }
<span class="fc" id="L712">    value = hashConfig.get(XML_USELOCALEXEC);</span>
<span class="pc bpc" id="L713" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L714">      setUseLocalExec(value.getBoolean());</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">      if (isUseLocalExec()) {</span>
<span class="nc" id="L716">        value = hashConfig.get(XML_LEXECADDR);</span>
        final String saddr;
        final InetAddress addr;
<span class="nc bnc" id="L719" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L720">          saddr = value.getString();</span>
          try {
<span class="nc" id="L722">            addr = InetAddress.getByName(saddr);</span>
<span class="nc" id="L723">          } catch (final UnknownHostException e) {</span>
<span class="nc" id="L724">            logger.error(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
<span class="nc" id="L725">            return false;</span>
<span class="nc" id="L726">          }</span>
        } else {
<span class="nc" id="L728">          logger.warn(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
          try {
<span class="nc" id="L730">            addr = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 });</span>
<span class="nc" id="L731">          } catch (final UnknownHostException e) {</span>
<span class="nc" id="L732">            logger.error(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
<span class="nc" id="L733">            return false;</span>
<span class="nc" id="L734">          }</span>
        }
<span class="nc" id="L736">        value = hashConfig.get(XML_LEXECPORT);</span>
        final int port;
<span class="nc bnc" id="L738" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L739">          port = value.getInteger();</span>
        } else {
<span class="nc" id="L741">          port = 9999;</span>
        }
<span class="nc" id="L743">        LocalExecClient.setAddress(new InetSocketAddress(addr, port));</span>
      }
    }
<span class="fc" id="L746">    value = hashConfig.get(XML_SERVER_ADMIN);</span>
<span class="pc bpc" id="L747" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L748">      setAdminName(value.getString());</span>
    } else {
<span class="nc" id="L750">      logger.error(&quot;Unable to find Administrator name in Config file&quot;);</span>
<span class="nc" id="L751">      return false;</span>
    }
<span class="pc bpc" id="L753" title="3 of 4 branches missed.">    if (getCryptoKey() == null &amp;&amp; !setCryptoKey()) {</span>
<span class="nc" id="L754">      logger.error(&quot;Unable to find Crypto Key in Config file&quot;);</span>
<span class="nc" id="L755">      return false;</span>
    }
    final String passwd;
<span class="fc" id="L758">    value = hashConfig.get(XML_SERVER_PASSWD);</span>
<span class="pc bpc" id="L759" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L760">      passwd = value.getString();</span>
    } else {
<span class="nc" id="L762">      logger.error(&quot;Unable to find Password in Config file&quot;);</span>
<span class="nc" id="L763">      return false;</span>
    }
    final byte[] decodedByteKeys;
    try {
<span class="fc" id="L767">      decodedByteKeys = getCryptoKey().decryptHexInBytes(passwd);</span>
<span class="nc" id="L768">    } catch (final Exception e) {</span>
<span class="nc" id="L769">      logger.error(</span>
          &quot;Unable to Decrypt Server Password in Config file from: &quot; + passwd,
          e);
<span class="nc" id="L772">      return false;</span>
<span class="fc" id="L773">    }</span>
<span class="fc" id="L774">    setSERVERKEY(decodedByteKeys);</span>
<span class="fc" id="L775">    value = hashConfig.get(XML_HTTPADMINPATH);</span>
<span class="pc bpc" id="L776" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L777">      logger.error(&quot;Unable to find Http Admin Base in Config file&quot;);</span>
<span class="nc" id="L778">      return false;</span>
    }
<span class="fc" id="L780">    final String path = value.getString();</span>
<span class="pc bpc" id="L781" title="2 of 4 branches missed.">    if (path == null || path.length() == 0) {</span>
<span class="nc" id="L782">      logger.warn(</span>
          &quot;Unable to set correct Http Admin Base in Config file. No HTTPS support will be used.&quot;);
<span class="nc" id="L784">      setHttpBasePath(null);</span>
    } else {
<span class="fc" id="L786">      final File file = new File(path);</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">      if (!file.isDirectory()) {</span>
<span class="nc" id="L788">        logger.error(&quot;Http Admin is not a directory in Config file&quot;);</span>
<span class="nc" id="L789">        return false;</span>
      }
      try {
<span class="fc" id="L792">        setHttpBasePath(AbstractDir.normalizePath(file.getCanonicalPath()) +</span>
                        DirInterface.SEPARATOR);
<span class="nc" id="L794">      } catch (final IOException e1) {</span>
<span class="nc" id="L795">        logger.error(&quot;Unable to set Http Admin Path in Config file&quot;);</span>
<span class="nc" id="L796">        return false;</span>
<span class="fc" id="L797">      }</span>
    }
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">    if (getHttpBasePath() != null) {</span>
      // Key for HTTPS
<span class="fc" id="L801">      value = hashConfig.get(XML_PATH_ADMIN_KEYPATH);</span>
<span class="pc bpc" id="L802" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L803">        final String keypath = value.getString();</span>
<span class="pc bpc" id="L804" title="2 of 4 branches missed.">        if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L805">          logger.error(&quot;Bad Key Path&quot;);</span>
<span class="nc" id="L806">          return false;</span>
        }
<span class="fc" id="L808">        value = hashConfig.get(XML_PATH_ADMIN_KEYSTOREPASS);</span>
<span class="pc bpc" id="L809" title="2 of 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L810">          logger.error(&quot;Unable to find KeyStore Passwd&quot;);</span>
<span class="nc" id="L811">          return false;</span>
        }
<span class="fc" id="L813">        final String keystorepass = value.getString();</span>
<span class="pc bpc" id="L814" title="2 of 4 branches missed.">        if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L815">          logger.error(&quot;Bad KeyStore Passwd&quot;);</span>
<span class="nc" id="L816">          return false;</span>
        }
<span class="fc" id="L818">        value = hashConfig.get(XML_PATH_ADMIN_KEYPASS);</span>
<span class="pc bpc" id="L819" title="2 of 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L820">          logger.error(&quot;Unable to find Key Passwd&quot;);</span>
<span class="nc" id="L821">          return false;</span>
        }
<span class="fc" id="L823">        final String keypass = value.getString();</span>
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">        if (keypass == null || keypass.length() == 0) {</span>
<span class="nc" id="L825">          logger.error(&quot;Bad Key Passwd&quot;);</span>
<span class="nc" id="L826">          return false;</span>
        }
        try {
<span class="fc" id="L829">          HttpSslInitializer.waarpSecureKeyStore =</span>
              new WaarpSecureKeyStore(keypath, keystorepass, keypass);
<span class="nc" id="L831">        } catch (final CryptoException e) {</span>
<span class="nc" id="L832">          logger.error(&quot;Bad SecureKeyStore construction for AdminSsl&quot;);</span>
<span class="nc" id="L833">          return false;</span>
<span class="fc" id="L834">        }</span>
        // No client authentication
<span class="fc" id="L836">        HttpSslInitializer.waarpSecureKeyStore.initEmptyTrustStore();</span>
<span class="fc" id="L837">        HttpSslInitializer.waarpSslContextFactory =</span>
            new WaarpSslContextFactory(HttpSslInitializer.waarpSecureKeyStore,
                                       true);
      }
    }
<span class="fc" id="L842">    value = hashConfig.get(XML_MONITOR_SNMP_CONFIG);</span>
<span class="pc bpc" id="L843" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L844">      setSnmpConfig(value.getString());</span>
<span class="fc" id="L845">      logger.warn(&quot;SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="fc" id="L846">      final File snmpfile = new File(getSnmpConfig());</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">      if (snmpfile.canRead()) {</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">        if (!SnmpConfiguration.setConfigurationFromXml(snmpfile)) {</span>
<span class="nc" id="L849">          logger.warn(&quot;Bad SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="nc" id="L850">          setSnmpConfig(null);</span>
        }
      } else {
<span class="nc" id="L853">        logger.warn(&quot;Cannot read SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="nc" id="L854">        setSnmpConfig(null);</span>
      }
<span class="fc" id="L856">    } else {</span>
<span class="nc" id="L857">      logger.warn(&quot;NO SNMP configuration file&quot;);</span>
    }
<span class="fc" id="L859">    return true;</span>
  }

  private boolean loadDirectory() {
<span class="fc" id="L863">    final XmlValue value = hashConfig.get(XML_SERVER_HOME);</span>
<span class="pc bpc" id="L864" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L865">      logger.error(&quot;Unable to find Home in Config file&quot;);</span>
<span class="nc" id="L866">      return false;</span>
    }
<span class="fc" id="L868">    final String path = value.getString();</span>
<span class="fc" id="L869">    final File file = new File(path);</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">    if (!file.isDirectory()) {</span>
<span class="nc" id="L871">      logger.error(&quot;Home is not a directory in Config file&quot;);</span>
<span class="nc" id="L872">      return false;</span>
    }
    try {
<span class="fc" id="L875">      setBaseDirectory(AbstractDir.normalizePath(file.getCanonicalPath()));</span>
<span class="nc" id="L876">    } catch (final IOException e1) {</span>
<span class="nc" id="L877">      logger.error(&quot;Unable to set Home in Config file: &quot; + path);</span>
<span class="nc" id="L878">      return false;</span>
<span class="fc" id="L879">    }</span>
<span class="fc" id="L880">    return true;</span>
  }

  private boolean loadLimit() {
<span class="fc" id="L884">    XmlValue value = hashConfig.get(XML_LIMITGLOBAL);</span>
<span class="pc bpc" id="L885" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L886">      serverGlobalReadLimit = value.getLong();</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">      if (serverGlobalReadLimit &lt;= 0) {</span>
<span class="fc" id="L888">        serverGlobalReadLimit = 0;</span>
      }
<span class="fc" id="L890">      serverGlobalWriteLimit = serverGlobalReadLimit;</span>
<span class="fc" id="L891">      logger.info(&quot;Global Limit: {}&quot;, serverGlobalReadLimit);</span>
    }
<span class="fc" id="L893">    value = hashConfig.get(XML_LIMITSESSION);</span>
<span class="pc bpc" id="L894" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L895">      serverChannelReadLimit = value.getLong();</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">      if (serverChannelReadLimit &lt;= 0) {</span>
<span class="fc" id="L897">        serverChannelReadLimit = 0;</span>
      }
<span class="fc" id="L899">      serverChannelWriteLimit = serverChannelReadLimit;</span>
<span class="fc" id="L900">      logger.info(&quot;SessionInterface Limit: {}&quot;, serverChannelReadLimit);</span>
    }
<span class="fc" id="L902">    delayLimit = AbstractTrafficShapingHandler.DEFAULT_CHECK_INTERVAL;</span>
<span class="fc" id="L903">    value = hashConfig.get(XML_LIMITDELAY);</span>
<span class="pc bpc" id="L904" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L905">      delayLimit = (value.getLong() / 10) * 10;</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">      if (delayLimit &lt;= 0) {</span>
<span class="nc" id="L907">        delayLimit = 0;</span>
      }
<span class="fc" id="L909">      logger.info(&quot;Delay Limit: {}&quot;, delayLimit);</span>
    }
<span class="fc" id="L911">    boolean useCpuLimit = false;</span>
<span class="fc" id="L912">    boolean useCpuLimitJDK = false;</span>
<span class="fc" id="L913">    double cpulimit = 1.0;</span>
<span class="fc" id="L914">    value = hashConfig.get(XML_CSTRT_USECPULIMIT);</span>
<span class="pc bpc" id="L915" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L916">      useCpuLimit = value.getBoolean();</span>
<span class="fc" id="L917">      value = hashConfig.get(XML_CSTRT_USECPUJDKLIMIT);</span>
<span class="pc bpc" id="L918" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L919">        useCpuLimitJDK = value.getBoolean();</span>
      }
<span class="fc" id="L921">      value = hashConfig.get(XML_CSTRT_CPULIMIT);</span>
<span class="pc bpc" id="L922" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L923">        cpulimit = value.getDouble();</span>
      }
    }
<span class="fc" id="L926">    int connlimit = 0;</span>
<span class="fc" id="L927">    value = hashConfig.get(XML_CSTRT_CONNLIMIT);</span>
<span class="pc bpc" id="L928" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L929">      connlimit = value.getInteger();</span>
    }
<span class="fc" id="L931">    double lowcpuLimit = 0;</span>
<span class="fc" id="L932">    double highcpuLimit = 0;</span>
<span class="fc" id="L933">    double percentageDecrease = 0;</span>
<span class="fc" id="L934">    long delay = 1000000;</span>
<span class="fc" id="L935">    long limitLowBandwidth = 4096;</span>
<span class="fc" id="L936">    value = hashConfig.get(XML_CSTRT_LOWCPULIMIT);</span>
<span class="pc bpc" id="L937" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L938">      lowcpuLimit = value.getDouble();</span>
    }
<span class="fc" id="L940">    value = hashConfig.get(XML_CSTRT_HIGHCPULIMIT);</span>
<span class="pc bpc" id="L941" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L942">      highcpuLimit = value.getDouble();</span>
    }
<span class="fc" id="L944">    value = hashConfig.get(XML_CSTRT_PERCENTDECREASE);</span>
<span class="pc bpc" id="L945" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L946">      percentageDecrease = value.getDouble();</span>
    }
<span class="fc" id="L948">    value = hashConfig.get(XML_CSTRT_DELAYTHROTTLE);</span>
<span class="pc bpc" id="L949" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L950">      delay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L952">    value = hashConfig.get(XML_CSTRT_LIMITLOWBANDWIDTH);</span>
<span class="pc bpc" id="L953" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L954">      limitLowBandwidth = value.getLong();</span>
    }
<span class="fc" id="L956">    value = hashConfig.get(XML_TIMEOUTCON);</span>
<span class="pc bpc" id="L957" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L958">      setTimeoutCon((value.getLong() / 10) * 10);</span>
    }
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">    if (highcpuLimit &gt; 0) {</span>
<span class="nc" id="L961">      setConstraintLimitHandler(</span>
<span class="nc" id="L962">          new FtpConstraintLimitHandler(getTimeoutCon(), useCpuLimit,</span>
                                        useCpuLimitJDK, cpulimit, connlimit,
                                        lowcpuLimit, highcpuLimit,
                                        percentageDecrease, null, delay,
                                        limitLowBandwidth));
    } else {
<span class="fc" id="L968">      setConstraintLimitHandler(</span>
<span class="fc" id="L969">          new FtpConstraintLimitHandler(getTimeoutCon(), useCpuLimit,</span>
                                        useCpuLimitJDK, cpulimit, connlimit));
    }
<span class="fc" id="L972">    value = hashConfig.get(XML_SERVER_THREAD);</span>
<span class="pc bpc" id="L973" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L974">      setServerThread(value.getInteger());</span>
    }
<span class="fc" id="L976">    value = hashConfig.get(XML_CLIENT_THREAD);</span>
<span class="pc bpc" id="L977" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L978">      setClientThread(value.getInteger());</span>
    }
<span class="pc bpc" id="L980" title="2 of 4 branches missed.">    if (getServerThread() == 0 || getClientThread() == 0) {</span>
<span class="nc" id="L981">      computeNbThreads();</span>
    }
<span class="fc" id="L983">    value = hashConfig.get(XML_MEMORY_LIMIT);</span>
<span class="pc bpc" id="L984" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L985">      long lvalue = value.getLong();</span>
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">      if (lvalue &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L987">        lvalue = Integer.MAX_VALUE;</span>
      }
<span class="fc" id="L989">      setMaxGlobalMemory((int) lvalue);</span>
    }
<span class="fc" id="L991">    ((FilesystemBasedFileParameterImpl) getFileParameter()).deleteOnAbort =</span>
        false;
<span class="fc" id="L993">    value = hashConfig.get(XML_USENIO);</span>
<span class="pc bpc" id="L994" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L995">      FilesystemBasedFileParameterImpl.useNio = value.getBoolean();</span>
    }
<span class="fc" id="L997">    value = hashConfig.get(XML_USEFASTMD5);</span>
<span class="pc bpc" id="L998" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L999">      FilesystemBasedDigest.setUseFastMd5(value.getBoolean());</span>
    }
<span class="fc" id="L1001">    value = hashConfig.get(XML_BLOCKSIZE);</span>
<span class="pc bpc" id="L1002" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1003">      setBlocksize(value.getInteger());</span>
    }
<span class="fc" id="L1005">    value = hashConfig.get(XML_DELETEONABORT);</span>
<span class="pc bpc" id="L1006" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1007">      setDeleteOnAbort(value.getBoolean());</span>
    }
    // We use Apache Commons IO
<span class="fc" id="L1010">    FilesystemBasedDirJdkAbstract.ueApacheCommonsIo = true;</span>
<span class="fc" id="L1011">    return true;</span>
  }

  private boolean loadNetworkServer() {
<span class="fc" id="L1015">    XmlValue value = hashConfig.get(XML_SERVER_PORT);</span>
    final int port;
<span class="pc bpc" id="L1017" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1018">      port = value.getInteger();</span>
    } else {
<span class="nc" id="L1020">      port = 21;</span>
    }
<span class="fc" id="L1022">    setServerPort(port);</span>
<span class="fc" id="L1023">    value = hashConfig.get(XML_SERVER_ADDRESS);</span>
<span class="fc" id="L1024">    String address = null;</span>
<span class="pc bpc" id="L1025" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1026">      address = value.getString();</span>
    }
<span class="fc" id="L1028">    setServerAddress(address);</span>
<span class="fc" id="L1029">    int min = 100;</span>
<span class="fc" id="L1030">    int max = 65535;</span>
<span class="fc" id="L1031">    value = hashConfig.get(XML_RANGE_PORT_MIN);</span>
<span class="pc bpc" id="L1032" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1033">      min = value.getInteger();</span>
    }
<span class="fc" id="L1035">    value = hashConfig.get(XML_RANGE_PORT_MAX);</span>
<span class="pc bpc" id="L1036" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1037">      max = value.getInteger();</span>
    }
<span class="fc" id="L1039">    logger.warn(&quot;Passive Port range Min: &quot; + min + &quot; Max: &quot; + max);</span>
<span class="fc" id="L1040">    final CircularIntValue rangePort = new CircularIntValue(min, max);</span>
<span class="fc" id="L1041">    setRangePort(rangePort);</span>
<span class="fc" id="L1042">    value = hashConfig.get(XML_SERVER_HTTPS_PORT);</span>
<span class="fc" id="L1043">    int httpsport = 8067;</span>
<span class="pc bpc" id="L1044" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1045">      httpsport = value.getInteger();</span>
    }
<span class="fc" id="L1047">    serverHttpsPort = httpsport;</span>
<span class="fc" id="L1048">    return true;</span>
  }

  /**
   * Set the Crypto Key from the Document
   *
   * @return True if OK
   */
  private boolean setCryptoKey() {
<span class="fc" id="L1057">    final XmlValue value = hashConfig.get(XML_PATH_CRYPTOKEY);</span>
<span class="pc bpc" id="L1058" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1059">      logger.error(&quot;Unable to find CryptoKey in Config file&quot;);</span>
<span class="nc" id="L1060">      return false;</span>
    }
<span class="fc" id="L1062">    final String filename = value.getString();</span>
<span class="fc" id="L1063">    final File key = new File(filename);</span>
<span class="fc" id="L1064">    final Des des = new Des();</span>
    try {
<span class="fc" id="L1066">      des.setSecretKey(key);</span>
<span class="nc" id="L1067">    } catch (final CryptoException e) {</span>
<span class="nc" id="L1068">      logger.error(&quot;Unable to load CryptoKey from Config file&quot;);</span>
<span class="nc" id="L1069">      return false;</span>
<span class="nc" id="L1070">    } catch (final IOException e) {</span>
<span class="nc" id="L1071">      logger.error(&quot;Unable to load CryptoKey from Config file&quot;);</span>
<span class="nc" id="L1072">      return false;</span>
<span class="fc" id="L1073">    }</span>
<span class="fc" id="L1074">    cryptoKey = des;</span>
<span class="fc" id="L1075">    return true;</span>
  }

  /**
   * @return True if the global Exec parameters are correctly loaded
   */
  private boolean loadExec() {
    // Specific Exec command options
<span class="fc" id="L1083">    XmlValue value = hashConfig.get(XML_RETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1084" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1085">      logger.error(&quot;Unable to find Retrieve Command in Config file&quot;);</span>
<span class="nc" id="L1086">      return false;</span>
    }
<span class="fc" id="L1088">    final String retrieve = value.getString();</span>
<span class="fc" id="L1089">    value = hashConfig.get(XML_DELAYRETRIEVE_COMMAND);</span>
<span class="fc" id="L1090">    long retrievedelay = 0;</span>
<span class="pc bpc" id="L1091" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1092">      retrievedelay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L1094">    value = hashConfig.get(XML_STORE_COMMAND);</span>
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1096">      logger.error(&quot;Unable to find Store Command in Config file&quot;);</span>
<span class="nc" id="L1097">      return false;</span>
    }
<span class="fc" id="L1099">    final String store = value.getString();</span>
<span class="fc" id="L1100">    value = hashConfig.get(XML_DELAYSTORE_COMMAND);</span>
<span class="fc" id="L1101">    long storedelay = 0;</span>
<span class="pc bpc" id="L1102" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1103">      storedelay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L1105">    AbstractExecutor</span>
<span class="fc" id="L1106">        .initializeExecutor(retrieve, retrievedelay, store, storedelay);</span>
<span class="fc" id="L1107">    return true;</span>
  }

  /**
   * Load database parameter
   *
   * @return True if OK
   */
  private boolean loadDatabase() {
<span class="fc" id="L1116">    XmlValue value = hashConfig.get(XML_DBDRIVER);</span>
<span class="pc bpc" id="L1117" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1118">      logger.error(&quot;Unable to find DBDriver in Config file&quot;);</span>
<span class="nc" id="L1119">      DbConstantFtp.gatewayAdmin = new DbAdmin(); // no database support</span>
    } else {
<span class="fc" id="L1121">      final String dbdriver = value.getString();</span>
<span class="fc" id="L1122">      value = hashConfig.get(XML_DBSERVER);</span>
<span class="pc bpc" id="L1123" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1124">        logger.error(&quot;Unable to find DBServer in Config file&quot;);</span>
<span class="nc" id="L1125">        return false;</span>
      }
<span class="fc" id="L1127">      final String dbserver = value.getString();</span>
<span class="fc" id="L1128">      value = hashConfig.get(XML_DBUSER);</span>
<span class="pc bpc" id="L1129" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1130">        logger.error(&quot;Unable to find DBUser in Config file&quot;);</span>
<span class="nc" id="L1131">        return false;</span>
      }
<span class="fc" id="L1133">      final String dbuser = value.getString();</span>
<span class="fc" id="L1134">      value = hashConfig.get(XML_DBPASSWD);</span>
<span class="pc bpc" id="L1135" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1136">        logger.error(&quot;Unable to find DBPassword in Config file&quot;);</span>
<span class="nc" id="L1137">        return false;</span>
      }
<span class="fc" id="L1139">      final String dbpasswd = value.getString();</span>
<span class="pc bpc" id="L1140" title="4 of 8 branches missed.">      if (dbdriver == null || dbserver == null || dbuser == null ||</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">          dbpasswd == null || dbdriver.length() == 0 ||</span>
<span class="pc bpc" id="L1142" title="2 of 4 branches missed.">          dbserver.length() == 0 || dbuser.length() == 0 ||</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">          dbpasswd.length() == 0) {</span>
<span class="nc" id="L1144">        logger.error(&quot;Unable to find Correct DB data in Config file&quot;);</span>
<span class="nc" id="L1145">        return false;</span>
      }
      try {
<span class="fc" id="L1148">        DbConstantFtp.gatewayAdmin = DbModelFactoryFtp</span>
<span class="fc" id="L1149">            .initialize(dbdriver, dbserver, dbuser, dbpasswd, true);</span>
<span class="fc" id="L1150">        org.waarp.common.database.DbConstant.admin = DbConstantFtp.gatewayAdmin;</span>
<span class="nc" id="L1151">      } catch (final WaarpDatabaseNoConnectionException e2) {</span>
<span class="nc" id="L1152">        logger.error(&quot;Unable to Connect to DB&quot;, e2);</span>
<span class="nc" id="L1153">        return false;</span>
<span class="fc" id="L1154">      }</span>
    }
<span class="fc" id="L1156">    return true;</span>
  }

  protected boolean loadSsl() {
    // StoreKey for Server
<span class="fc" id="L1161">    XmlValue value = hashConfig.get(XML_PATH_KEYPATH);</span>
<span class="pc bpc" id="L1162" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="fc" id="L1163">      logger.info(&quot;Unable to find Key Path&quot;);</span>
<span class="fc" id="L1164">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="fc" id="L1165">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
<span class="fc" id="L1166">      return true;</span>
    } else {
<span class="nc" id="L1168">      final String keypath = value.getString();</span>
<span class="nc bnc" id="L1169" title="All 4 branches missed.">      if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L1170">        logger.error(&quot;Bad Key Path&quot;);</span>
<span class="nc" id="L1171">        return false;</span>
      }
<span class="nc" id="L1173">      value = hashConfig.get(XML_PATH_KEYSTOREPASS);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1175">        logger.error(&quot;Unable to find KeyStore Passwd&quot;);</span>
<span class="nc" id="L1176">        return false;</span>
      }
<span class="nc" id="L1178">      final String keystorepass = value.getString();</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">      if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L1180">        logger.error(&quot;Bad KeyStore Passwd&quot;);</span>
<span class="nc" id="L1181">        return false;</span>
      }
<span class="nc" id="L1183">      value = hashConfig.get(XML_PATH_KEYPASS);</span>
<span class="nc bnc" id="L1184" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1185">        logger.error(&quot;Unable to find Key Passwd&quot;);</span>
<span class="nc" id="L1186">        return false;</span>
      }
<span class="nc" id="L1188">      final String keypass = value.getString();</span>
<span class="nc bnc" id="L1189" title="All 4 branches missed.">      if (keypass == null || keypass.length() == 0) {</span>
<span class="nc" id="L1190">        logger.error(&quot;Bad Key Passwd&quot;);</span>
<span class="nc" id="L1191">        return false;</span>
      }
      try {
<span class="nc" id="L1194">        FtpsInitializer.waarpSecureKeyStore =</span>
            new WaarpSecureKeyStore(keypath, keystorepass, keypass);
<span class="nc" id="L1196">      } catch (final CryptoException e) {</span>
<span class="nc" id="L1197">        logger.error(&quot;Bad SecureKeyStore construction&quot;);</span>
<span class="nc" id="L1198">        return false;</span>
<span class="nc" id="L1199">      }</span>

    }
    // TrustedKey for OpenR66 server
<span class="nc" id="L1203">    value = hashConfig.get(XML_PATH_TRUSTKEYPATH);</span>
<span class="nc bnc" id="L1204" title="All 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1205">      logger.info(&quot;Unable to find TRUST Key Path&quot;);</span>
<span class="nc" id="L1206">      FtpsInitializer.waarpSecureKeyStore.initEmptyTrustStore();</span>
    } else {
<span class="nc" id="L1208">      final String keypath = value.getString();</span>
<span class="nc bnc" id="L1209" title="All 4 branches missed.">      if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L1210">        logger.error(&quot;Bad TRUST Key Path&quot;);</span>
<span class="nc" id="L1211">        return false;</span>
      }
<span class="nc" id="L1213">      value = hashConfig.get(XML_PATH_TRUSTKEYSTOREPASS);</span>
<span class="nc bnc" id="L1214" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1215">        logger.error(&quot;Unable to find TRUST KeyStore Passwd&quot;);</span>
<span class="nc" id="L1216">        return false;</span>
      }
<span class="nc" id="L1218">      final String keystorepass = value.getString();</span>
<span class="nc bnc" id="L1219" title="All 4 branches missed.">      if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L1220">        logger.error(&quot;Bad TRUST KeyStore Passwd&quot;);</span>
<span class="nc" id="L1221">        return false;</span>
      }
<span class="nc" id="L1223">      boolean useClientAuthent = false;</span>
<span class="nc" id="L1224">      value = hashConfig.get(XML_USECLIENT_AUTHENT);</span>
<span class="nc bnc" id="L1225" title="All 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1226">        useClientAuthent = value.getBoolean();</span>
      }
      try {
<span class="nc" id="L1229">        FtpsInitializer.waarpSecureKeyStore</span>
<span class="nc" id="L1230">            .initTrustStore(keypath, keystorepass, useClientAuthent);</span>
<span class="nc" id="L1231">      } catch (final CryptoException e) {</span>
<span class="nc" id="L1232">        logger.error(&quot;Bad TrustKeyStore construction&quot;);</span>
<span class="nc" id="L1233">        return false;</span>
<span class="nc" id="L1234">      }</span>
    }
<span class="nc" id="L1236">    FtpsInitializer.waarpSslContextFactory =</span>
        new WaarpSslContextFactory(FtpsInitializer.waarpSecureKeyStore);
<span class="nc" id="L1238">    boolean useImplicit = false;</span>
<span class="nc" id="L1239">    value = hashConfig.get(XML_IMPLICIT_FTPS);</span>
<span class="nc bnc" id="L1240" title="All 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1241">      useImplicit = value.getBoolean();</span>
    }
<span class="nc" id="L1243">    boolean useExplicit = false;</span>
<span class="nc" id="L1244">    value = hashConfig.get(XML_EXPLICIT_FTPS);</span>
<span class="nc bnc" id="L1245" title="All 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1246">      useExplicit = value.getBoolean();</span>
    }
<span class="nc bnc" id="L1248" title="All 4 branches missed.">    if (useImplicit &amp;&amp; useExplicit) {</span>
<span class="nc" id="L1249">      logger.error(&quot;Only one of IMPLICIT or EXPLICIT could be True&quot;);</span>
<span class="nc" id="L1250">      return false;</span>
    }
<span class="nc bnc" id="L1252" title="All 4 branches missed.">    if (!useImplicit &amp;&amp; !useExplicit) {</span>
<span class="nc" id="L1253">      logger.error(</span>
          &quot;Since all SecureStore are specified, one of IMPLICIT or EXPLICIT should be True&quot;);
<span class="nc" id="L1255">      logger.warn(&quot;FTPS support will be ignored...&quot;);</span>
<span class="nc" id="L1256">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="nc" id="L1257">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
<span class="nc" id="L1258">      return true;</span>
    }
<span class="nc" id="L1260">    getFtpInternalConfiguration().setUsingNativeSsl(useImplicit);</span>
<span class="nc" id="L1261">    getFtpInternalConfiguration().setAcceptAuthProt(useExplicit);</span>
<span class="nc" id="L1262">    return true;</span>
  }

  /**
   * Initiate the configuration from the xml file for server
   *
   * @param filename
   *
   * @return True if OK
   */
  public boolean setConfigurationServerFromXml(final String filename) {
    final Document document;
    // Open config file
    try {
<span class="fc" id="L1276">      document = XmlUtil.getNewSaxReader().read(filename);</span>
<span class="nc" id="L1277">    } catch (final DocumentException e) {</span>
<span class="nc" id="L1278">      logger.error(&quot;Unable to read the XML Config file: &quot; + filename, e);</span>
<span class="nc" id="L1279">      return false;</span>
<span class="fc" id="L1280">    }</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">    if (document == null) {</span>
<span class="nc" id="L1282">      logger.error(&quot;Unable to read the XML Config file: &quot; + filename);</span>
<span class="nc" id="L1283">      return false;</span>
    }
<span class="fc" id="L1285">    XmlValue[] configuration = XmlUtil.read(document, configServer);</span>
<span class="fc" id="L1286">    hashConfig = new XmlHash(configuration);</span>
    // Now read the configuration
<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">    if (!loadIdentity()) {</span>
<span class="nc" id="L1289">      logger.error(&quot;Cannot load Identity&quot;);</span>
<span class="nc" id="L1290">      return false;</span>
    }
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">    if (!loadDatabase()) {</span>
<span class="nc" id="L1293">      logger.error(&quot;Cannot load Database configuration&quot;);</span>
<span class="nc" id="L1294">      return false;</span>
    }
<span class="pc bpc" id="L1296" title="1 of 2 branches missed.">    if (!loadServerParam()) {</span>
<span class="nc" id="L1297">      logger.error(&quot;Cannot load Server Parameters&quot;);</span>
<span class="nc" id="L1298">      return false;</span>
    }
<span class="pc bpc" id="L1300" title="1 of 2 branches missed.">    if (!loadDirectory()) {</span>
<span class="nc" id="L1301">      logger.error(&quot;Cannot load Directory configuration&quot;);</span>
<span class="nc" id="L1302">      return false;</span>
    }
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">    if (!loadLimit()) {</span>
<span class="nc" id="L1305">      logger.error(&quot;Cannot load Limit configuration&quot;);</span>
<span class="nc" id="L1306">      return false;</span>
    }
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">    if (!loadNetworkServer()) {</span>
<span class="nc" id="L1309">      logger.error(&quot;Cannot load Network configuration&quot;);</span>
<span class="nc" id="L1310">      return false;</span>
    }
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">    if (!loadExec()) {</span>
<span class="nc" id="L1313">      logger.error(&quot;Cannot load Exec configuration&quot;);</span>
<span class="nc" id="L1314">      return false;</span>
    }
    // if no database, must load authentication from file
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">    if (!loadAuthentication()) {</span>
<span class="nc" id="L1318">      logger.error(&quot;Cannot load Authentication configuration&quot;);</span>
<span class="nc" id="L1319">      return false;</span>
    }
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">    if (!loadSsl()) {</span>
      // ignore and continue =&gt; No SSL
<span class="nc" id="L1323">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="nc" id="L1324">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
    }
<span class="fc" id="L1326">    hashConfig.clear();</span>
<span class="fc" id="L1327">    hashConfig = null;</span>
<span class="fc" id="L1328">    configuration = null;</span>
<span class="fc" id="L1329">    logger.debug(&quot;File based configuration loaded&quot;);</span>
<span class="fc" id="L1330">    return true;</span>
  }

  /**
   * Configure HTTPS
   */
  public void configureHttps() {
<span class="fc" id="L1337">    logger.debug(&quot;Start HTTPS&quot;);</span>
    // Now start the HTTPS support
    // Configure the server.
    /**
     * Bootstrap for Https server
     */
<span class="fc" id="L1343">    final ServerBootstrap httpsBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L1344">    httpExecutor = new NioEventLoopGroup(getServerThread() * 10,</span>
                                         new WaarpThreadFactory(
                                             &quot;HttpExecutor&quot;));
<span class="fc" id="L1347">    workerGroup = new NioEventLoopGroup(getServerThread() * 10,</span>
                                        new WaarpThreadFactory(&quot;HTTP_Worker&quot;));
<span class="fc" id="L1349">    WaarpNettyUtil</span>
<span class="fc" id="L1350">        .setServerBootstrap(httpsBootstrap, workerGroup, (int) getTimeoutCon());</span>

    // Configure the pipeline factory.
<span class="fc" id="L1353">    httpsBootstrap.childHandler(new HttpSslInitializer(isUseHttpCompression()));</span>
<span class="fc" id="L1354">    httpChannelGroup =</span>
<span class="fc" id="L1355">        new DefaultChannelGroup(&quot;HttpOpenR66&quot;, httpExecutor.next());</span>

    // Bind and start to accept incoming connections.
<span class="fc" id="L1358">    logger.warn(&quot;Start Https Support on port: &quot; + serverHttpsPort + &quot; with &quot; +</span>
<span class="pc bpc" id="L1359" title="1 of 2 branches missed.">                (isUseHttpCompression()? &quot;&quot; : &quot;no&quot;) + &quot; compression support&quot;);</span>
<span class="fc" id="L1360">    final ChannelFuture future =</span>
<span class="fc" id="L1361">        httpsBootstrap.bind(new InetSocketAddress(serverHttpsPort));</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">    if (WaarpNettyUtil.awaitIsSuccessOfInterrupted(future)) {</span>
<span class="fc" id="L1363">      httpChannelGroup.add(future.channel());</span>
    }
<span class="fc" id="L1365">  }</span>

  /**
   * Configure ConstraintLimitHandler
   */
  public void configureConstraint() {
<span class="fc" id="L1371">    logger.debug(&quot;Configure constraints&quot;);</span>
<span class="fc" id="L1372">    getConstraintLimitHandler().setHandler(</span>
<span class="fc" id="L1373">        getFtpInternalConfiguration().getGlobalTrafficShapingHandler());</span>
<span class="fc" id="L1374">  }</span>

  /**
   * Configure LocalExec
   */
  public void configureLExec() {
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">    if (isUseLocalExec()) {</span>
<span class="nc" id="L1381">      logger.debug(&quot;Start LExec&quot;);</span>
<span class="nc" id="L1382">      LocalExecClient.initialize(getClientThread(), getMaxGlobalMemory());</span>
    }
<span class="fc" id="L1384">  }</span>

  /**
   * Configure the SNMP support if needed
   *
   * @throws FtpNoConnectionException
   */
  public void configureSnmp() throws FtpNoConnectionException {
<span class="fc" id="L1392">    logger.debug(&quot;Start SNMP&quot;);</span>
<span class="fc" id="L1393">    setMonitoring(new FtpMonitoring(null));</span>
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">    if (getSnmpConfig() != null) {</span>
<span class="fc" id="L1395">      final int snmpPortShow = getServerPort();</span>
<span class="fc" id="L1396">      setFtpMib(new FtpPrivateMib(snmpPortShow));</span>
<span class="fc" id="L1397">      WaarpMOFactory.setFactory(new FtpVariableFactory());</span>
<span class="fc" id="L1398">      setAgentSnmp(</span>
<span class="fc" id="L1399">          new WaarpSnmpAgent(new File(getSnmpConfig()), getMonitoring(),</span>
<span class="fc" id="L1400">                             getFtpMib()));</span>
      try {
<span class="fc" id="L1402">        getAgentSnmp().start();</span>
<span class="fc" id="L1403">        logger.debug(&quot;SNMP configured&quot;);</span>
<span class="nc" id="L1404">      } catch (final IOException e) {</span>
<span class="nc" id="L1405">        getMonitoring().releaseResources();</span>
<span class="nc" id="L1406">        setMonitoring(null);</span>
<span class="nc" id="L1407">        setFtpMib(null);</span>
<span class="nc" id="L1408">        setAgentSnmp(null);</span>
<span class="nc" id="L1409">        throw new FtpNoConnectionException(&quot;AgentSnmp Error while starting&quot;, e);</span>
<span class="fc" id="L1410">      }</span>
    }
<span class="fc" id="L1412">  }</span>

  /**
   * @param serverkey the SERVERADMINKEY to set
   */
  public void setSERVERKEY(final byte[] serverkey) {
<span class="fc" id="L1418">    serverAdminKey = serverkey;</span>
<span class="fc" id="L1419">  }</span>

  /**
   * Check the password for Shutdown
   *
   * @param password
   *
   * @return True if the password is OK
   */
  @Override
  public boolean checkPassword(final String password) {
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">    if (password == null) {</span>
<span class="nc" id="L1431">      return false;</span>
    }
<span class="fc" id="L1433">    return Arrays</span>
<span class="fc" id="L1434">        .equals(serverAdminKey, password.getBytes(WaarpStringUtils.UTF8));</span>
  }

  /**
   * Initialize Authentication from current authenticationFile
   *
   * @param filename the filename from which authentication will be
   *     loaded
   * @param purge if True, the current authentications are totally
   *     replaced
   *     by the new ones
   *
   * @return True if OK
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean initializeAuthent(final String filename, final boolean purge) {
<span class="fc" id="L1450">    logger.debug(&quot;Load authent&quot;);</span>
    final Document document;
    try {
<span class="fc" id="L1453">      document = XmlUtil.getNewSaxReader().read(filename);</span>
<span class="nc" id="L1454">    } catch (final DocumentException e) {</span>
<span class="nc" id="L1455">      logger</span>
<span class="nc" id="L1456">          .error(&quot;Unable to read the XML Authentication file: &quot; + filename, e);</span>
<span class="nc" id="L1457">      return false;</span>
<span class="fc" id="L1458">    }</span>
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">    if (document == null) {</span>
<span class="nc" id="L1460">      logger.error(&quot;Unable to read the XML Authentication file: &quot; + filename);</span>
<span class="nc" id="L1461">      return false;</span>
    }
<span class="fc" id="L1463">    final XmlValue[] configurationXml = XmlUtil.read(document, authentElements);</span>
<span class="fc" id="L1464">    XmlHash hashConfigXml = new XmlHash(configurationXml);</span>

<span class="fc" id="L1466">    XmlValue value = hashConfigXml.get(XML_AUTHENTIFICATION_ENTRY);</span>
<span class="fc" id="L1467">    final List&lt;XmlValue[]&gt; list = (List&lt;XmlValue[]&gt;) value.getList();</span>
<span class="fc" id="L1468">    final ConcurrentHashMap&lt;String, SimpleAuth&gt; newAuthents =</span>
        new ConcurrentHashMap&lt;String, SimpleAuth&gt;();
<span class="fc bfc" id="L1470" title="All 2 branches covered.">    for (final XmlValue[] xmlValues : list) {</span>
<span class="fc" id="L1471">      hashConfigXml = new XmlHash(xmlValues);</span>
<span class="fc" id="L1472">      value = hashConfigXml.get(XML_AUTHENTICATION_USER);</span>
<span class="pc bpc" id="L1473" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1474">        logger.error(&quot;Unable to find a User in Config file&quot;);</span>
<span class="nc" id="L1475">        continue;</span>
      }
<span class="fc" id="L1477">      final String user = value.getString();</span>
<span class="fc" id="L1478">      value = hashConfigXml.get(XML_AUTHENTICATION_ACCOUNT);</span>
<span class="pc bpc" id="L1479" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1480">        logger.error(&quot;Unable to find a Account in Config file: &quot; + user);</span>
<span class="nc" id="L1481">        continue;</span>
      }
      final String[] account;
<span class="fc" id="L1484">      final List&lt;String&gt; listaccount = (List&lt;String&gt;) value.getList();</span>
<span class="pc bpc" id="L1485" title="1 of 2 branches missed.">      if (!listaccount.isEmpty()) {</span>
<span class="fc" id="L1486">        account = new String[listaccount.size()];</span>
<span class="fc" id="L1487">        int i = 0;</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">        for (final String s : listaccount) {</span>
<span class="fc" id="L1489">          account[i] = s;</span>
          // logger.debug(&quot;User: {} Acct: {}&quot;, user, account[i])
<span class="fc" id="L1491">          final File directory =</span>
<span class="fc" id="L1492">              new File(getBaseDirectory() + '/' + user + '/' + account[i]);</span>
<span class="fc" id="L1493">          directory.mkdirs();//NOSONAR</span>
<span class="fc" id="L1494">          i++;</span>
<span class="fc" id="L1495">        }</span>
<span class="fc" id="L1496">      } else {</span>
<span class="nc" id="L1497">        logger.error(&quot;Unable to find a Account in Config file: &quot; + user);</span>
<span class="nc" id="L1498">        continue;</span>
      }
<span class="fc" id="L1500">      value = hashConfigXml.get(XML_AUTHENTICATION_ADMIN);</span>
<span class="fc" id="L1501">      boolean isAdmin = false;</span>
<span class="pc bpc" id="L1502" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1503">        isAdmin = value.getBoolean();</span>
      }
<span class="fc" id="L1505">      String retrcmd = null;</span>
<span class="fc" id="L1506">      long retrdelay = 0;</span>
<span class="fc" id="L1507">      String storcmd = null;</span>
<span class="fc" id="L1508">      long stordelay = 0;</span>
<span class="fc" id="L1509">      value = hashConfigXml.get(XML_RETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1510" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1511">        retrcmd = value.getString();</span>
      }
<span class="fc" id="L1513">      value = hashConfigXml.get(XML_DELAYRETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1514" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1515">        retrdelay = (value.getLong() / 10) * 10;</span>
      }
<span class="fc" id="L1517">      value = hashConfigXml.get(XML_STORE_COMMAND);</span>
<span class="pc bpc" id="L1518" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1519">        storcmd = value.getString();</span>
      }
<span class="fc" id="L1521">      value = hashConfigXml.get(XML_DELAYSTORE_COMMAND);</span>
<span class="pc bpc" id="L1522" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1523">        stordelay = (value.getLong() / 10) * 10;</span>
      }
      final String passwd;
<span class="fc" id="L1526">      value = hashConfigXml.get(XML_AUTHENTICATION_PASSWDFILE);</span>
<span class="pc bpc" id="L1527" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
        // load key from file
<span class="fc" id="L1529">        final File key = new File(value.getString());</span>
<span class="pc bpc" id="L1530" title="1 of 2 branches missed.">        if (!key.canRead()) {</span>
<span class="nc" id="L1531">          logger</span>
<span class="nc" id="L1532">              .error(&quot;Cannot read key for user &quot; + user + ':' + key.getName());</span>
<span class="nc" id="L1533">          continue;</span>
        }
        try {
<span class="fc" id="L1536">          final byte[] byteKeys = getCryptoKey().decryptHexFile(key);</span>
<span class="fc" id="L1537">          passwd = new String(byteKeys, WaarpStringUtils.UTF8);</span>
<span class="nc" id="L1538">        } catch (final Exception e2) {</span>
<span class="nc" id="L1539">          logger.error(&quot;Cannot read key for user &quot; + user, e2);</span>
<span class="nc" id="L1540">          continue;</span>
<span class="fc" id="L1541">        }</span>
<span class="fc" id="L1542">      } else {</span>
<span class="nc" id="L1543">        value = hashConfigXml.get(XML_AUTHENTICATION_PASSWD);</span>
<span class="nc bnc" id="L1544" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1545">          final String encrypted = value.getString();</span>
          final byte[] byteKeys;
          try {
<span class="nc" id="L1548">            byteKeys = getCryptoKey().decryptHexInBytes(encrypted);</span>
<span class="nc" id="L1549">            passwd = new String(byteKeys, WaarpStringUtils.UTF8);</span>
<span class="nc" id="L1550">          } catch (final Exception e) {</span>
<span class="nc" id="L1551">            logger.error(&quot;Unable to Decrypt Key for user &quot; + user, e);</span>
<span class="nc" id="L1552">            continue;</span>
<span class="nc" id="L1553">          }</span>
<span class="nc" id="L1554">        } else {</span>
<span class="nc" id="L1555">          logger.error(&quot;Unable to find Password in Config file&quot;);</span>
          // DO NOT Allow empty key
<span class="nc" id="L1557">          continue;</span>
        }
      }
<span class="fc" id="L1560">      final SimpleAuth auth =</span>
          new SimpleAuth(user, passwd, account, storcmd, stordelay, retrcmd,
                         retrdelay);
<span class="fc" id="L1563">      auth.setAdmin(isAdmin);</span>
<span class="fc" id="L1564">      newAuthents.put(user, auth);</span>
<span class="fc" id="L1565">      hashConfigXml.clear();</span>
<span class="fc" id="L1566">    }</span>
<span class="fc" id="L1567">    hashConfigXml.clear();</span>
<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">    if (purge) {</span>
<span class="nc" id="L1569">      authentications.clear();</span>
    }
<span class="fc" id="L1571">    authentications.putAll(newAuthents);</span>
<span class="fc" id="L1572">    newAuthents.clear();</span>
<span class="fc" id="L1573">    return true;</span>
  }

  /**
   * Export the Authentication to the original files
   *
   * @param filename the filename where the authentication will be
   *     exported
   *
   * @return True if successful
   */
  public boolean saveAuthenticationFile(final String filename) {
<span class="nc" id="L1585">    final Document document = XmlUtil.createEmptyDocument();</span>
<span class="nc" id="L1586">    final XmlValue[] roots = new XmlValue[1];</span>
<span class="nc" id="L1587">    final XmlValue root = new XmlValue(authentElements[0]);</span>
<span class="nc" id="L1588">    roots[0] = root;</span>
<span class="nc" id="L1589">    final Enumeration&lt;SimpleAuth&gt; auths = authentications.elements();</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">    while (auths.hasMoreElements()) {</span>
<span class="nc" id="L1591">      final SimpleAuth auth = auths.nextElement();</span>
<span class="nc" id="L1592">      final XmlValue[] values = new XmlValue[configAuthenticationDecls.length];</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">      for (int i = 0; i &lt; configAuthenticationDecls.length; i++) {</span>
<span class="nc" id="L1594">        values[i] = new XmlValue(configAuthenticationDecls[i]);</span>
      }
      try {
<span class="nc" id="L1597">        values[0].setFromString(auth.getUser());</span>
        // PasswdFile: none values[1].setFromString()
<span class="nc" id="L1599">        values[2].setFromString(auth.getPassword());</span>
        // Accounts
<span class="nc" id="L1601">        final String[] accts = auth.getAccounts();</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">        for (final String string : accts) {</span>
<span class="nc" id="L1603">          values[3].addFromString(string);</span>
        }
<span class="nc" id="L1605">        values[4].setValue(auth.isAdmin());</span>
<span class="nc" id="L1606">        values[5].setFromString(auth.getRetrCmd());</span>
<span class="nc" id="L1607">        values[6].setValue(auth.getRetrDelay());</span>
<span class="nc" id="L1608">        values[7].setFromString(auth.getStorCmd());</span>
<span class="nc" id="L1609">        values[8].setValue(auth.getStorDelay());</span>
<span class="nc" id="L1610">      } catch (final InvalidArgumentException e1) {</span>
<span class="nc" id="L1611">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e1);</span>
<span class="nc" id="L1612">        return false;</span>
<span class="nc" id="L1613">      } catch (final InvalidObjectException e) {</span>
<span class="nc" id="L1614">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e);</span>
<span class="nc" id="L1615">        return false;</span>
<span class="nc" id="L1616">      }</span>
      try {
<span class="nc" id="L1618">        root.addValue(values);</span>
<span class="nc" id="L1619">      } catch (final InvalidObjectException e) {</span>
<span class="nc" id="L1620">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e);</span>
<span class="nc" id="L1621">        return false;</span>
<span class="nc" id="L1622">      }</span>
<span class="nc" id="L1623">    }</span>
<span class="nc" id="L1624">    XmlUtil.write(document, roots);</span>
    try {
<span class="nc" id="L1626">      XmlUtil.saveDocument(filename, document);</span>
<span class="nc" id="L1627">    } catch (final IOException e1) {</span>
<span class="nc" id="L1628">      logger.error(&quot;Cannot write to file: &quot; + filename + &quot; since {}&quot;,</span>
<span class="nc" id="L1629">                   e1.getMessage());</span>
<span class="nc" id="L1630">      return false;</span>
<span class="nc" id="L1631">    }</span>
<span class="nc" id="L1632">    return true;</span>
  }

  /**
   * @param user
   *
   * @return the SimpleAuth if any for this user
   */
  public SimpleAuth getSimpleAuth(final String user) {
<span class="fc" id="L1641">    return authentications.get(user);</span>
  }

  /**
   * @param format Format in HTML to use as ouput format
   *
   * @return the Html String containing the table of all Authentication
   *     entries
   */
  public String getHtmlAuth(final String format) {
    final String result;
<span class="fc" id="L1652">    final StringBuilder builder = new StringBuilder();</span>
    /*
     * XXXUSERXXX XXXPWDXXX XXXACTSXXX XXXADMXXX XXXSTCXXX XXXSTDXXX XXXRTCXXX XXXRTDXXX
     */
<span class="fc" id="L1656">    final Enumeration&lt;SimpleAuth&gt; simpleAuths = authentications.elements();</span>
    SimpleAuth auth;
<span class="fc bfc" id="L1658" title="All 2 branches covered.">    while (simpleAuths.hasMoreElements()) {</span>
<span class="fc" id="L1659">      auth = simpleAuths.nextElement();</span>
<span class="fc" id="L1660">      String newElt = format.replace(&quot;XXXUSERXXX&quot;, auth.getUser());</span>
<span class="fc" id="L1661">      newElt = newElt.replace(&quot;XXXPWDXXX&quot;, auth.getPassword());</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">      if (auth.getStorCmd() != null) {</span>
<span class="fc" id="L1663">        newElt = newElt.replace(&quot;XXXSTCXXX&quot;, auth.getStorCmd());</span>
      } else {
<span class="fc" id="L1665">        newElt = newElt.replace(&quot;XXXSTCXXX&quot;, &quot;&quot;);</span>
      }
<span class="fc bfc" id="L1667" title="All 2 branches covered.">      if (auth.getRetrCmd() != null) {</span>
<span class="fc" id="L1668">        newElt = newElt.replace(&quot;XXXRTCXXX&quot;, auth.getRetrCmd());</span>
      } else {
<span class="fc" id="L1670">        newElt = newElt.replace(&quot;XXXRTCXXX&quot;, &quot;&quot;);</span>
      }
<span class="fc" id="L1672">      newElt = newElt.replace(&quot;XXXSTDXXX&quot;, Long.toString(auth.getStorDelay()));</span>
<span class="fc" id="L1673">      newElt = newElt.replace(&quot;XXXRTDXXX&quot;, Long.toString(auth.getRetrDelay()));</span>
<span class="fc" id="L1674">      newElt = newElt.replace(&quot;XXXADMXXX&quot;, Boolean.toString(auth.isAdmin()));</span>
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">      if (auth.getAccounts() != null) {</span>
<span class="fc" id="L1676">        final StringBuilder accts = new StringBuilder();</span>
<span class="fc bfc" id="L1677" title="All 2 branches covered.">        for (int i = 0; i &lt; auth.getAccounts().length - 1; i++) {</span>
<span class="fc" id="L1678">          accts.append(auth.getAccounts()[i]).append(&quot;, &quot;);</span>
        }
<span class="fc" id="L1680">        accts.append(auth.getAccounts()[auth.getAccounts().length - 1]);</span>
<span class="fc" id="L1681">        newElt = newElt.replace(&quot;XXXACTSXXX&quot;, accts.toString());</span>
<span class="fc" id="L1682">      } else {</span>
<span class="nc" id="L1683">        newElt = newElt.replace(&quot;XXXACTSXXX&quot;, &quot;No Account&quot;);</span>
      }
<span class="fc" id="L1685">      builder.append(newElt);</span>
<span class="fc" id="L1686">    }</span>
<span class="fc" id="L1687">    result = builder.toString();</span>
<span class="fc" id="L1688">    return result;</span>
  }

  /**
   * Only available with Database support for Waarp
   *
   * @param format Format in HTML to use as ouput format
   * @param limit number of TransferLog to populate
   *
   * @return the Html String containing the table of all Transfer entries
   */
  public String getHtmlTransfer(final String format, final int limit) {
    final String result;
<span class="fc" id="L1701">    final StringBuilder builder = new StringBuilder();</span>
    /*
     * XXXIDXXX XXXUSERXXX XXXACCTXXX XXXFILEXXX XXXMODEXXX XXXSTATUSXXX XXXINFOXXX XXXUPINFXXX XXXSTARTXXX
     * XXXSTOPXXX
     */
<span class="fc" id="L1706">    DbPreparedStatement preparedStatement = null;</span>
    try {
      try {
<span class="fc" id="L1709">        preparedStatement = DbTransferLog</span>
<span class="fc" id="L1710">            .getStatusPrepareStament(DbConstantFtp.gatewayAdmin.getSession(),</span>
                                     null, limit);
<span class="fc" id="L1712">        preparedStatement.executeQuery();</span>
<span class="nc" id="L1713">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1714">        return &quot;&quot;;</span>
<span class="nc" id="L1715">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L1716">        return &quot;&quot;;</span>
<span class="fc" id="L1717">      }</span>
      try {
<span class="fc bfc" id="L1719" title="All 2 branches covered.">        while (preparedStatement.getNext()) {</span>
<span class="fc" id="L1720">          final DbTransferLog log =</span>
<span class="fc" id="L1721">              DbTransferLog.getFromStatement(preparedStatement);</span>
<span class="fc" id="L1722">          String newElt =</span>
<span class="fc" id="L1723">              format.replace(&quot;XXXIDXXX&quot;, Long.toString(log.getSpecialId()));</span>
<span class="fc" id="L1724">          newElt = newElt.replace(&quot;XXXUSERXXX&quot;, log.getUser());</span>
<span class="fc" id="L1725">          newElt = newElt.replace(&quot;XXXACCTXXX&quot;, log.getAccount());</span>
<span class="fc" id="L1726">          newElt = newElt.replace(&quot;XXXFILEXXX&quot;, log.getFilename());</span>
<span class="fc" id="L1727">          newElt = newElt.replace(&quot;XXXMODEXXX&quot;, log.getMode());</span>
<span class="fc" id="L1728">          newElt = newElt.replace(&quot;XXXSTATUSXXX&quot;, log.getErrorInfo().getMesg());</span>
<span class="fc" id="L1729">          newElt = newElt.replace(&quot;XXXINFOXXX&quot;, log.getInfotransf());</span>
<span class="fc" id="L1730">          newElt = newElt.replace(&quot;XXXUPINFXXX&quot;, log.getUpdatedInfo().name());</span>
<span class="fc" id="L1731">          newElt = newElt.replace(&quot;XXXSTARTXXX&quot;, log.getStart().toString());</span>
<span class="fc" id="L1732">          newElt = newElt.replace(&quot;XXXSTOPXXX&quot;, log.getStop().toString());</span>
<span class="fc" id="L1733">          builder.append(newElt);</span>
<span class="fc" id="L1734">        }</span>
<span class="nc" id="L1735">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1736">        return &quot;&quot;;</span>
<span class="nc" id="L1737">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L1738">        return &quot;&quot;;</span>
<span class="fc" id="L1739">      }</span>
<span class="fc" id="L1740">      result = builder.toString();</span>
<span class="fc" id="L1741">      return result;</span>
    } finally {
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">      if (preparedStatement != null) {</span>
<span class="fc" id="L1744">        preparedStatement.realClose();</span>
      }
    }
  }

  /**
   * @see FtpConfiguration#getNextRangePort()
   */
  @Override
  public int getNextRangePort() {
    try {
<span class="fc" id="L1755">      return ((CircularIntValue) getProperty(RANGE_PORT)).getNext();</span>
<span class="nc" id="L1756">    } catch (final FtpUnknownFieldException e) {</span>
<span class="nc" id="L1757">      return -1;</span>
    }
  }

  /**
   * @param rangePort the range of available ports for Passive
   *     connections
   */
  private void setRangePort(final CircularIntValue rangePort) {
<span class="fc" id="L1766">    setProperty(RANGE_PORT, rangePort);</span>
<span class="fc" id="L1767">  }</span>

  /**
   * @return the httpPipelineExecutor
   */
  public EventExecutorGroup getHttpPipelineExecutor() {
<span class="fc" id="L1773">    return httpExecutor;</span>
  }

  /**
   * @return the httpChannelGroup
   */
  public ChannelGroup getHttpChannelGroup() {
<span class="fc" id="L1780">    return httpChannelGroup;</span>
  }

  /**
   * Finalize resources attached to handlers
   */
  private static class GgChannelGroupFutureListener
      implements ChannelGroupFutureListener {
    final EventExecutorGroup executorWorker;
    final String name;

    private GgChannelGroupFutureListener(final String name,
<span class="fc" id="L1792">                                         final EventExecutorGroup executorWorker) {</span>
<span class="fc" id="L1793">      this.name = name;</span>
<span class="fc" id="L1794">      this.executorWorker = executorWorker;</span>
<span class="fc" id="L1795">    }</span>

    @Override
    public void operationComplete(final ChannelGroupFuture future)
        throws Exception {
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">      if (executorWorker != null) {</span>
<span class="fc" id="L1801">        executorWorker.shutdownGracefully();</span>
      }
<span class="fc" id="L1803">      logger.info(&quot;Done with shutdown &quot; + name);</span>
<span class="fc" id="L1804">    }</span>
  }

  @Override
  public void releaseResources() {
<span class="fc" id="L1809">    logger.debug(&quot;Release resources&quot;);</span>
<span class="fc" id="L1810">    super.releaseResources();</span>
<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">    if (httpChannelGroup != null) {</span>
<span class="fc" id="L1812">      final int result = httpChannelGroup.size();</span>
<span class="fc" id="L1813">      logger.debug(&quot;HttpChannelGroup: &quot; + result);</span>
<span class="fc" id="L1814">      httpChannelGroup.close().addListener(</span>
          new GgChannelGroupFutureListener(&quot;HttpChannelGroup&quot;, workerGroup));
    }
<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">    if (httpExecutor != null) {</span>
<span class="fc" id="L1818">      httpExecutor.shutdownGracefully();</span>
    }
<span class="pc bpc" id="L1820" title="1 of 2 branches missed.">    if (isUseLocalExec()) {</span>
<span class="nc" id="L1821">      LocalExecClient.releaseResources();</span>
    }
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">    if (getConstraintLimitHandler() != null) {</span>
<span class="fc" id="L1824">      getConstraintLimitHandler().release();</span>
    }
<span class="pc bpc" id="L1826" title="1 of 2 branches missed.">    if (getAgentSnmp() != null) {</span>
<span class="fc" id="L1827">      getAgentSnmp().stop();</span>
    }
<span class="fc" id="L1829">    DbAdmin.closeAllConnection();</span>
<span class="fc" id="L1830">  }</span>

  @Override
  public void inShutdownProcess() {
<span class="pc bpc" id="L1834" title="1 of 2 branches missed.">    if (getFtpMib() != null) {</span>
<span class="fc" id="L1835">      getFtpMib().notifyStartStop(&quot;Shutdown in progress for &quot; + getHostId(),</span>
<span class="fc" id="L1836">                                  &quot;Gives extra seconds: &quot; + getTimeoutCon());</span>
    }
<span class="fc" id="L1838">  }</span>

  /**
   * @return the authenticationFile
   */
  public String getAuthenticationFile() {
<span class="fc" id="L1844">    return authenticationFile;</span>
  }

  /**
   * @param authenticationFile the authenticationFile to set
   */
  public void setAuthenticationFile(final String authenticationFile) {
<span class="fc" id="L1851">    this.authenticationFile = authenticationFile;</span>
<span class="fc" id="L1852">  }</span>

  /**
   * @return the httpBasePath
   */
  public String getHttpBasePath() {
<span class="fc" id="L1858">    return httpBasePath;</span>
  }

  /**
   * @param httpBasePath the httpBasePath to set
   */
  public void setHttpBasePath(final String httpBasePath) {
<span class="fc" id="L1865">    this.httpBasePath = httpBasePath;</span>
<span class="fc" id="L1866">  }</span>

  /**
   * @return the useHttpCompression
   */
  public boolean isUseHttpCompression() {
<span class="fc" id="L1872">    return useHttpCompression;</span>
  }

  /**
   * @param useHttpCompression the useHttpCompression to set
   */
  public void setUseHttpCompression(final boolean useHttpCompression) {
<span class="fc" id="L1879">    this.useHttpCompression = useHttpCompression;</span>
<span class="fc" id="L1880">  }</span>

  /**
   * @return the useLocalExec
   */
  public boolean isUseLocalExec() {
<span class="fc" id="L1886">    return useLocalExec;</span>
  }

  /**
   * @param useLocalExec the useLocalExec to set
   */
  public void setUseLocalExec(final boolean useLocalExec) {
<span class="fc" id="L1893">    this.useLocalExec = useLocalExec;</span>
<span class="fc" id="L1894">  }</span>

  /**
   * @return the cryptoKey
   */
  public Des getCryptoKey() {
<span class="fc" id="L1900">    return cryptoKey;</span>
  }

  /**
   * @param cryptoKey the cryptoKey to set
   */
  public void setCryptoKey(final Des cryptoKey) {
<span class="nc" id="L1907">    this.cryptoKey = cryptoKey;</span>
<span class="nc" id="L1908">  }</span>

  /**
   * @return the hostId
   */
  public String getHostId() {
<span class="fc" id="L1914">    return hostId;</span>
  }

  /**
   * @param hostId the hostId to set
   */
  public void setHostId(final String hostId) {
<span class="fc" id="L1921">    this.hostId = hostId;</span>
<span class="fc" id="L1922">  }</span>

  /**
   * @return the adminName
   */
  public String getAdminName() {
<span class="fc" id="L1928">    return adminName;</span>
  }

  /**
   * @param adminName the adminName to set
   */
  public void setAdminName(final String adminName) {
<span class="fc" id="L1935">    this.adminName = adminName;</span>
<span class="fc" id="L1936">  }</span>

  /**
   * @return the constraintLimitHandler
   */
  public FtpConstraintLimitHandler getConstraintLimitHandler() {
<span class="fc" id="L1942">    return constraintLimitHandler;</span>
  }

  /**
   * @param constraintLimitHandler the constraintLimitHandler to set
   */
  public void setConstraintLimitHandler(
      final FtpConstraintLimitHandler constraintLimitHandler) {
<span class="fc" id="L1950">    this.constraintLimitHandler = constraintLimitHandler;</span>
<span class="fc" id="L1951">  }</span>

  /**
   * @return the snmpConfig
   */
  public String getSnmpConfig() {
<span class="fc" id="L1957">    return snmpConfig;</span>
  }

  /**
   * @param snmpConfig the snmpConfig to set
   */
  public void setSnmpConfig(final String snmpConfig) {
<span class="fc" id="L1964">    this.snmpConfig = snmpConfig;</span>
<span class="fc" id="L1965">  }</span>

  /**
   * @return the agentSnmp
   */
  public WaarpSnmpAgent getAgentSnmp() {
<span class="fc" id="L1971">    return agentSnmp;</span>
  }

  /**
   * @param agentSnmp the agentSnmp to set
   */
  public void setAgentSnmp(final WaarpSnmpAgent agentSnmp) {
<span class="fc" id="L1978">    this.agentSnmp = agentSnmp;</span>
<span class="fc" id="L1979">  }</span>

  /**
   * @return the ftpMib
   */
  public FtpPrivateMib getFtpMib() {
<span class="fc" id="L1985">    return ftpMib;</span>
  }

  /**
   * @param ftpMib the ftpMib to set
   */
  public void setFtpMib(final FtpPrivateMib ftpMib) {
<span class="fc" id="L1992">    this.ftpMib = ftpMib;</span>
<span class="fc" id="L1993">  }</span>

  /**
   * @return the monitoring
   */
  public FtpMonitoring getMonitoring() {
<span class="fc" id="L1999">    return monitoring;</span>
  }

  /**
   * @param monitoring the monitoring to set
   */
  public void setMonitoring(final FtpMonitoring monitoring) {
<span class="fc" id="L2006">    this.monitoring = monitoring;</span>
<span class="fc" id="L2007">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>