<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileBasedConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Gateway Ftp</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.ftp.config</a> &gt; <span class="el_source">FileBasedConfiguration.java</span></div><h1>FileBasedConfiguration.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.gateway.ftp.config;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.ChannelGroupFuture;
import io.netty.channel.group.ChannelGroupFutureListener;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.traffic.AbstractTrafficShapingHandler;
import io.netty.util.concurrent.EventExecutorGroup;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.waarp.common.crypto.Des;
import org.waarp.common.crypto.ssl.WaarpSecureKeyStore;
import org.waarp.common.crypto.ssl.WaarpSslContextFactory;
import org.waarp.common.database.DbAdmin;
import org.waarp.common.database.DbPreparedStatement;
import org.waarp.common.database.exception.WaarpDatabaseNoConnectionException;
import org.waarp.common.database.exception.WaarpDatabaseSqlException;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.exception.CryptoException;
import org.waarp.common.exception.InvalidArgumentException;
import org.waarp.common.file.AbstractDir;
import org.waarp.common.file.DirInterface;
import org.waarp.common.file.FileParameterInterface;
import org.waarp.common.file.filesystembased.FilesystemBasedFileParameterImpl;
import org.waarp.common.file.filesystembased.specific.FilesystemBasedDirJdkAbstract;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.common.utility.WaarpThreadFactory;
import org.waarp.common.xml.XmlDecl;
import org.waarp.common.xml.XmlHash;
import org.waarp.common.xml.XmlType;
import org.waarp.common.xml.XmlUtil;
import org.waarp.common.xml.XmlValue;
import org.waarp.ftp.core.config.FtpConfiguration;
import org.waarp.ftp.core.control.BusinessHandler;
import org.waarp.ftp.core.control.ftps.FtpsInitializer;
import org.waarp.ftp.core.data.handler.DataBusinessHandler;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.exception.FtpUnknownFieldException;
import org.waarp.gateway.ftp.adminssl.HttpSslInitializer;
import org.waarp.gateway.ftp.control.FtpConstraintLimitHandler;
import org.waarp.gateway.ftp.database.DbConstantFtp;
import org.waarp.gateway.ftp.database.data.DbTransferLog;
import org.waarp.gateway.ftp.database.model.DbModelFactoryFtp;
import org.waarp.gateway.ftp.exec.AbstractExecutor;
import org.waarp.gateway.ftp.exec.LocalExecClient;
import org.waarp.gateway.ftp.file.SimpleAuth;
import org.waarp.gateway.ftp.snmp.FtpMonitoring;
import org.waarp.gateway.ftp.snmp.FtpPrivateMib;
import org.waarp.gateway.ftp.snmp.FtpVariableFactory;
import org.waarp.snmp.SnmpConfiguration;
import org.waarp.snmp.WaarpMOFactory;
import org.waarp.snmp.WaarpSnmpAgent;

import java.io.File;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * FtpConfiguration based on a XML file
 */
public class FileBasedConfiguration extends FtpConfiguration {
  private static final String ERROR_DURING_WRITE_AUTHENTICATION_FILE =
      &quot;Error during Write Authentication file&quot;;

  private static final String UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE =
      &quot;Unable to find LocalExec Address in Config file&quot;;

  /**
   * Internal Logger
   */
<span class="fc" id="L105">  private static final WaarpLogger logger =</span>
<span class="fc" id="L106">      WaarpLoggerFactory.getLogger(FileBasedConfiguration.class);</span>

  /**
   * SERVER HOSTID
   */
  private static final String XML_SERVER_HOSTID = &quot;hostid&quot;;
  /**
   * Authentication
   */
  private static final String XML_AUTHENTIFICATION_FILE = &quot;authentfile&quot;;
  /**
   * SERVER CRYPTO for Password
   */
  private static final String XML_PATH_CRYPTOKEY = &quot;cryptokey&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L124">  private static final XmlDecl[] configIdentityDecls = {</span>
      // identity
      new XmlDecl(XmlType.STRING, XML_SERVER_HOSTID),
      new XmlDecl(XmlType.STRING, XML_PATH_CRYPTOKEY),
      new XmlDecl(XmlType.STRING, XML_AUTHENTIFICATION_FILE)
  };
  /**
   * Use HTTP compression for R66 HTTP connection
   */
  private static final String XML_USEHTTPCOMP = &quot;usehttpcomp&quot;;
  /**
   * Use external Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_USELOCALEXEC = &quot;uselocalexec&quot;;

  /**
   * Address of Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_LEXECADDR = &quot;lexecaddr&quot;;

  /**
   * Port of Waarp Local Exec for ExecTask and ExecMoveTask
   */
  private static final String XML_LEXECPORT = &quot;lexecport&quot;;
  /**
   * ADMINISTRATOR SERVER NAME (shutdown)
   */
  private static final String XML_SERVER_ADMIN = &quot;serveradmin&quot;;
  /**
   * SERVER PASSWORD (shutdown)
   */
  private static final String XML_SERVER_PASSWD = &quot;serverpasswd&quot;; //NOSONAR
  /**
   * SERVER SSL STOREKEY PATH ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYPATH = &quot;admkeypath&quot;;

  /**
   * SERVER SSL KEY PASS ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYPASS = &quot;admkeypass&quot;;

  /**
   * SERVER SSL STOREKEY PASS ADMIN
   */
  private static final String XML_PATH_ADMIN_KEYSTOREPASS = &quot;admkeystorepass&quot;;
  /**
   * HTTP Admin Directory
   */
  private static final String XML_HTTPADMINPATH = &quot;httpadmin&quot;;
  /**
   * Monitoring: snmp configuration file (if empty, no snmp support)
   */
  private static final String XML_MONITOR_SNMP_CONFIG = &quot;snmpconfig&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L182">  private static final XmlDecl[] configServerParamDecls = {</span>
      // server
      new XmlDecl(XmlType.BOOLEAN, XML_USELOCALEXEC),
      new XmlDecl(XmlType.STRING, XML_LEXECADDR),
      new XmlDecl(XmlType.INTEGER, XML_LEXECPORT),
      new XmlDecl(XmlType.STRING, XML_SERVER_ADMIN),
      new XmlDecl(XmlType.STRING, XML_SERVER_PASSWD),
      new XmlDecl(XmlType.BOOLEAN, XML_USEHTTPCOMP),
      new XmlDecl(XmlType.STRING, XML_HTTPADMINPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYSTOREPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_ADMIN_KEYPASS),
      new XmlDecl(XmlType.STRING, XML_MONITOR_SNMP_CONFIG)
  };
  /**
   * SERVER PORT
   */
  private static final String XML_SERVER_PORT = &quot;serverport&quot;;
  /**
   * SERVER ADDRESS if any
   */
  private static final String XML_SERVER_ADDRESS = &quot;serveraddress&quot;;
  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String XML_RANGE_PORT_MIN = &quot;portmin&quot;;

  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String XML_RANGE_PORT_MAX = &quot;portmax&quot;;
  /**
   * SERVER HTTP PORT MONITORING
   */
  private static final String XML_SERVER_HTTP_PORT = &quot;serverhttpport&quot;;
  /**
   * SERVER HTTPS PORT ADMINISTRATION
   */
  private static final String XML_SERVER_HTTPS_PORT = &quot;serverhttpsport&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L225">  private static final XmlDecl[] configNetworkServerDecls = {</span>
      // network
      new XmlDecl(XmlType.INTEGER, XML_SERVER_PORT),
      new XmlDecl(XmlType.STRING, XML_SERVER_ADDRESS),
      new XmlDecl(XmlType.INTEGER, XML_RANGE_PORT_MIN),
      new XmlDecl(XmlType.INTEGER, XML_RANGE_PORT_MAX),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_HTTP_PORT),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_HTTPS_PORT)
  };
  /**
   * Database Driver as of oracle, mysql, postgresql, h2
   */
  private static final String XML_DBDRIVER = &quot;dbdriver&quot;;

  /**
   * Database Server connection string as of jdbc:type://[host:port],[failoverhost:port]
   * .../[database][?propertyName1][ =propertyValue1][&amp;propertyName2][=propertyValue2]...
   */
  private static final String XML_DBSERVER = &quot;dbserver&quot;;

  /**
   * Database User
   */
  private static final String XML_DBUSER = &quot;dbuser&quot;;

  /**
   * Database Password
   */
  private static final String XML_DBPASSWD = &quot;dbpasswd&quot;;//NOSONAR
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L257">  private static final XmlDecl[] configDbDecls = {</span>
      // db
      new XmlDecl(XmlType.STRING, XML_DBDRIVER),
      new XmlDecl(XmlType.STRING, XML_DBSERVER),
      new XmlDecl(XmlType.STRING, XML_DBUSER),
      new XmlDecl(XmlType.STRING, XML_DBPASSWD)
  };
  /**
   * Should a file be deleted when a Store like command is aborted
   */
  private static final String XML_DELETEONABORT = &quot;deleteonabort&quot;;
  /**
   * Default number of threads in pool for Server.
   */
  private static final String XML_SERVER_THREAD = &quot;serverthread&quot;;

  /**
   * Default number of threads in pool for Client.
   */
  private static final String XML_CLIENT_THREAD = &quot;clientthread&quot;;
  /**
   * Memory Limit to use.
   */
  private static final String XML_MEMORY_LIMIT = &quot;memorylimit&quot;;

  /**
   * Limit for Session
   */
  private static final String XML_LIMITSESSION = &quot;sessionlimit&quot;;

  /**
   * Limit for Global
   */
  private static final String XML_LIMITGLOBAL = &quot;globallimit&quot;;
  /**
   * Delay between two checks for Limit
   */
  private static final String XML_LIMITDELAY = &quot;delaylimit&quot;;
  /**
   * Nb of milliseconds after connection is in timeout
   */
  private static final String XML_TIMEOUTCON = &quot;timeoutcon&quot;;
  /**
   * Size by default of block size for receive/sending files. Should be a
   * multiple of 8192 (maximum = 64K due to
   * block limitation to 2 bytes)
   */
  private static final String XML_BLOCKSIZE = &quot;blocksize&quot;;
  /**
   * Should a file MD5 SHA1 be computed using NIO
   */
  private static final String XML_USENIO = &quot;usenio&quot;;

  /**
   * Should a file MD5 be computed using FastMD5
   */
  private static final String XML_USEFASTMD5 = &quot;usefastmd5&quot;;

  /**
   * If using Fast MD5, should we used the binary JNI library, empty meaning
   * no
   */
  private static final String XML_FASTMD5 = &quot;fastmd5&quot;;
  /**
   * Usage of CPU Limit
   */
  private static final String XML_CSTRT_USECPULIMIT = &quot;usecpulimit&quot;;

  /**
   * Usage of JDK CPU Limit (True) or SysMon CPU Limit
   */
  private static final String XML_CSTRT_USECPUJDKLIMIT = &quot;usejdkcpulimit&quot;;

  /**
   * CPU LIMIT between 0 and 1, where 1 stands for no limit
   */
  private static final String XML_CSTRT_CPULIMIT = &quot;cpulimit&quot;;
  /**
   * Connection limit where 0 stands for no limit
   */
  private static final String XML_CSTRT_CONNLIMIT = &quot;connlimit&quot;;
  /**
   * CPU LOW limit to apply increase of throttle
   */
  private static final String XML_CSTRT_LOWCPULIMIT = &quot;lowcpulimit&quot;;
  /**
   * CPU HIGH limit to apply decrease of throttle, 0 meaning no throttle
   * activated
   */
  private static final String XML_CSTRT_HIGHCPULIMIT = &quot;highcpulimit&quot;;
  /**
   * PERCENTAGE DECREASE of Bandwidth
   */
  private static final String XML_CSTRT_PERCENTDECREASE = &quot;percentdecrease&quot;;
  /**
   * Delay between 2 checks of throttle test
   */
  private static final String XML_CSTRT_DELAYTHROTTLE = &quot;delaythrottle&quot;;
  /**
   * Bandwidth low limit to not got below
   */
  private static final String XML_CSTRT_LIMITLOWBANDWIDTH = &quot;limitlowbandwidth&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L362">  private static final XmlDecl[] configLimitDecls = {</span>
      // limit
      new XmlDecl(XmlType.BOOLEAN, XML_DELETEONABORT),
      new XmlDecl(XmlType.LONG, XML_LIMITSESSION),
      new XmlDecl(XmlType.LONG, XML_LIMITGLOBAL),
      new XmlDecl(XmlType.LONG, XML_LIMITDELAY),
      new XmlDecl(XmlType.INTEGER, XML_SERVER_THREAD),
      new XmlDecl(XmlType.INTEGER, XML_CLIENT_THREAD),
      new XmlDecl(XmlType.LONG, XML_MEMORY_LIMIT),
      new XmlDecl(XmlType.BOOLEAN, XML_CSTRT_USECPULIMIT),
      new XmlDecl(XmlType.BOOLEAN, XML_CSTRT_USECPUJDKLIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_CPULIMIT),
      new XmlDecl(XmlType.INTEGER, XML_CSTRT_CONNLIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_LOWCPULIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_HIGHCPULIMIT),
      new XmlDecl(XmlType.DOUBLE, XML_CSTRT_PERCENTDECREASE),
      new XmlDecl(XmlType.LONG, XML_CSTRT_LIMITLOWBANDWIDTH),
      new XmlDecl(XmlType.LONG, XML_CSTRT_DELAYTHROTTLE),
      new XmlDecl(XmlType.LONG, XML_TIMEOUTCON),
      new XmlDecl(XmlType.BOOLEAN, XML_USENIO),
      new XmlDecl(XmlType.BOOLEAN, XML_USEFASTMD5),
      new XmlDecl(XmlType.STRING, XML_FASTMD5),
      new XmlDecl(XmlType.INTEGER, XML_BLOCKSIZE)
  };

  /**
   * RETRIEVE COMMAND
   */
  public static final String XML_RETRIEVE_COMMAND = &quot;retrievecmd&quot;;

  /**
   * STORE COMMAND
   */
  public static final String XML_STORE_COMMAND = &quot;storecmd&quot;;

  /**
   * DELAY RETRIEVE COMMAND
   */
  public static final String XML_DELAYRETRIEVE_COMMAND = &quot;retrievedelay&quot;;

  /**
   * DELAY STORE COMMAND
   */
  public static final String XML_DELAYSTORE_COMMAND = &quot;storedelay&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L409">  private static final XmlDecl[] configExecDecls = {</span>
      // Exec
      new XmlDecl(XmlType.STRING, XML_RETRIEVE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYRETRIEVE_COMMAND),
      new XmlDecl(XmlType.STRING, XML_STORE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYSTORE_COMMAND)
  };
  /**
   * Base Directory
   */
  private static final String XML_SERVER_HOME = &quot;serverhome&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L423">  private static final XmlDecl[] configDirectoryDecls = {</span>
      // directory
      new XmlDecl(XmlType.STRING, XML_SERVER_HOME)
  };
  /**
   * SERVER SSL STOREKEY PATH
   */
  private static final String XML_PATH_KEYPATH = &quot;keypath&quot;;

  /**
   * SERVER SSL KEY PASS
   */
  private static final String XML_PATH_KEYPASS = &quot;keypass&quot;;

  /**
   * SERVER SSL STOREKEY PASS
   */
  private static final String XML_PATH_KEYSTOREPASS = &quot;keystorepass&quot;;

  /**
   * SERVER SSL TRUSTSTOREKEY PATH
   */
  private static final String XML_PATH_TRUSTKEYPATH = &quot;trustkeypath&quot;;

  /**
   * SERVER SSL TRUSTSTOREKEY PASS
   */
  private static final String XML_PATH_TRUSTKEYSTOREPASS = &quot;trustkeystorepass&quot;;

  /**
   * SERVER SSL Use TrustStore for Client Authentication
   */
  private static final String XML_USECLIENT_AUTHENT =
      &quot;trustuseclientauthenticate&quot;;
  /**
   * SERVER SSL Use Implicit FTPS
   */
  private static final String XML_IMPLICIT_FTPS = &quot;useimplicitftps&quot;;
  /**
   * SERVER SSL Use Explicit FTPS
   */
  private static final String XML_EXPLICIT_FTPS = &quot;useexplicitftps&quot;;

  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L469">  private static final XmlDecl[] configSslDecls = {</span>
      // ssl
      new XmlDecl(XmlType.STRING, XML_PATH_KEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_KEYSTOREPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_KEYPASS),
      new XmlDecl(XmlType.STRING, XML_PATH_TRUSTKEYPATH),
      new XmlDecl(XmlType.STRING, XML_PATH_TRUSTKEYSTOREPASS),
      new XmlDecl(XmlType.BOOLEAN, XML_USECLIENT_AUTHENT),
      new XmlDecl(XmlType.BOOLEAN, XML_IMPLICIT_FTPS),
      new XmlDecl(XmlType.BOOLEAN, XML_EXPLICIT_FTPS)
  };
  /**
   * Overall structure of the Configuration file
   */
  private static final String XML_ROOT = &quot;/config/&quot;;
  private static final String XML_IDENTITY = &quot;identity&quot;;
  private static final String XML_SERVER = &quot;server&quot;;
  private static final String XML_DIRECTORY = &quot;directory&quot;;
  private static final String XML_LIMIT = &quot;limit&quot;;
  private static final String XML_NETWORK = &quot;network&quot;;
  private static final String XML_EXEC = &quot;exec&quot;;
  private static final String XML_DB = &quot;db&quot;;
  private static final String XML_SSL = &quot;ssl&quot;;
  /**
   * Global Structure for Server Configuration
   */
<span class="fc" id="L495">  private static final XmlDecl[] configServer = {</span>
      new XmlDecl(XML_IDENTITY, XmlType.XVAL, XML_ROOT + XML_IDENTITY,
                  configIdentityDecls, false),
      new XmlDecl(XML_SERVER, XmlType.XVAL, XML_ROOT + XML_SERVER,
                  configServerParamDecls, false),
      new XmlDecl(XML_NETWORK, XmlType.XVAL, XML_ROOT + XML_NETWORK,
                  configNetworkServerDecls, false),
      new XmlDecl(XML_EXEC, XmlType.XVAL, XML_ROOT + XML_EXEC, configExecDecls,
                  false),
      new XmlDecl(XML_DIRECTORY, XmlType.XVAL, XML_ROOT + XML_DIRECTORY,
                  configDirectoryDecls, false),
      new XmlDecl(XML_LIMIT, XmlType.XVAL, XML_ROOT + XML_LIMIT,
                  configLimitDecls, false),
      new XmlDecl(XML_DB, XmlType.XVAL, XML_ROOT + XML_DB, configDbDecls,
                  false),
      new XmlDecl(XML_SSL, XmlType.XVAL, XML_ROOT + XML_SSL, configSslDecls,
                  false)
  };

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_ROOT = &quot;authent&quot;;
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_ENTRY = &quot;entry&quot;;
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTIFICATION_BASED =
      '/' + XML_AUTHENTIFICATION_ROOT + '/' + XML_AUTHENTIFICATION_ENTRY;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_USER = &quot;user&quot;;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_PASSWD = &quot;passwd&quot;;//NOSONAR
  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_PASSWDFILE = //NOSONAR
      &quot;passwdfile&quot;;//NOSONAR

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_ACCOUNT = &quot;account&quot;;

  /**
   * Authentication Fields
   */
  private static final String XML_AUTHENTICATION_ADMIN = &quot;admin&quot;;
  /**
   * Structure of the Configuration file
   */
<span class="fc" id="L555">  private static final XmlDecl[] configAuthenticationDecls = {</span>
      // identity
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_USER),
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_PASSWDFILE),
      new XmlDecl(XmlType.STRING, XML_AUTHENTICATION_PASSWD),
      new XmlDecl(XML_AUTHENTICATION_ACCOUNT, XmlType.STRING,
                  XML_AUTHENTICATION_ACCOUNT, true),
      new XmlDecl(XmlType.BOOLEAN, XML_AUTHENTICATION_ADMIN),
      // Exec
      new XmlDecl(XmlType.STRING, XML_RETRIEVE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYRETRIEVE_COMMAND),
      new XmlDecl(XmlType.STRING, XML_STORE_COMMAND),
      new XmlDecl(XmlType.LONG, XML_DELAYSTORE_COMMAND)
  };
  /**
   * Global Structure for Server Configuration
   */
<span class="fc" id="L572">  private static final XmlDecl[] authentElements = {</span>
      new XmlDecl(XML_AUTHENTIFICATION_ENTRY, XmlType.XVAL,
                  XML_AUTHENTIFICATION_BASED, configAuthenticationDecls, true)
  };

  /**
   * RANGE of PORT for Passive Mode
   */
  private static final String RANGE_PORT = &quot;FTP_RANGE_PORT&quot;;
  /**
   * Use to access directly the configuration
   */
  public static FileBasedConfiguration fileBasedConfiguration;
  /**
   * All authentications
   */
<span class="fc" id="L588">  private ConcurrentHashMap&lt;String, SimpleAuth&gt; authentications =</span>
      new ConcurrentHashMap&lt;String, SimpleAuth&gt;();

  /**
   * File containing the authentications
   */
  private String authenticationFile;

  /**
   * Default HTTP server port
   */
<span class="fc" id="L599">  private int serverHttpsPort = 8067;</span>
  /**
   * Http Admin base
   */
<span class="fc" id="L603">  private String httpBasePath = &quot;src/main/admin/&quot;;</span>
  /**
   * Does this server will try to compress HTTP connections
   */
  private boolean useHttpCompression;

  /**
   * Does this server will use Waarp LocalExec Daemon for Execute
   */
  private boolean useLocalExec;

  /**
   * Crypto Key
   */
  private Des cryptoKey;
  /**
   * Server Administration Key
   */
  private byte[] serverAdminKey;
  /**
   * FTP server ID
   */
<span class="fc" id="L625">  private String hostId = &quot;noId&quot;;</span>
  /**
   * Admin name Id
   */
<span class="fc" id="L629">  private String adminName = &quot;noAdmin&quot;;</span>
  /**
   * Limit on CPU and Connection
   */
  private FtpConstraintLimitHandler constraintLimitHandler;

  /**
   * List of all Http Channels to enable the close call on them using Netty
   * ChannelGroup
   */
  private ChannelGroup httpChannelGroup;
  /**
   * Bootstrap for Https server
   */
  private ServerBootstrap httpsBootstrap;
  /**
   * Worker Group for Http
   */
  private EventLoopGroup workerGroup;

  /**
   * ThreadPoolExecutor for Http and Https Server
   */
  private EventExecutorGroup httpExecutor;
  /**
   * Monitoring: snmp configuration file (empty means no snmp support)
   */
  private String snmpConfig;
  /**
   * SNMP Agent (if any)
   */
  private WaarpSnmpAgent agentSnmp;
  /**
   * Associated MIB
   */
  private FtpPrivateMib ftpMib;
  /**
   * Monitoring object
   */
  private FtpMonitoring monitoring;

  /**
   * @param classtype
   * @param businessHandler class that will be used for
   *     BusinessHandler
   * @param dataBusinessHandler class that will be used for
   *     DataBusinessHandler
   * @param fileParameter the FileParameter to use
   */
  public FileBasedConfiguration(Class&lt;?&gt; classtype,
                                Class&lt;? extends BusinessHandler&gt; businessHandler,
                                Class&lt;? extends DataBusinessHandler&gt; dataBusinessHandler,
                                FileParameterInterface fileParameter) {
<span class="fc" id="L682">    super(classtype, businessHandler, dataBusinessHandler, fileParameter);</span>
<span class="fc" id="L683">    computeNbThreads();</span>
<span class="fc" id="L684">  }</span>

  private static XmlValue[] configuration;
  private static XmlHash hashConfig;

  private boolean loadIdentity() {
<span class="fc" id="L690">    final XmlValue value = hashConfig.get(XML_SERVER_HOSTID);</span>
<span class="pc bpc" id="L691" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L692">      setHostId(value.getString());</span>
    } else {
<span class="nc" id="L694">      logger.error(&quot;Unable to find Host ID in Config file&quot;);</span>
<span class="nc" id="L695">      return false;</span>
    }
<span class="fc" id="L697">    return setCryptoKey();</span>
  }

  private boolean loadAuthentication() {
    // if no database, must load authentication from file
<span class="fc" id="L702">    final XmlValue value = hashConfig.get(XML_AUTHENTIFICATION_FILE);</span>
<span class="pc bpc" id="L703" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L704">      setAuthenticationFile(value.getString());</span>
<span class="fc" id="L705">      return initializeAuthent(getAuthenticationFile(), false);</span>
    } else {
<span class="nc" id="L707">      logger.warn(&quot;Unable to find Authentication file in Config file&quot;);</span>
<span class="nc" id="L708">      return false;</span>
    }
  }

  private boolean loadServerParam() {
<span class="fc" id="L713">    XmlValue value = hashConfig.get(XML_USEHTTPCOMP);</span>
<span class="pc bpc" id="L714" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L715">      setUseHttpCompression(value.getBoolean());</span>
    }
<span class="fc" id="L717">    value = hashConfig.get(XML_USELOCALEXEC);</span>
<span class="pc bpc" id="L718" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L719">      setUseLocalExec(value.getBoolean());</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">      if (isUseLocalExec()) {</span>
<span class="nc" id="L721">        value = hashConfig.get(XML_LEXECADDR);</span>
        String saddr;
        InetAddress addr;
<span class="nc bnc" id="L724" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L725">          saddr = value.getString();</span>
          try {
<span class="nc" id="L727">            addr = InetAddress.getByName(saddr);</span>
<span class="nc" id="L728">          } catch (final UnknownHostException e) {</span>
<span class="nc" id="L729">            logger.error(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
<span class="nc" id="L730">            return false;</span>
<span class="nc" id="L731">          }</span>
        } else {
<span class="nc" id="L733">          logger.warn(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
          try {
<span class="nc" id="L735">            addr = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 });</span>
<span class="nc" id="L736">          } catch (final UnknownHostException e) {</span>
<span class="nc" id="L737">            logger.error(UNABLE_TO_FIND_LOCAL_EXEC_ADDRESS_IN_CONFIG_FILE);</span>
<span class="nc" id="L738">            return false;</span>
<span class="nc" id="L739">          }</span>
        }
<span class="nc" id="L741">        value = hashConfig.get(XML_LEXECPORT);</span>
        int port;
<span class="nc bnc" id="L743" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L744">          port = value.getInteger();</span>
        } else {
<span class="nc" id="L746">          port = 9999;</span>
        }
<span class="nc" id="L748">        LocalExecClient.setAddress(new InetSocketAddress(addr, port));</span>
      }
    }
<span class="fc" id="L751">    value = hashConfig.get(XML_SERVER_ADMIN);</span>
<span class="pc bpc" id="L752" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L753">      setAdminName(value.getString());</span>
    } else {
<span class="nc" id="L755">      logger.error(&quot;Unable to find Administrator name in Config file&quot;);</span>
<span class="nc" id="L756">      return false;</span>
    }
<span class="pc bpc" id="L758" title="3 of 4 branches missed.">    if (getCryptoKey() == null &amp;&amp; !setCryptoKey()) {</span>
<span class="nc" id="L759">      logger.error(&quot;Unable to find Crypto Key in Config file&quot;);</span>
<span class="nc" id="L760">      return false;</span>
    }
    String passwd;
<span class="fc" id="L763">    value = hashConfig.get(XML_SERVER_PASSWD);</span>
<span class="pc bpc" id="L764" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L765">      passwd = value.getString();</span>
    } else {
<span class="nc" id="L767">      logger.error(&quot;Unable to find Password in Config file&quot;);</span>
<span class="nc" id="L768">      return false;</span>
    }
    byte[] decodedByteKeys;
    try {
<span class="fc" id="L772">      decodedByteKeys = getCryptoKey().decryptHexInBytes(passwd);</span>
<span class="nc" id="L773">    } catch (final Exception e) {</span>
<span class="nc" id="L774">      logger.error(</span>
          &quot;Unable to Decrypt Server Password in Config file from: &quot; + passwd,
          e);
<span class="nc" id="L777">      return false;</span>
<span class="fc" id="L778">    }</span>
<span class="fc" id="L779">    setSERVERKEY(decodedByteKeys);</span>
<span class="fc" id="L780">    value = hashConfig.get(XML_HTTPADMINPATH);</span>
<span class="pc bpc" id="L781" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L782">      logger.error(&quot;Unable to find Http Admin Base in Config file&quot;);</span>
<span class="nc" id="L783">      return false;</span>
    }
<span class="fc" id="L785">    final String path = value.getString();</span>
<span class="pc bpc" id="L786" title="2 of 4 branches missed.">    if (path == null || path.length() == 0) {</span>
<span class="nc" id="L787">      logger.warn(</span>
          &quot;Unable to set correct Http Admin Base in Config file. No HTTPS support will be used.&quot;);
<span class="nc" id="L789">      setHttpBasePath(null);</span>
    } else {
<span class="fc" id="L791">      final File file = new File(path);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">      if (!file.isDirectory()) {</span>
<span class="nc" id="L793">        logger.error(&quot;Http Admin is not a directory in Config file&quot;);</span>
<span class="nc" id="L794">        return false;</span>
      }
      try {
<span class="fc" id="L797">        setHttpBasePath(AbstractDir.normalizePath(file.getCanonicalPath()) +</span>
                        DirInterface.SEPARATOR);
<span class="nc" id="L799">      } catch (final IOException e1) {</span>
<span class="nc" id="L800">        logger.error(&quot;Unable to set Http Admin Path in Config file&quot;);</span>
<span class="nc" id="L801">        return false;</span>
<span class="fc" id="L802">      }</span>
    }
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">    if (getHttpBasePath() != null) {</span>
      // Key for HTTPS
<span class="fc" id="L806">      value = hashConfig.get(XML_PATH_ADMIN_KEYPATH);</span>
<span class="pc bpc" id="L807" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L808">        final String keypath = value.getString();</span>
<span class="pc bpc" id="L809" title="2 of 4 branches missed.">        if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L810">          logger.error(&quot;Bad Key Path&quot;);</span>
<span class="nc" id="L811">          return false;</span>
        }
<span class="fc" id="L813">        value = hashConfig.get(XML_PATH_ADMIN_KEYSTOREPASS);</span>
<span class="pc bpc" id="L814" title="2 of 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L815">          logger.error(&quot;Unable to find KeyStore Passwd&quot;);</span>
<span class="nc" id="L816">          return false;</span>
        }
<span class="fc" id="L818">        final String keystorepass = value.getString();</span>
<span class="pc bpc" id="L819" title="2 of 4 branches missed.">        if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L820">          logger.error(&quot;Bad KeyStore Passwd&quot;);</span>
<span class="nc" id="L821">          return false;</span>
        }
<span class="fc" id="L823">        value = hashConfig.get(XML_PATH_ADMIN_KEYPASS);</span>
<span class="pc bpc" id="L824" title="2 of 4 branches missed.">        if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L825">          logger.error(&quot;Unable to find Key Passwd&quot;);</span>
<span class="nc" id="L826">          return false;</span>
        }
<span class="fc" id="L828">        final String keypass = value.getString();</span>
<span class="pc bpc" id="L829" title="2 of 4 branches missed.">        if (keypass == null || keypass.length() == 0) {</span>
<span class="nc" id="L830">          logger.error(&quot;Bad Key Passwd&quot;);</span>
<span class="nc" id="L831">          return false;</span>
        }
        try {
<span class="fc" id="L834">          HttpSslInitializer.waarpSecureKeyStore =</span>
              new WaarpSecureKeyStore(keypath, keystorepass, keypass);
<span class="nc" id="L836">        } catch (final CryptoException e) {</span>
<span class="nc" id="L837">          logger.error(&quot;Bad SecureKeyStore construction for AdminSsl&quot;);</span>
<span class="nc" id="L838">          return false;</span>
<span class="fc" id="L839">        }</span>
        // No client authentication
<span class="fc" id="L841">        HttpSslInitializer.waarpSecureKeyStore.initEmptyTrustStore();</span>
<span class="fc" id="L842">        HttpSslInitializer.waarpSslContextFactory =</span>
            new WaarpSslContextFactory(HttpSslInitializer.waarpSecureKeyStore,
                                       true);
      }
    }
<span class="fc" id="L847">    value = hashConfig.get(XML_MONITOR_SNMP_CONFIG);</span>
<span class="pc bpc" id="L848" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L849">      setSnmpConfig(value.getString());</span>
<span class="fc" id="L850">      logger.warn(&quot;SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="fc" id="L851">      final File snmpfile = new File(getSnmpConfig());</span>
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">      if (snmpfile.canRead()) {</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        if (!SnmpConfiguration.setConfigurationFromXml(snmpfile)) {</span>
<span class="nc" id="L854">          logger.warn(&quot;Bad SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="nc" id="L855">          setSnmpConfig(null);</span>
        }
      } else {
<span class="nc" id="L858">        logger.warn(&quot;Cannot read SNMP configuration file: &quot; + getSnmpConfig());</span>
<span class="nc" id="L859">        setSnmpConfig(null);</span>
      }
<span class="fc" id="L861">    } else {</span>
<span class="nc" id="L862">      logger.warn(&quot;NO SNMP configuration file&quot;);</span>
    }
<span class="fc" id="L864">    return true;</span>
  }

  private boolean loadDirectory() {
<span class="fc" id="L868">    final XmlValue value = hashConfig.get(XML_SERVER_HOME);</span>
<span class="pc bpc" id="L869" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L870">      logger.error(&quot;Unable to find Home in Config file&quot;);</span>
<span class="nc" id="L871">      return false;</span>
    }
<span class="fc" id="L873">    final String path = value.getString();</span>
<span class="fc" id="L874">    final File file = new File(path);</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">    if (!file.isDirectory()) {</span>
<span class="nc" id="L876">      logger.error(&quot;Home is not a directory in Config file&quot;);</span>
<span class="nc" id="L877">      return false;</span>
    }
    try {
<span class="fc" id="L880">      setBaseDirectory(AbstractDir.normalizePath(file.getCanonicalPath()));</span>
<span class="nc" id="L881">    } catch (final IOException e1) {</span>
<span class="nc" id="L882">      logger.error(&quot;Unable to set Home in Config file: &quot; + path);</span>
<span class="nc" id="L883">      return false;</span>
<span class="fc" id="L884">    }</span>
<span class="fc" id="L885">    return true;</span>
  }

  private boolean loadLimit(boolean updateLimit) {
<span class="fc" id="L889">    XmlValue value = hashConfig.get(XML_LIMITGLOBAL);</span>
<span class="pc bpc" id="L890" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L891">      serverGlobalReadLimit = value.getLong();</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">      if (serverGlobalReadLimit &lt;= 0) {</span>
<span class="fc" id="L893">        serverGlobalReadLimit = 0;</span>
      }
<span class="fc" id="L895">      serverGlobalWriteLimit = serverGlobalReadLimit;</span>
<span class="fc" id="L896">      logger.info(&quot;Global Limit: {}&quot;, serverGlobalReadLimit);</span>
    }
<span class="fc" id="L898">    value = hashConfig.get(XML_LIMITSESSION);</span>
<span class="pc bpc" id="L899" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L900">      serverChannelReadLimit = value.getLong();</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">      if (serverChannelReadLimit &lt;= 0) {</span>
<span class="fc" id="L902">        serverChannelReadLimit = 0;</span>
      }
<span class="fc" id="L904">      serverChannelWriteLimit = serverChannelReadLimit;</span>
<span class="fc" id="L905">      logger.info(&quot;SessionInterface Limit: {}&quot;, serverChannelReadLimit);</span>
    }
<span class="fc" id="L907">    delayLimit = AbstractTrafficShapingHandler.DEFAULT_CHECK_INTERVAL;</span>
<span class="fc" id="L908">    value = hashConfig.get(XML_LIMITDELAY);</span>
<span class="pc bpc" id="L909" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L910">      delayLimit = (value.getLong() / 10) * 10;</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">      if (delayLimit &lt;= 0) {</span>
<span class="nc" id="L912">        delayLimit = 0;</span>
      }
<span class="fc" id="L914">      logger.info(&quot;Delay Limit: {}&quot;, delayLimit);</span>
    }
<span class="fc" id="L916">    boolean useCpuLimit = false;</span>
<span class="fc" id="L917">    boolean useCpuLimitJDK = false;</span>
<span class="fc" id="L918">    double cpulimit = 1.0;</span>
<span class="fc" id="L919">    value = hashConfig.get(XML_CSTRT_USECPULIMIT);</span>
<span class="pc bpc" id="L920" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L921">      useCpuLimit = value.getBoolean();</span>
<span class="fc" id="L922">      value = hashConfig.get(XML_CSTRT_USECPUJDKLIMIT);</span>
<span class="pc bpc" id="L923" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L924">        useCpuLimitJDK = value.getBoolean();</span>
      }
<span class="fc" id="L926">      value = hashConfig.get(XML_CSTRT_CPULIMIT);</span>
<span class="pc bpc" id="L927" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L928">        cpulimit = value.getDouble();</span>
      }
    }
<span class="fc" id="L931">    int connlimit = 0;</span>
<span class="fc" id="L932">    value = hashConfig.get(XML_CSTRT_CONNLIMIT);</span>
<span class="pc bpc" id="L933" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L934">      connlimit = value.getInteger();</span>
    }
<span class="fc" id="L936">    double lowcpuLimit = 0;</span>
<span class="fc" id="L937">    double highcpuLimit = 0;</span>
<span class="fc" id="L938">    double percentageDecrease = 0;</span>
<span class="fc" id="L939">    long delay = 1000000;</span>
<span class="fc" id="L940">    long limitLowBandwidth = 4096;</span>
<span class="fc" id="L941">    value = hashConfig.get(XML_CSTRT_LOWCPULIMIT);</span>
<span class="pc bpc" id="L942" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L943">      lowcpuLimit = value.getDouble();</span>
    }
<span class="fc" id="L945">    value = hashConfig.get(XML_CSTRT_HIGHCPULIMIT);</span>
<span class="pc bpc" id="L946" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L947">      highcpuLimit = value.getDouble();</span>
    }
<span class="fc" id="L949">    value = hashConfig.get(XML_CSTRT_PERCENTDECREASE);</span>
<span class="pc bpc" id="L950" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L951">      percentageDecrease = value.getDouble();</span>
    }
<span class="fc" id="L953">    value = hashConfig.get(XML_CSTRT_DELAYTHROTTLE);</span>
<span class="pc bpc" id="L954" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L955">      delay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L957">    value = hashConfig.get(XML_CSTRT_LIMITLOWBANDWIDTH);</span>
<span class="pc bpc" id="L958" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L959">      limitLowBandwidth = value.getLong();</span>
    }
<span class="fc" id="L961">    value = hashConfig.get(XML_TIMEOUTCON);</span>
<span class="pc bpc" id="L962" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L963">      setTimeoutCon((value.getLong() / 10) * 10);</span>
    }
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">    if (highcpuLimit &gt; 0) {</span>
<span class="nc" id="L966">      setConstraintLimitHandler(</span>
<span class="nc" id="L967">          new FtpConstraintLimitHandler(getTimeoutCon(), useCpuLimit,</span>
                                        useCpuLimitJDK, cpulimit, connlimit,
                                        lowcpuLimit, highcpuLimit,
                                        percentageDecrease, null, delay,
                                        limitLowBandwidth));
    } else {
<span class="fc" id="L973">      setConstraintLimitHandler(</span>
<span class="fc" id="L974">          new FtpConstraintLimitHandler(getTimeoutCon(), useCpuLimit,</span>
                                        useCpuLimitJDK, cpulimit, connlimit));
    }
<span class="fc" id="L977">    value = hashConfig.get(XML_SERVER_THREAD);</span>
<span class="pc bpc" id="L978" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L979">      setServerThread(value.getInteger());</span>
    }
<span class="fc" id="L981">    value = hashConfig.get(XML_CLIENT_THREAD);</span>
<span class="pc bpc" id="L982" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L983">      setClientThread(value.getInteger());</span>
    }
<span class="pc bpc" id="L985" title="2 of 4 branches missed.">    if (getServerThread() == 0 || getClientThread() == 0) {</span>
<span class="nc" id="L986">      computeNbThreads();</span>
    }
<span class="fc" id="L988">    value = hashConfig.get(XML_MEMORY_LIMIT);</span>
<span class="pc bpc" id="L989" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L990">      long lvalue = value.getLong();</span>
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">      if (lvalue &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L992">        lvalue = Integer.MAX_VALUE;</span>
      }
<span class="fc" id="L994">      setMaxGlobalMemory((int) lvalue);</span>
    }
<span class="fc" id="L996">    ((FilesystemBasedFileParameterImpl) getFileParameter()).deleteOnAbort =</span>
        false;
<span class="fc" id="L998">    value = hashConfig.get(XML_USENIO);</span>
<span class="pc bpc" id="L999" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1000">      FilesystemBasedFileParameterImpl.useNio = value.getBoolean();</span>
    }
<span class="fc" id="L1002">    value = hashConfig.get(XML_USEFASTMD5);</span>
<span class="pc bpc" id="L1003" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1004">      FilesystemBasedDigest.setUseFastMd5(value.getBoolean());</span>
    }
<span class="fc" id="L1006">    value = hashConfig.get(XML_BLOCKSIZE);</span>
<span class="pc bpc" id="L1007" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1008">      setBlocksize(value.getInteger());</span>
    }
<span class="fc" id="L1010">    value = hashConfig.get(XML_DELETEONABORT);</span>
<span class="pc bpc" id="L1011" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1012">      setDeleteOnAbort(value.getBoolean());</span>
    }
    // We use Apache Commons IO
<span class="fc" id="L1015">    FilesystemBasedDirJdkAbstract.ueApacheCommonsIo = true;</span>
<span class="fc" id="L1016">    return true;</span>
  }

  private boolean loadNetworkServer() {
<span class="fc" id="L1020">    XmlValue value = hashConfig.get(XML_SERVER_PORT);</span>
    int port;
<span class="pc bpc" id="L1022" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1023">      port = value.getInteger();</span>
    } else {
<span class="nc" id="L1025">      port = 21;</span>
    }
<span class="fc" id="L1027">    setServerPort(port);</span>
<span class="fc" id="L1028">    value = hashConfig.get(XML_SERVER_ADDRESS);</span>
<span class="fc" id="L1029">    String address = null;</span>
<span class="pc bpc" id="L1030" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1031">      address = value.getString();</span>
    }
<span class="fc" id="L1033">    setServerAddress(address);</span>
<span class="fc" id="L1034">    int min = 100;</span>
<span class="fc" id="L1035">    int max = 65535;</span>
<span class="fc" id="L1036">    value = hashConfig.get(XML_RANGE_PORT_MIN);</span>
<span class="pc bpc" id="L1037" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1038">      min = value.getInteger();</span>
    }
<span class="fc" id="L1040">    value = hashConfig.get(XML_RANGE_PORT_MAX);</span>
<span class="pc bpc" id="L1041" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1042">      max = value.getInteger();</span>
    }
<span class="fc" id="L1044">    logger.warn(&quot;Passive Port range Min: &quot; + min + &quot; Max: &quot; + max);</span>
<span class="fc" id="L1045">    final CircularIntValue rangePort = new CircularIntValue(min, max);</span>
<span class="fc" id="L1046">    setRangePort(rangePort);</span>
<span class="fc" id="L1047">    value = hashConfig.get(XML_SERVER_HTTPS_PORT);</span>
<span class="fc" id="L1048">    int httpsport = 8067;</span>
<span class="pc bpc" id="L1049" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1050">      httpsport = value.getInteger();</span>
    }
<span class="fc" id="L1052">    serverHttpsPort = httpsport;</span>
<span class="fc" id="L1053">    return true;</span>
  }

  /**
   * Set the Crypto Key from the Document
   *
   * @return True if OK
   */
  private boolean setCryptoKey() {
<span class="fc" id="L1062">    final XmlValue value = hashConfig.get(XML_PATH_CRYPTOKEY);</span>
<span class="pc bpc" id="L1063" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1064">      logger.error(&quot;Unable to find CryptoKey in Config file&quot;);</span>
<span class="nc" id="L1065">      return false;</span>
    }
<span class="fc" id="L1067">    final String filename = value.getString();</span>
<span class="fc" id="L1068">    final File key = new File(filename);</span>
<span class="fc" id="L1069">    final Des des = new Des();</span>
    try {
<span class="fc" id="L1071">      des.setSecretKey(key);</span>
<span class="nc" id="L1072">    } catch (final CryptoException e) {</span>
<span class="nc" id="L1073">      logger.error(&quot;Unable to load CryptoKey from Config file&quot;);</span>
<span class="nc" id="L1074">      return false;</span>
<span class="nc" id="L1075">    } catch (final IOException e) {</span>
<span class="nc" id="L1076">      logger.error(&quot;Unable to load CryptoKey from Config file&quot;);</span>
<span class="nc" id="L1077">      return false;</span>
<span class="fc" id="L1078">    }</span>
<span class="fc" id="L1079">    cryptoKey = des;</span>
<span class="fc" id="L1080">    return true;</span>
  }

  /**
   * @return True if the global Exec parameters are correctly loaded
   */
  private boolean loadExec() {
    // Specific Exec command options
<span class="fc" id="L1088">    XmlValue value = hashConfig.get(XML_RETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1089" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1090">      logger.error(&quot;Unable to find Retrieve Command in Config file&quot;);</span>
<span class="nc" id="L1091">      return false;</span>
    }
<span class="fc" id="L1093">    final String retrieve = value.getString();</span>
<span class="fc" id="L1094">    value = hashConfig.get(XML_DELAYRETRIEVE_COMMAND);</span>
<span class="fc" id="L1095">    long retrievedelay = 0;</span>
<span class="pc bpc" id="L1096" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1097">      retrievedelay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L1099">    value = hashConfig.get(XML_STORE_COMMAND);</span>
<span class="pc bpc" id="L1100" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1101">      logger.error(&quot;Unable to find Store Command in Config file&quot;);</span>
<span class="nc" id="L1102">      return false;</span>
    }
<span class="fc" id="L1104">    final String store = value.getString();</span>
<span class="fc" id="L1105">    value = hashConfig.get(XML_DELAYSTORE_COMMAND);</span>
<span class="fc" id="L1106">    long storedelay = 0;</span>
<span class="pc bpc" id="L1107" title="2 of 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1108">      storedelay = (value.getLong() / 10) * 10;</span>
    }
<span class="fc" id="L1110">    AbstractExecutor</span>
<span class="fc" id="L1111">        .initializeExecutor(retrieve, retrievedelay, store, storedelay);</span>
<span class="fc" id="L1112">    return true;</span>
  }

  /**
   * Load database parameter
   *
   * @return True if OK
   */
  private boolean loadDatabase() {
<span class="fc" id="L1121">    XmlValue value = hashConfig.get(XML_DBDRIVER);</span>
<span class="pc bpc" id="L1122" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1123">      logger.error(&quot;Unable to find DBDriver in Config file&quot;);</span>
<span class="nc" id="L1124">      DbConstantFtp.gatewayAdmin = new DbAdmin(); // no database support</span>
    } else {
<span class="fc" id="L1126">      final String dbdriver = value.getString();</span>
<span class="fc" id="L1127">      value = hashConfig.get(XML_DBSERVER);</span>
<span class="pc bpc" id="L1128" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1129">        logger.error(&quot;Unable to find DBServer in Config file&quot;);</span>
<span class="nc" id="L1130">        return false;</span>
      }
<span class="fc" id="L1132">      final String dbserver = value.getString();</span>
<span class="fc" id="L1133">      value = hashConfig.get(XML_DBUSER);</span>
<span class="pc bpc" id="L1134" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1135">        logger.error(&quot;Unable to find DBUser in Config file&quot;);</span>
<span class="nc" id="L1136">        return false;</span>
      }
<span class="fc" id="L1138">      final String dbuser = value.getString();</span>
<span class="fc" id="L1139">      value = hashConfig.get(XML_DBPASSWD);</span>
<span class="pc bpc" id="L1140" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1141">        logger.error(&quot;Unable to find DBPassword in Config file&quot;);</span>
<span class="nc" id="L1142">        return false;</span>
      }
<span class="fc" id="L1144">      final String dbpasswd = value.getString();</span>
<span class="pc bpc" id="L1145" title="4 of 8 branches missed.">      if (dbdriver == null || dbserver == null || dbuser == null ||</span>
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">          dbpasswd == null || dbdriver.length() == 0 ||</span>
<span class="pc bpc" id="L1147" title="2 of 4 branches missed.">          dbserver.length() == 0 || dbuser.length() == 0 ||</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">          dbpasswd.length() == 0) {</span>
<span class="nc" id="L1149">        logger.error(&quot;Unable to find Correct DB data in Config file&quot;);</span>
<span class="nc" id="L1150">        return false;</span>
      }
      try {
<span class="fc" id="L1153">        DbConstantFtp.gatewayAdmin = DbModelFactoryFtp</span>
<span class="fc" id="L1154">            .initialize(dbdriver, dbserver, dbuser, dbpasswd, true);</span>
<span class="fc" id="L1155">        org.waarp.common.database.DbConstant.admin = DbConstantFtp.gatewayAdmin;</span>
<span class="nc" id="L1156">      } catch (final WaarpDatabaseNoConnectionException e2) {</span>
<span class="nc" id="L1157">        logger.error(&quot;Unable to Connect to DB&quot;, e2);</span>
<span class="nc" id="L1158">        return false;</span>
<span class="fc" id="L1159">      }</span>
    }
<span class="fc" id="L1161">    return true;</span>
  }

  protected boolean loadSsl() {
    // StoreKey for Server
<span class="fc" id="L1166">    XmlValue value = hashConfig.get(XML_PATH_KEYPATH);</span>
<span class="pc bpc" id="L1167" title="2 of 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="fc" id="L1168">      logger.info(&quot;Unable to find Key Path&quot;);</span>
<span class="fc" id="L1169">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="fc" id="L1170">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
<span class="fc" id="L1171">      return true;</span>
    } else {
<span class="nc" id="L1173">      final String keypath = value.getString();</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">      if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L1175">        logger.error(&quot;Bad Key Path&quot;);</span>
<span class="nc" id="L1176">        return false;</span>
      }
<span class="nc" id="L1178">      value = hashConfig.get(XML_PATH_KEYSTOREPASS);</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1180">        logger.error(&quot;Unable to find KeyStore Passwd&quot;);</span>
<span class="nc" id="L1181">        return false;</span>
      }
<span class="nc" id="L1183">      final String keystorepass = value.getString();</span>
<span class="nc bnc" id="L1184" title="All 4 branches missed.">      if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L1185">        logger.error(&quot;Bad KeyStore Passwd&quot;);</span>
<span class="nc" id="L1186">        return false;</span>
      }
<span class="nc" id="L1188">      value = hashConfig.get(XML_PATH_KEYPASS);</span>
<span class="nc bnc" id="L1189" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1190">        logger.error(&quot;Unable to find Key Passwd&quot;);</span>
<span class="nc" id="L1191">        return false;</span>
      }
<span class="nc" id="L1193">      final String keypass = value.getString();</span>
<span class="nc bnc" id="L1194" title="All 4 branches missed.">      if (keypass == null || keypass.length() == 0) {</span>
<span class="nc" id="L1195">        logger.error(&quot;Bad Key Passwd&quot;);</span>
<span class="nc" id="L1196">        return false;</span>
      }
      try {
<span class="nc" id="L1199">        FtpsInitializer.waarpSecureKeyStore =</span>
            new WaarpSecureKeyStore(keypath, keystorepass, keypass);
<span class="nc" id="L1201">      } catch (final CryptoException e) {</span>
<span class="nc" id="L1202">        logger.error(&quot;Bad SecureKeyStore construction&quot;);</span>
<span class="nc" id="L1203">        return false;</span>
<span class="nc" id="L1204">      }</span>

    }
    // TrustedKey for OpenR66 server
<span class="nc" id="L1208">    value = hashConfig.get(XML_PATH_TRUSTKEYPATH);</span>
<span class="nc bnc" id="L1209" title="All 4 branches missed.">    if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1210">      logger.info(&quot;Unable to find TRUST Key Path&quot;);</span>
<span class="nc" id="L1211">      FtpsInitializer.waarpSecureKeyStore.initEmptyTrustStore();</span>
    } else {
<span class="nc" id="L1213">      final String keypath = value.getString();</span>
<span class="nc bnc" id="L1214" title="All 4 branches missed.">      if (keypath == null || keypath.length() == 0) {</span>
<span class="nc" id="L1215">        logger.error(&quot;Bad TRUST Key Path&quot;);</span>
<span class="nc" id="L1216">        return false;</span>
      }
<span class="nc" id="L1218">      value = hashConfig.get(XML_PATH_TRUSTKEYSTOREPASS);</span>
<span class="nc bnc" id="L1219" title="All 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1220">        logger.error(&quot;Unable to find TRUST KeyStore Passwd&quot;);</span>
<span class="nc" id="L1221">        return false;</span>
      }
<span class="nc" id="L1223">      final String keystorepass = value.getString();</span>
<span class="nc bnc" id="L1224" title="All 4 branches missed.">      if (keystorepass == null || keystorepass.length() == 0) {</span>
<span class="nc" id="L1225">        logger.error(&quot;Bad TRUST KeyStore Passwd&quot;);</span>
<span class="nc" id="L1226">        return false;</span>
      }
<span class="nc" id="L1228">      boolean useClientAuthent = false;</span>
<span class="nc" id="L1229">      value = hashConfig.get(XML_USECLIENT_AUTHENT);</span>
<span class="nc bnc" id="L1230" title="All 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1231">        useClientAuthent = value.getBoolean();</span>
      }
      try {
<span class="nc" id="L1234">        FtpsInitializer.waarpSecureKeyStore</span>
<span class="nc" id="L1235">            .initTrustStore(keypath, keystorepass, useClientAuthent);</span>
<span class="nc" id="L1236">      } catch (final CryptoException e) {</span>
<span class="nc" id="L1237">        logger.error(&quot;Bad TrustKeyStore construction&quot;);</span>
<span class="nc" id="L1238">        return false;</span>
<span class="nc" id="L1239">      }</span>
    }
<span class="nc" id="L1241">    FtpsInitializer.waarpSslContextFactory =</span>
        new WaarpSslContextFactory(FtpsInitializer.waarpSecureKeyStore);
<span class="nc" id="L1243">    boolean useImplicit = false;</span>
<span class="nc" id="L1244">    value = hashConfig.get(XML_IMPLICIT_FTPS);</span>
<span class="nc bnc" id="L1245" title="All 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1246">      useImplicit = value.getBoolean();</span>
    }
<span class="nc" id="L1248">    boolean useExplicit = false;</span>
<span class="nc" id="L1249">    value = hashConfig.get(XML_EXPLICIT_FTPS);</span>
<span class="nc bnc" id="L1250" title="All 4 branches missed.">    if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1251">      useExplicit = value.getBoolean();</span>
    }
<span class="nc bnc" id="L1253" title="All 4 branches missed.">    if (useImplicit &amp;&amp; useExplicit) {</span>
<span class="nc" id="L1254">      logger.error(&quot;Only one of IMPLICIT or EXPLICIT could be True&quot;);</span>
<span class="nc" id="L1255">      return false;</span>
    }
<span class="nc bnc" id="L1257" title="All 4 branches missed.">    if (!useImplicit &amp;&amp; !useExplicit) {</span>
<span class="nc" id="L1258">      logger.error(</span>
          &quot;Since all SecureStore are specified, one of IMPLICIT or EXPLICIT should be True&quot;);
<span class="nc" id="L1260">      logger.warn(&quot;FTPS support will be ignored...&quot;);</span>
<span class="nc" id="L1261">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="nc" id="L1262">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
<span class="nc" id="L1263">      return true;</span>
    }
<span class="nc" id="L1265">    getFtpInternalConfiguration().setUsingNativeSsl(useImplicit);</span>
<span class="nc" id="L1266">    getFtpInternalConfiguration().setAcceptAuthProt(useExplicit);</span>
<span class="nc" id="L1267">    return true;</span>
  }

  /**
   * Initiate the configuration from the xml file for server
   *
   * @param filename
   *
   * @return True if OK
   */
  public boolean setConfigurationServerFromXml(String filename) {
    Document document;
    // Open config file
    try {
<span class="fc" id="L1281">      document = XmlUtil.getNewSaxReader().read(filename);</span>
<span class="nc" id="L1282">    } catch (final DocumentException e) {</span>
<span class="nc" id="L1283">      logger.error(&quot;Unable to read the XML Config file: &quot; + filename, e);</span>
<span class="nc" id="L1284">      return false;</span>
<span class="fc" id="L1285">    }</span>
<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">    if (document == null) {</span>
<span class="nc" id="L1287">      logger.error(&quot;Unable to read the XML Config file: &quot; + filename);</span>
<span class="nc" id="L1288">      return false;</span>
    }
<span class="fc" id="L1290">    configuration = XmlUtil.read(document, configServer);</span>
<span class="fc" id="L1291">    hashConfig = new XmlHash(configuration);</span>
    // Now read the configuration
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">    if (!loadIdentity()) {</span>
<span class="nc" id="L1294">      logger.error(&quot;Cannot load Identity&quot;);</span>
<span class="nc" id="L1295">      return false;</span>
    }
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">    if (!loadDatabase()) {</span>
<span class="nc" id="L1298">      logger.error(&quot;Cannot load Database configuration&quot;);</span>
<span class="nc" id="L1299">      return false;</span>
    }
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">    if (!loadServerParam()) {</span>
<span class="nc" id="L1302">      logger.error(&quot;Cannot load Server Parameters&quot;);</span>
<span class="nc" id="L1303">      return false;</span>
    }
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">    if (!loadDirectory()) {</span>
<span class="nc" id="L1306">      logger.error(&quot;Cannot load Directory configuration&quot;);</span>
<span class="nc" id="L1307">      return false;</span>
    }
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">    if (!loadLimit(false)) {</span>
<span class="nc" id="L1310">      logger.error(&quot;Cannot load Limit configuration&quot;);</span>
<span class="nc" id="L1311">      return false;</span>
    }
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">    if (!loadNetworkServer()) {</span>
<span class="nc" id="L1314">      logger.error(&quot;Cannot load Network configuration&quot;);</span>
<span class="nc" id="L1315">      return false;</span>
    }
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">    if (!loadExec()) {</span>
<span class="nc" id="L1318">      logger.error(&quot;Cannot load Exec configuration&quot;);</span>
<span class="nc" id="L1319">      return false;</span>
    }
    // if no database, must load authentication from file
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">    if (!loadAuthentication()) {</span>
<span class="nc" id="L1323">      logger.error(&quot;Cannot load Authentication configuration&quot;);</span>
<span class="nc" id="L1324">      return false;</span>
    }
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">    if (!loadSsl()) {</span>
      // ignore and continue =&gt; No SSL
<span class="nc" id="L1328">      getFtpInternalConfiguration().setUsingNativeSsl(false);</span>
<span class="nc" id="L1329">      getFtpInternalConfiguration().setAcceptAuthProt(false);</span>
    }
<span class="fc" id="L1331">    hashConfig.clear();</span>
<span class="fc" id="L1332">    hashConfig = null;</span>
<span class="fc" id="L1333">    configuration = null;</span>
<span class="fc" id="L1334">    logger.debug(&quot;File based configuration loaded&quot;);</span>
<span class="fc" id="L1335">    return true;</span>
  }

  /**
   * Configure HTTPS
   */
  public void configureHttps() {
<span class="fc" id="L1342">    logger.debug(&quot;Start HTTPS&quot;);</span>
    // Now start the HTTPS support
    // Configure the server.
<span class="fc" id="L1345">    httpsBootstrap = new ServerBootstrap();</span>
<span class="fc" id="L1346">    httpExecutor = new NioEventLoopGroup(getServerThread() * 10,</span>
                                         new WaarpThreadFactory(
                                             &quot;HttpExecutor&quot;));
<span class="fc" id="L1349">    workerGroup = new NioEventLoopGroup(getServerThread() * 10,</span>
                                        new WaarpThreadFactory(&quot;HTTP_Worker&quot;));
<span class="fc" id="L1351">    WaarpNettyUtil</span>
<span class="fc" id="L1352">        .setServerBootstrap(httpsBootstrap, workerGroup, (int) getTimeoutCon());</span>

    // Configure the pipeline factory.
<span class="fc" id="L1355">    httpsBootstrap.childHandler(new HttpSslInitializer(isUseHttpCompression()));</span>
<span class="fc" id="L1356">    httpChannelGroup =</span>
<span class="fc" id="L1357">        new DefaultChannelGroup(&quot;HttpOpenR66&quot;, httpExecutor.next());</span>

    // Bind and start to accept incoming connections.
<span class="fc" id="L1360">    logger.warn(&quot;Start Https Support on port: &quot; + serverHttpsPort + &quot; with &quot; +</span>
<span class="pc bpc" id="L1361" title="1 of 2 branches missed.">                (isUseHttpCompression()? &quot;&quot; : &quot;no&quot;) + &quot; compression support&quot;);</span>
<span class="fc" id="L1362">    final ChannelFuture future =</span>
<span class="fc" id="L1363">        httpsBootstrap.bind(new InetSocketAddress(serverHttpsPort));</span>
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">    if (WaarpNettyUtil.awaitIsSuccessOfInterrupted(future)) {</span>
<span class="fc" id="L1365">      httpChannelGroup.add(future.channel());</span>
    }
<span class="fc" id="L1367">  }</span>

  /**
   * Configure ConstraintLimitHandler
   */
  public void configureConstraint() {
<span class="fc" id="L1373">    logger.debug(&quot;Configure constraints&quot;);</span>
<span class="fc" id="L1374">    getConstraintLimitHandler().setHandler(</span>
<span class="fc" id="L1375">        getFtpInternalConfiguration().getGlobalTrafficShapingHandler());</span>
<span class="fc" id="L1376">  }</span>

  /**
   * Configure LocalExec
   */
  public void configureLExec() {
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">    if (isUseLocalExec()) {</span>
<span class="nc" id="L1383">      logger.debug(&quot;Start LExec&quot;);</span>
<span class="nc" id="L1384">      LocalExecClient.initialize(getClientThread(), getMaxGlobalMemory());</span>
    }
<span class="fc" id="L1386">  }</span>

  /**
   * Configure the SNMP support if needed
   *
   * @throws FtpNoConnectionException
   */
  public void configureSnmp() throws FtpNoConnectionException {
<span class="fc" id="L1394">    logger.debug(&quot;Start SNMP&quot;);</span>
<span class="fc" id="L1395">    setMonitoring(new FtpMonitoring(null));</span>
<span class="pc bpc" id="L1396" title="1 of 2 branches missed.">    if (getSnmpConfig() != null) {</span>
<span class="fc" id="L1397">      final int snmpPortShow = getServerPort();</span>
<span class="fc" id="L1398">      setFtpMib(new FtpPrivateMib(snmpPortShow));</span>
<span class="fc" id="L1399">      WaarpMOFactory.setFactory(new FtpVariableFactory());</span>
<span class="fc" id="L1400">      setAgentSnmp(</span>
<span class="fc" id="L1401">          new WaarpSnmpAgent(new File(getSnmpConfig()), getMonitoring(),</span>
<span class="fc" id="L1402">                             getFtpMib()));</span>
      try {
<span class="fc" id="L1404">        getAgentSnmp().start();</span>
<span class="fc" id="L1405">        logger.debug(&quot;SNMP configured&quot;);</span>
<span class="nc" id="L1406">      } catch (final IOException e) {</span>
<span class="nc" id="L1407">        getMonitoring().releaseResources();</span>
<span class="nc" id="L1408">        setMonitoring(null);</span>
<span class="nc" id="L1409">        setFtpMib(null);</span>
<span class="nc" id="L1410">        setAgentSnmp(null);</span>
<span class="nc" id="L1411">        throw new FtpNoConnectionException(&quot;AgentSnmp Error while starting&quot;, e);</span>
<span class="fc" id="L1412">      }</span>
    }
<span class="fc" id="L1414">  }</span>

  /**
   * @param serverkey the SERVERADMINKEY to set
   */
  public void setSERVERKEY(byte[] serverkey) {
<span class="fc" id="L1420">    serverAdminKey = serverkey;</span>
<span class="fc" id="L1421">  }</span>

  /**
   * Check the password for Shutdown
   *
   * @param password
   *
   * @return True if the password is OK
   */
  @Override
  public boolean checkPassword(String password) {
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">    if (password == null) {</span>
<span class="nc" id="L1433">      return false;</span>
    }
<span class="fc" id="L1435">    return Arrays</span>
<span class="fc" id="L1436">        .equals(serverAdminKey, password.getBytes(WaarpStringUtils.UTF8));</span>
  }

  /**
   * Initialize Authentication from current authenticationFile
   *
   * @param filename the filename from which authentication will be
   *     loaded
   * @param purge if True, the current authentications are totally
   *     replaced
   *     by the new ones
   *
   * @return True if OK
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public boolean initializeAuthent(String filename, boolean purge) {
<span class="fc" id="L1452">    logger.debug(&quot;Load authent&quot;);</span>
    Document document;
    try {
<span class="fc" id="L1455">      document = XmlUtil.getNewSaxReader().read(filename);</span>
<span class="nc" id="L1456">    } catch (final DocumentException e) {</span>
<span class="nc" id="L1457">      logger</span>
<span class="nc" id="L1458">          .error(&quot;Unable to read the XML Authentication file: &quot; + filename, e);</span>
<span class="nc" id="L1459">      return false;</span>
<span class="fc" id="L1460">    }</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">    if (document == null) {</span>
<span class="nc" id="L1462">      logger.error(&quot;Unable to read the XML Authentication file: &quot; + filename);</span>
<span class="nc" id="L1463">      return false;</span>
    }
<span class="fc" id="L1465">    XmlValue[] configurationXml = XmlUtil.read(document, authentElements);</span>
<span class="fc" id="L1466">    XmlHash hashConfigXml = new XmlHash(configurationXml);</span>

<span class="fc" id="L1468">    XmlValue value = hashConfigXml.get(XML_AUTHENTIFICATION_ENTRY);</span>
<span class="fc" id="L1469">    final List&lt;XmlValue[]&gt; list = (List&lt;XmlValue[]&gt;) value.getList();</span>
<span class="fc" id="L1470">    final ConcurrentHashMap&lt;String, SimpleAuth&gt; newAuthents =</span>
        new ConcurrentHashMap&lt;String, SimpleAuth&gt;();
<span class="fc bfc" id="L1472" title="All 2 branches covered.">    for (final XmlValue[] xmlValues : list) {</span>
<span class="fc" id="L1473">      hashConfigXml = new XmlHash(xmlValues);</span>
<span class="fc" id="L1474">      value = hashConfigXml.get(XML_AUTHENTICATION_USER);</span>
<span class="pc bpc" id="L1475" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1476">        logger.error(&quot;Unable to find a User in Config file&quot;);</span>
<span class="nc" id="L1477">        continue;</span>
      }
<span class="fc" id="L1479">      final String user = value.getString();</span>
<span class="fc" id="L1480">      value = hashConfigXml.get(XML_AUTHENTICATION_ACCOUNT);</span>
<span class="pc bpc" id="L1481" title="2 of 4 branches missed.">      if (value == null || value.isEmpty()) {</span>
<span class="nc" id="L1482">        logger.error(&quot;Unable to find a Account in Config file: &quot; + user);</span>
<span class="nc" id="L1483">        continue;</span>
      }
      String[] account;
<span class="fc" id="L1486">      final List&lt;String&gt; listaccount = (List&lt;String&gt;) value.getList();</span>
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">      if (!listaccount.isEmpty()) {</span>
<span class="fc" id="L1488">        account = new String[listaccount.size()];</span>
<span class="fc" id="L1489">        int i = 0;</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        for (final String s : listaccount) {</span>
<span class="fc" id="L1491">          account[i] = s;</span>
          // logger.debug(&quot;User: {} Acct: {}&quot;, user, account[i])
<span class="fc" id="L1493">          final File directory =</span>
<span class="fc" id="L1494">              new File(getBaseDirectory() + '/' + user + '/' + account[i]);</span>
<span class="fc" id="L1495">          directory.mkdirs();</span>
<span class="fc" id="L1496">          i++;</span>
<span class="fc" id="L1497">        }</span>
<span class="fc" id="L1498">      } else {</span>
<span class="nc" id="L1499">        logger.error(&quot;Unable to find a Account in Config file: &quot; + user);</span>
<span class="nc" id="L1500">        continue;</span>
      }
<span class="fc" id="L1502">      value = hashConfigXml.get(XML_AUTHENTICATION_ADMIN);</span>
<span class="fc" id="L1503">      boolean isAdmin = false;</span>
<span class="pc bpc" id="L1504" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1505">        isAdmin = value.getBoolean();</span>
      }
<span class="fc" id="L1507">      String retrcmd = null;</span>
<span class="fc" id="L1508">      long retrdelay = 0;</span>
<span class="fc" id="L1509">      String storcmd = null;</span>
<span class="fc" id="L1510">      long stordelay = 0;</span>
<span class="fc" id="L1511">      value = hashConfigXml.get(XML_RETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1512" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1513">        retrcmd = value.getString();</span>
      }
<span class="fc" id="L1515">      value = hashConfigXml.get(XML_DELAYRETRIEVE_COMMAND);</span>
<span class="pc bpc" id="L1516" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1517">        retrdelay = (value.getLong() / 10) * 10;</span>
      }
<span class="fc" id="L1519">      value = hashConfigXml.get(XML_STORE_COMMAND);</span>
<span class="pc bpc" id="L1520" title="1 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L1521">        storcmd = value.getString();</span>
      }
<span class="fc" id="L1523">      value = hashConfigXml.get(XML_DELAYSTORE_COMMAND);</span>
<span class="pc bpc" id="L1524" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1525">        stordelay = (value.getLong() / 10) * 10;</span>
      }
      String passwd;
<span class="fc" id="L1528">      value = hashConfigXml.get(XML_AUTHENTICATION_PASSWDFILE);</span>
<span class="pc bpc" id="L1529" title="2 of 4 branches missed.">      if (value != null &amp;&amp; !value.isEmpty()) {</span>
        // load key from file
<span class="fc" id="L1531">        final File key = new File(value.getString());</span>
<span class="pc bpc" id="L1532" title="1 of 2 branches missed.">        if (!key.canRead()) {</span>
<span class="nc" id="L1533">          logger</span>
<span class="nc" id="L1534">              .error(&quot;Cannot read key for user &quot; + user + ':' + key.getName());</span>
<span class="nc" id="L1535">          continue;</span>
        }
        try {
<span class="fc" id="L1538">          final byte[] byteKeys = getCryptoKey().decryptHexFile(key);</span>
<span class="fc" id="L1539">          passwd = new String(byteKeys, WaarpStringUtils.UTF8);</span>
<span class="nc" id="L1540">        } catch (final Exception e2) {</span>
<span class="nc" id="L1541">          logger.error(&quot;Cannot read key for user &quot; + user, e2);</span>
<span class="nc" id="L1542">          continue;</span>
<span class="fc" id="L1543">        }</span>
<span class="fc" id="L1544">      } else {</span>
<span class="nc" id="L1545">        value = hashConfigXml.get(XML_AUTHENTICATION_PASSWD);</span>
<span class="nc bnc" id="L1546" title="All 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="nc" id="L1547">          final String encrypted = value.getString();</span>
          byte[] byteKeys;
          try {
<span class="nc" id="L1550">            byteKeys = getCryptoKey().decryptHexInBytes(encrypted);</span>
<span class="nc" id="L1551">            passwd = new String(byteKeys, WaarpStringUtils.UTF8);</span>
<span class="nc" id="L1552">          } catch (final Exception e) {</span>
<span class="nc" id="L1553">            logger.error(&quot;Unable to Decrypt Key for user &quot; + user, e);</span>
<span class="nc" id="L1554">            continue;</span>
<span class="nc" id="L1555">          }</span>
<span class="nc" id="L1556">        } else {</span>
<span class="nc" id="L1557">          logger.error(&quot;Unable to find Password in Config file&quot;);</span>
          // DO NOT Allow empty key
<span class="nc" id="L1559">          continue;</span>
        }
      }
<span class="fc" id="L1562">      final SimpleAuth auth =</span>
          new SimpleAuth(user, passwd, account, storcmd, stordelay, retrcmd,
                         retrdelay);
<span class="fc" id="L1565">      auth.setAdmin(isAdmin);</span>
<span class="fc" id="L1566">      newAuthents.put(user, auth);</span>
<span class="fc" id="L1567">      hashConfigXml.clear();</span>
<span class="fc" id="L1568">    }</span>
<span class="fc" id="L1569">    hashConfigXml.clear();</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">    if (purge) {</span>
<span class="nc" id="L1571">      authentications.clear();</span>
    }
<span class="fc" id="L1573">    authentications.putAll(newAuthents);</span>
<span class="fc" id="L1574">    newAuthents.clear();</span>
<span class="fc" id="L1575">    return true;</span>
  }

  /**
   * Export the Authentication to the original files
   *
   * @param filename the filename where the authentication will be
   *     exported
   *
   * @return True if successful
   */
  public boolean saveAuthenticationFile(String filename) {
<span class="nc" id="L1587">    final Document document = XmlUtil.createEmptyDocument();</span>
<span class="nc" id="L1588">    final XmlValue[] roots = new XmlValue[1];</span>
<span class="nc" id="L1589">    final XmlValue root = new XmlValue(authentElements[0]);</span>
<span class="nc" id="L1590">    roots[0] = root;</span>
<span class="nc" id="L1591">    final Enumeration&lt;SimpleAuth&gt; auths = authentications.elements();</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">    while (auths.hasMoreElements()) {</span>
<span class="nc" id="L1593">      final SimpleAuth auth = auths.nextElement();</span>
<span class="nc" id="L1594">      final XmlValue[] values = new XmlValue[configAuthenticationDecls.length];</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      for (int i = 0; i &lt; configAuthenticationDecls.length; i++) {</span>
<span class="nc" id="L1596">        values[i] = new XmlValue(configAuthenticationDecls[i]);</span>
      }
      try {
<span class="nc" id="L1599">        values[0].setFromString(auth.getUser());</span>
        // PasswdFile: none values[1].setFromString()
<span class="nc" id="L1601">        values[2].setFromString(auth.getPassword());</span>
        // Accounts
<span class="nc" id="L1603">        final String[] accts = auth.getAccounts();</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        for (final String string : accts) {</span>
<span class="nc" id="L1605">          values[3].addFromString(string);</span>
        }
<span class="nc" id="L1607">        values[4].setValue(auth.isAdmin());</span>
<span class="nc" id="L1608">        values[5].setFromString(auth.getRetrCmd());</span>
<span class="nc" id="L1609">        values[6].setValue(auth.getRetrDelay());</span>
<span class="nc" id="L1610">        values[7].setFromString(auth.getStorCmd());</span>
<span class="nc" id="L1611">        values[8].setValue(auth.getStorDelay());</span>
<span class="nc" id="L1612">      } catch (final InvalidArgumentException e1) {</span>
<span class="nc" id="L1613">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e1);</span>
<span class="nc" id="L1614">        return false;</span>
<span class="nc" id="L1615">      } catch (final InvalidObjectException e) {</span>
<span class="nc" id="L1616">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e);</span>
<span class="nc" id="L1617">        return false;</span>
<span class="nc" id="L1618">      }</span>
      try {
<span class="nc" id="L1620">        root.addValue(values);</span>
<span class="nc" id="L1621">      } catch (final InvalidObjectException e) {</span>
<span class="nc" id="L1622">        logger.error(ERROR_DURING_WRITE_AUTHENTICATION_FILE, e);</span>
<span class="nc" id="L1623">        return false;</span>
<span class="nc" id="L1624">      }</span>
<span class="nc" id="L1625">    }</span>
<span class="nc" id="L1626">    XmlUtil.write(document, roots);</span>
    try {
<span class="nc" id="L1628">      XmlUtil.saveDocument(filename, document);</span>
<span class="nc" id="L1629">    } catch (final IOException e1) {</span>
<span class="nc" id="L1630">      logger.error(&quot;Cannot write to file: &quot; + filename + &quot; since {}&quot;,</span>
<span class="nc" id="L1631">                   e1.getMessage());</span>
<span class="nc" id="L1632">      return false;</span>
<span class="nc" id="L1633">    }</span>
<span class="nc" id="L1634">    return true;</span>
  }

  /**
   * @param user
   *
   * @return the SimpleAuth if any for this user
   */
  public SimpleAuth getSimpleAuth(String user) {
<span class="fc" id="L1643">    return authentications.get(user);</span>
  }

  /**
   * @param format Format in HTML to use as ouput format
   *
   * @return the Html String containing the table of all Authentication
   *     entries
   */
  public String getHtmlAuth(String format) {
    String result;
<span class="fc" id="L1654">    final StringBuilder builder = new StringBuilder();</span>
    /*
     * XXXUSERXXX XXXPWDXXX XXXACTSXXX XXXADMXXX XXXSTCXXX XXXSTDXXX XXXRTCXXX XXXRTDXXX
     */
<span class="fc" id="L1658">    final Enumeration&lt;SimpleAuth&gt; simpleAuths = authentications.elements();</span>
    SimpleAuth auth;
<span class="fc bfc" id="L1660" title="All 2 branches covered.">    while (simpleAuths.hasMoreElements()) {</span>
<span class="fc" id="L1661">      auth = simpleAuths.nextElement();</span>
<span class="fc" id="L1662">      String newElt = format.replace(&quot;XXXUSERXXX&quot;, auth.getUser());</span>
<span class="fc" id="L1663">      newElt = newElt.replace(&quot;XXXPWDXXX&quot;, auth.getPassword());</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">      if (auth.getStorCmd() != null) {</span>
<span class="fc" id="L1665">        newElt = newElt.replace(&quot;XXXSTCXXX&quot;, auth.getStorCmd());</span>
      } else {
<span class="fc" id="L1667">        newElt = newElt.replace(&quot;XXXSTCXXX&quot;, &quot;&quot;);</span>
      }
<span class="fc bfc" id="L1669" title="All 2 branches covered.">      if (auth.getRetrCmd() != null) {</span>
<span class="fc" id="L1670">        newElt = newElt.replace(&quot;XXXRTCXXX&quot;, auth.getRetrCmd());</span>
      } else {
<span class="fc" id="L1672">        newElt = newElt.replace(&quot;XXXRTCXXX&quot;, &quot;&quot;);</span>
      }
<span class="fc" id="L1674">      newElt = newElt.replace(&quot;XXXSTDXXX&quot;, Long.toString(auth.getStorDelay()));</span>
<span class="fc" id="L1675">      newElt = newElt.replace(&quot;XXXRTDXXX&quot;, Long.toString(auth.getRetrDelay()));</span>
<span class="fc" id="L1676">      newElt = newElt.replace(&quot;XXXADMXXX&quot;, Boolean.toString(auth.isAdmin()));</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">      if (auth.getAccounts() != null) {</span>
<span class="fc" id="L1678">        final StringBuilder accts = new StringBuilder();</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">        for (int i = 0; i &lt; auth.getAccounts().length - 1; i++) {</span>
<span class="fc" id="L1680">          accts.append(auth.getAccounts()[i]).append(&quot;, &quot;);</span>
        }
<span class="fc" id="L1682">        accts.append(auth.getAccounts()[auth.getAccounts().length - 1]);</span>
<span class="fc" id="L1683">        newElt = newElt.replace(&quot;XXXACTSXXX&quot;, accts.toString());</span>
<span class="fc" id="L1684">      } else {</span>
<span class="nc" id="L1685">        newElt = newElt.replace(&quot;XXXACTSXXX&quot;, &quot;No Account&quot;);</span>
      }
<span class="fc" id="L1687">      builder.append(newElt);</span>
<span class="fc" id="L1688">    }</span>
<span class="fc" id="L1689">    result = builder.toString();</span>
<span class="fc" id="L1690">    return result;</span>
  }

  /**
   * Only available with Database support for Waarp
   *
   * @param format Format in HTML to use as ouput format
   * @param limit number of TransferLog to populate
   *
   * @return the Html String containing the table of all Transfer entries
   */
  public String getHtmlTransfer(String format, int limit) {
    String result;
<span class="fc" id="L1703">    final StringBuilder builder = new StringBuilder();</span>
    /*
     * XXXIDXXX XXXUSERXXX XXXACCTXXX XXXFILEXXX XXXMODEXXX XXXSTATUSXXX XXXINFOXXX XXXUPINFXXX XXXSTARTXXX
     * XXXSTOPXXX
     */
<span class="fc" id="L1708">    DbPreparedStatement preparedStatement = null;</span>
    try {
      try {
<span class="fc" id="L1711">        preparedStatement = DbTransferLog</span>
<span class="fc" id="L1712">            .getStatusPrepareStament(DbConstantFtp.gatewayAdmin.getSession(),</span>
                                     null, limit);
<span class="fc" id="L1714">        preparedStatement.executeQuery();</span>
<span class="nc" id="L1715">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1716">        return &quot;&quot;;</span>
<span class="nc" id="L1717">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L1718">        return &quot;&quot;;</span>
<span class="fc" id="L1719">      }</span>
      try {
<span class="fc bfc" id="L1721" title="All 2 branches covered.">        while (preparedStatement.getNext()) {</span>
<span class="fc" id="L1722">          final DbTransferLog log =</span>
<span class="fc" id="L1723">              DbTransferLog.getFromStatement(preparedStatement);</span>
<span class="fc" id="L1724">          String newElt =</span>
<span class="fc" id="L1725">              format.replace(&quot;XXXIDXXX&quot;, Long.toString(log.getSpecialId()));</span>
<span class="fc" id="L1726">          newElt = newElt.replace(&quot;XXXUSERXXX&quot;, log.getUser());</span>
<span class="fc" id="L1727">          newElt = newElt.replace(&quot;XXXACCTXXX&quot;, log.getAccount());</span>
<span class="fc" id="L1728">          newElt = newElt.replace(&quot;XXXFILEXXX&quot;, log.getFilename());</span>
<span class="fc" id="L1729">          newElt = newElt.replace(&quot;XXXMODEXXX&quot;, log.getMode());</span>
<span class="fc" id="L1730">          newElt = newElt.replace(&quot;XXXSTATUSXXX&quot;, log.getErrorInfo().getMesg());</span>
<span class="fc" id="L1731">          newElt = newElt.replace(&quot;XXXINFOXXX&quot;, log.getInfotransf());</span>
<span class="fc" id="L1732">          newElt = newElt.replace(&quot;XXXUPINFXXX&quot;, log.getUpdatedInfo().name());</span>
<span class="fc" id="L1733">          newElt = newElt.replace(&quot;XXXSTARTXXX&quot;, log.getStart().toString());</span>
<span class="fc" id="L1734">          newElt = newElt.replace(&quot;XXXSTOPXXX&quot;, log.getStop().toString());</span>
<span class="fc" id="L1735">          builder.append(newElt);</span>
<span class="fc" id="L1736">        }</span>
<span class="nc" id="L1737">      } catch (final WaarpDatabaseNoConnectionException e) {</span>
<span class="nc" id="L1738">        return &quot;&quot;;</span>
<span class="nc" id="L1739">      } catch (final WaarpDatabaseSqlException e) {</span>
<span class="nc" id="L1740">        return &quot;&quot;;</span>
<span class="fc" id="L1741">      }</span>
<span class="fc" id="L1742">      result = builder.toString();</span>
<span class="fc" id="L1743">      return result;</span>
    } finally {
<span class="pc bpc" id="L1745" title="1 of 2 branches missed.">      if (preparedStatement != null) {</span>
<span class="fc" id="L1746">        preparedStatement.realClose();</span>
      }
    }
  }

  /**
   * @see FtpConfiguration#getNextRangePort()
   */
  @Override
  public int getNextRangePort() {
    try {
<span class="fc" id="L1757">      return ((CircularIntValue) getProperty(RANGE_PORT)).getNext();</span>
<span class="nc" id="L1758">    } catch (final FtpUnknownFieldException e) {</span>
<span class="nc" id="L1759">      return -1;</span>
    }
  }

  /**
   * @param rangePort the range of available ports for Passive
   *     connections
   */
  private void setRangePort(CircularIntValue rangePort) {
<span class="fc" id="L1768">    setProperty(RANGE_PORT, rangePort);</span>
<span class="fc" id="L1769">  }</span>

  /**
   * @return the httpPipelineExecutor
   */
  public EventExecutorGroup getHttpPipelineExecutor() {
<span class="fc" id="L1775">    return httpExecutor;</span>
  }

  /**
   * @return the httpChannelGroup
   */
  public ChannelGroup getHttpChannelGroup() {
<span class="fc" id="L1782">    return httpChannelGroup;</span>
  }

  /**
   * Finalize resources attached to handlers
   */
  private static class GgChannelGroupFutureListener
      implements ChannelGroupFutureListener {
    final EventExecutorGroup executorWorker;
    final String name;

    private GgChannelGroupFutureListener(String name,
<span class="fc" id="L1794">                                         EventExecutorGroup executorWorker) {</span>
<span class="fc" id="L1795">      this.name = name;</span>
<span class="fc" id="L1796">      this.executorWorker = executorWorker;</span>
<span class="fc" id="L1797">    }</span>

    @Override
    public void operationComplete(ChannelGroupFuture future) throws Exception {
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">      if (executorWorker != null) {</span>
<span class="fc" id="L1802">        executorWorker.shutdownGracefully();</span>
      }
<span class="fc" id="L1804">      logger.info(&quot;Done with shutdown &quot; + name);</span>
<span class="fc" id="L1805">    }</span>
  }

  @Override
  public void releaseResources() {
<span class="fc" id="L1810">    logger.debug(&quot;Release resources&quot;);</span>
<span class="fc" id="L1811">    super.releaseResources();</span>
<span class="pc bpc" id="L1812" title="1 of 2 branches missed.">    if (httpChannelGroup != null) {</span>
<span class="fc" id="L1813">      final int result = httpChannelGroup.size();</span>
<span class="fc" id="L1814">      logger.debug(&quot;HttpChannelGroup: &quot; + result);</span>
<span class="fc" id="L1815">      httpChannelGroup.close().addListener(</span>
          new GgChannelGroupFutureListener(&quot;HttpChannelGroup&quot;, workerGroup));
    }
<span class="pc bpc" id="L1818" title="1 of 2 branches missed.">    if (httpExecutor != null) {</span>
<span class="fc" id="L1819">      httpExecutor.shutdownGracefully();</span>
    }
<span class="pc bpc" id="L1821" title="1 of 2 branches missed.">    if (isUseLocalExec()) {</span>
<span class="nc" id="L1822">      LocalExecClient.releaseResources();</span>
    }
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">    if (getConstraintLimitHandler() != null) {</span>
<span class="fc" id="L1825">      getConstraintLimitHandler().release();</span>
    }
<span class="pc bpc" id="L1827" title="1 of 2 branches missed.">    if (getAgentSnmp() != null) {</span>
<span class="fc" id="L1828">      getAgentSnmp().stop();</span>
    }
<span class="fc" id="L1830">    DbAdmin.closeAllConnection();</span>
<span class="fc" id="L1831">  }</span>

  @Override
  public void inShutdownProcess() {
<span class="pc bpc" id="L1835" title="1 of 2 branches missed.">    if (getFtpMib() != null) {</span>
<span class="fc" id="L1836">      getFtpMib().notifyStartStop(&quot;Shutdown in progress for &quot; + getHostId(),</span>
<span class="fc" id="L1837">                                  &quot;Gives extra seconds: &quot; + getTimeoutCon());</span>
    }
<span class="fc" id="L1839">  }</span>

  /**
   * @return the authenticationFile
   */
  public String getAuthenticationFile() {
<span class="fc" id="L1845">    return authenticationFile;</span>
  }

  /**
   * @param authenticationFile the authenticationFile to set
   */
  public void setAuthenticationFile(String authenticationFile) {
<span class="fc" id="L1852">    this.authenticationFile = authenticationFile;</span>
<span class="fc" id="L1853">  }</span>

  /**
   * @return the httpBasePath
   */
  public String getHttpBasePath() {
<span class="fc" id="L1859">    return httpBasePath;</span>
  }

  /**
   * @param httpBasePath the httpBasePath to set
   */
  public void setHttpBasePath(String httpBasePath) {
<span class="fc" id="L1866">    this.httpBasePath = httpBasePath;</span>
<span class="fc" id="L1867">  }</span>

  /**
   * @return the useHttpCompression
   */
  public boolean isUseHttpCompression() {
<span class="fc" id="L1873">    return useHttpCompression;</span>
  }

  /**
   * @param useHttpCompression the useHttpCompression to set
   */
  public void setUseHttpCompression(boolean useHttpCompression) {
<span class="fc" id="L1880">    this.useHttpCompression = useHttpCompression;</span>
<span class="fc" id="L1881">  }</span>

  /**
   * @return the useLocalExec
   */
  public boolean isUseLocalExec() {
<span class="fc" id="L1887">    return useLocalExec;</span>
  }

  /**
   * @param useLocalExec the useLocalExec to set
   */
  public void setUseLocalExec(boolean useLocalExec) {
<span class="fc" id="L1894">    this.useLocalExec = useLocalExec;</span>
<span class="fc" id="L1895">  }</span>

  /**
   * @return the cryptoKey
   */
  public Des getCryptoKey() {
<span class="fc" id="L1901">    return cryptoKey;</span>
  }

  /**
   * @param cryptoKey the cryptoKey to set
   */
  public void setCryptoKey(Des cryptoKey) {
<span class="nc" id="L1908">    this.cryptoKey = cryptoKey;</span>
<span class="nc" id="L1909">  }</span>

  /**
   * @return the hostId
   */
  public String getHostId() {
<span class="fc" id="L1915">    return hostId;</span>
  }

  /**
   * @param hostId the hostId to set
   */
  public void setHostId(String hostId) {
<span class="fc" id="L1922">    this.hostId = hostId;</span>
<span class="fc" id="L1923">  }</span>

  /**
   * @return the adminName
   */
  public String getAdminName() {
<span class="fc" id="L1929">    return adminName;</span>
  }

  /**
   * @param adminName the adminName to set
   */
  public void setAdminName(String adminName) {
<span class="fc" id="L1936">    this.adminName = adminName;</span>
<span class="fc" id="L1937">  }</span>

  /**
   * @return the constraintLimitHandler
   */
  public FtpConstraintLimitHandler getConstraintLimitHandler() {
<span class="fc" id="L1943">    return constraintLimitHandler;</span>
  }

  /**
   * @param constraintLimitHandler the constraintLimitHandler to set
   */
  public void setConstraintLimitHandler(
      FtpConstraintLimitHandler constraintLimitHandler) {
<span class="fc" id="L1951">    this.constraintLimitHandler = constraintLimitHandler;</span>
<span class="fc" id="L1952">  }</span>

  /**
   * @return the snmpConfig
   */
  public String getSnmpConfig() {
<span class="fc" id="L1958">    return snmpConfig;</span>
  }

  /**
   * @param snmpConfig the snmpConfig to set
   */
  public void setSnmpConfig(String snmpConfig) {
<span class="fc" id="L1965">    this.snmpConfig = snmpConfig;</span>
<span class="fc" id="L1966">  }</span>

  /**
   * @return the agentSnmp
   */
  public WaarpSnmpAgent getAgentSnmp() {
<span class="fc" id="L1972">    return agentSnmp;</span>
  }

  /**
   * @param agentSnmp the agentSnmp to set
   */
  public void setAgentSnmp(WaarpSnmpAgent agentSnmp) {
<span class="fc" id="L1979">    this.agentSnmp = agentSnmp;</span>
<span class="fc" id="L1980">  }</span>

  /**
   * @return the ftpMib
   */
  public FtpPrivateMib getFtpMib() {
<span class="fc" id="L1986">    return ftpMib;</span>
  }

  /**
   * @param ftpMib the ftpMib to set
   */
  public void setFtpMib(FtpPrivateMib ftpMib) {
<span class="fc" id="L1993">    this.ftpMib = ftpMib;</span>
<span class="fc" id="L1994">  }</span>

  /**
   * @return the monitoring
   */
  public FtpMonitoring getMonitoring() {
<span class="fc" id="L2000">    return monitoring;</span>
  }

  /**
   * @param monitoring the monitoring to set
   */
  public void setMonitoring(FtpMonitoring monitoring) {
<span class="fc" id="L2007">    this.monitoring = monitoring;</span>
<span class="fc" id="L2008">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>