<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileMonitor.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.filemonitor</a> &gt; <span class="el_source">FileMonitor.java</span></div><h1>FileMonitor.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.filemonitor;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import io.netty.util.HashedWheelTimer;
import io.netty.util.Timeout;
import io.netty.util.Timer;
import io.netty.util.TimerTask;
import org.waarp.common.database.DbConstant;
import org.waarp.common.digest.FilesystemBasedDigest;
import org.waarp.common.digest.FilesystemBasedDigest.DigestAlgo;
import org.waarp.common.file.AbstractDir;
import org.waarp.common.future.WaarpFuture;
import org.waarp.common.json.JsonHandler;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpThreadFactory;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * This package would like to propose a JSE 6 compatible way to scan a directory
 * for new, deleted and changed
 * files, in order to allow some functions like pooling a directory before
 * actions.
 */
public class FileMonitor {
  /**
   * Internal Logger
   */
  protected static volatile WaarpLogger logger;
<span class="fc" id="L76">  protected static final DigestAlgo defaultDigestAlgo = DigestAlgo.MD5;</span>
  protected static final long MINIMAL_DELAY = 100;
  protected static final long DEFAULT_DELAY = 1000;
  protected static final long DEFAULT_CHECK_DELAY = 300000; // 5 minutes

  protected WaarpFuture future;
  protected WaarpFuture internalfuture;
  protected boolean stopped;
  protected final String name;
  protected final File statusFile;
  protected final File stopFile;
<span class="fc" id="L87">  protected final List&lt;File&gt; directories = new ArrayList&lt;File&gt;();</span>
  protected final DigestAlgo digest;
<span class="fc" id="L89">  protected long elapseTime = DEFAULT_DELAY; // default to 1s</span>
<span class="fc" id="L90">  protected long elapseWaarpTime = -1; // default set to run after each run</span>
<span class="fc" id="L91">  protected long checkDelay = DEFAULT_CHECK_DELAY; // default set to 5 minutes</span>
  protected Timer timer;
  protected Timer timerWaarp;
  // used only if elapseWaarpTime &gt; defaultDelay (1s)
  protected final boolean scanSubDir;

<span class="fc" id="L97">  protected boolean ignoreAlreadyUsed = false;</span>

  protected boolean initialized;
  protected File checkFile;

<span class="fc" id="L102">  protected final ConcurrentHashMap&lt;String, FileItem&gt; fileItems =</span>
      new ConcurrentHashMap&lt;String, FileItem&gt;();
<span class="fc" id="L104">  protected final ConcurrentHashMap&lt;String, FileItem&gt; lastFileItems =</span>
      new ConcurrentHashMap&lt;String, FileItem&gt;();

<span class="fc" id="L107">  protected FileFilter filter = new FileFilter() {</span>
    @Override
    public boolean accept(final File pathname) {
<span class="fc" id="L110">      return pathname.isFile();</span>
    }
  };
  protected final FileMonitorCommandRunnableFuture commandValidFile;
  protected FileMonitorCommandFactory commandValidFileFactory;
  protected ExecutorService executor;
  protected int fixedThreadPool;
  protected final FileMonitorCommandRunnableFuture commandRemovedFile;
  protected FileMonitorCommandRunnableFuture commandCheckIteration;

<span class="fc" id="L120">  protected final ConcurrentLinkedQueue&lt;FileItem&gt; toUse =</span>
      new ConcurrentLinkedQueue&lt;FileItem&gt;();
<span class="fc" id="L122">  protected final ConcurrentLinkedQueue&lt;Future&lt;?&gt;&gt; results =</span>
      new ConcurrentLinkedQueue&lt;Future&lt;?&gt;&gt;();

<span class="fc" id="L125">  protected final AtomicLong globalok = new AtomicLong(0);</span>
<span class="fc" id="L126">  protected final AtomicLong globalerror = new AtomicLong(0);</span>
<span class="fc" id="L127">  protected final AtomicLong todayok = new AtomicLong(0);</span>
<span class="fc" id="L128">  protected final AtomicLong todayerror = new AtomicLong(0);</span>
  protected Date nextDay;

  /**
   * @param name name of this daemon
   * @param statusFile the file where the current status is saved
   *     (current
   *     files)
   * @param stopFile the file when created (.exists()) will stop the
   *     daemon
   * @param directory the directory where files will be monitored
   * @param digest the digest to use (default if null is MD5)
   * @param elapseTime the time to wait in ms for between 2 checks
   *     (default
   *     is 1000ms, minimum is
   *     100ms)
   * @param filter the filter to be applied on selected files (default
   *     is
   *     isFile())
   * @param commandValidFile the commandValidFile to run (may be null,
   *     which
   *     means poll() commandValidFile
   *     has to be used)
   * @param commandRemovedFile the commandRemovedFile to run (may be
   *     null)
   * @param commandCheckIteration the commandCheckIteration to run
   *     (may be
   *     null), runs after each check
   *     (elapseTime)
   */
  public FileMonitor(final String name, final File statusFile,
                     final File stopFile, final File directory,
                     final DigestAlgo digest, final long elapseTime,
                     final FileFilter filter, final boolean scanSubdir,
                     final FileMonitorCommandRunnableFuture commandValidFile,
                     final FileMonitorCommandRunnableFuture commandRemovedFile,
<span class="fc" id="L164">                     final FileMonitorCommandRunnableFuture commandCheckIteration) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (logger == null) {</span>
<span class="fc" id="L166">      logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
    }
<span class="fc" id="L168">    this.name = name;</span>
<span class="fc" id="L169">    this.statusFile = statusFile;</span>
<span class="fc" id="L170">    this.stopFile = stopFile;</span>
<span class="fc" id="L171">    directories.add(directory);</span>
<span class="fc" id="L172">    scanSubDir = scanSubdir;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">    if (digest == null) {</span>
<span class="fc" id="L174">      this.digest = defaultDigestAlgo;</span>
    } else {
<span class="nc" id="L176">      this.digest = digest;</span>
    }
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">    if (elapseTime &gt;= MINIMAL_DELAY) {</span>
<span class="fc" id="L179">      this.elapseTime = (elapseTime / 10) * 10;</span>
    }
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (filter != null) {</span>
<span class="fc" id="L182">      this.filter = filter;</span>
    }
<span class="fc" id="L184">    this.commandValidFile = commandValidFile;</span>
<span class="fc" id="L185">    this.commandRemovedFile = commandRemovedFile;</span>
<span class="fc" id="L186">    this.commandCheckIteration = commandCheckIteration;</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">    if (statusFile != null) {</span>
<span class="fc" id="L188">      checkFile = new File(statusFile.getAbsolutePath() + &quot;.chk&quot;);</span>
    }
<span class="fc" id="L190">    reloadStatus();</span>
<span class="fc" id="L191">    setNextDay();</span>
<span class="fc" id="L192">  }</span>

  protected void setNextDay() {
<span class="fc" id="L195">    final Calendar c = new GregorianCalendar();</span>
<span class="fc" id="L196">    c.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L197">    c.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L198">    c.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L199">    c.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L200">    c.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="fc" id="L201">    nextDay = c.getTime();</span>
<span class="fc" id="L202">  }</span>

  /**
   * @param commandCheckIteration the commandCheckIteration to run
   *     (may be
   *     null), runs after each check
   *     (elapseTime)
   */
  public void setCommandCheckIteration(
      final FileMonitorCommandRunnableFuture commandCheckIteration) {
<span class="nc" id="L212">    this.commandCheckIteration = commandCheckIteration;</span>
<span class="nc" id="L213">  }</span>

  /**
   * @param factory the factory to used instead of simple instance
   *     (enables
   *     parallelism)
   * @param fixedPool if &gt; 0, set the number of parallel threads
   *     allowed
   */
  public void setCommandValidFileFactory(
      final FileMonitorCommandFactory factory, final int fixedPool) {
<span class="nc" id="L224">    commandValidFileFactory = factory;</span>
<span class="nc" id="L225">    fixedThreadPool = fixedPool;</span>
<span class="nc" id="L226">  }</span>

  /**
   * @return the elapseWaarpTime
   */
  public long getElapseWaarpTime() {
<span class="nc" id="L232">    return elapseWaarpTime;</span>
  }

  /**
   * if set greater than 1000 ms, will be parallel, else will be sequential
   * after each check and ignoring this
   * timer
   *
   * @param elapseWaarpTime the elapseWaarpTime to set
   */
  public void setElapseWaarpTime(final long elapseWaarpTime) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">    if (elapseWaarpTime &gt;= DEFAULT_DELAY) {</span>
<span class="nc" id="L244">      this.elapseWaarpTime = (elapseWaarpTime / 10) * 10;</span>
    }
<span class="nc" id="L246">  }</span>

  /**
   * @return True if Already used files will be ignored
   */
  public boolean isIgnoreAlreadyUsed() {
<span class="nc" id="L252">    return ignoreAlreadyUsed;</span>
  }

  /**
   * @param ignoreAlreadyUsed if True, already used files will be ignored.
   *     Else if False, if an already used file is modified, then it will be reused.
   */
  public void setIgnoreAlreadyUsed(final boolean ignoreAlreadyUsed) {
<span class="fc" id="L260">    this.ignoreAlreadyUsed = ignoreAlreadyUsed;</span>
<span class="fc" id="L261">  }</span>

  /**
   * @param checkDelay the delay before checking if action was
   *     correctly taken
   */
  public void setCheckDelay(final long checkDelay) {
<span class="fc" id="L268">    this.checkDelay = checkDelay;</span>
<span class="fc" id="L269">  }</span>

  /**
   * Add a directory to scan
   *
   * @param directory
   */
  public void addDirectory(final File directory) {
<span class="fc" id="L277">    synchronized (directories) {</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">      if (!directories.contains(directory)) {</span>
<span class="fc" id="L279">        directories.add(directory);</span>
      }
<span class="fc" id="L281">    }</span>
<span class="fc" id="L282">  }</span>

  /**
   * Add a directory to scan
   *
   * @param directory
   */
  public void removeDirectory(final File directory) {
<span class="fc" id="L290">    synchronized (directories) {</span>
<span class="fc" id="L291">      directories.remove(directory);</span>
<span class="fc" id="L292">    }</span>
<span class="fc" id="L293">  }</span>

  protected void setThreadName() {
<span class="fc" id="L296">    Thread.currentThread().setName(&quot;FileMonitor_&quot; + name);</span>
<span class="fc" id="L297">  }</span>

  private boolean testChkFile() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (checkFile.exists()) {</span>
<span class="nc" id="L301">      deleteChkFile();</span>
<span class="nc" id="L302">      final long time = elapseTime * 10;</span>
<span class="nc" id="L303">      logger.warn(</span>
          &quot;Waiting to check if another Monitor is running with the same configuration: &quot; +
          time / 1000 + 's');
      try {
<span class="nc" id="L307">        Thread.sleep(time);</span>
<span class="nc" id="L308">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L309">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L310">      }</span>
<span class="nc" id="L311">      return checkFile.exists();</span>
    }
<span class="nc" id="L313">    return false;</span>
  }

  private void createChkFile() {
    try {
<span class="fc bfc" id="L318" title="All 2 branches covered.">      if (!checkFile.createNewFile()) {</span>
<span class="fc" id="L319">        logger.info(&quot;Cannot create Check File&quot;);</span>
      }
<span class="nc" id="L321">    } catch (final IOException ignored) {</span>
<span class="nc" id="L322">      SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="fc" id="L323">    }</span>
<span class="fc" id="L324">  }</span>

  private void deleteChkFile() {
<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (!checkFile.delete()) {</span>
<span class="fc" id="L328">      logger.info(&quot;Cannot delete Check File&quot;);</span>
    }
<span class="fc" id="L330">  }</span>

  protected void reloadStatus() {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (statusFile == null) {</span>
<span class="nc" id="L334">      return;</span>
    }
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    if (!statusFile.exists()) {</span>
<span class="fc" id="L337">      initialized = true;</span>
<span class="fc" id="L338">      return;</span>
    }
<span class="nc bnc" id="L340" title="All 2 branches missed.">    if (testChkFile()) {</span>
      // error ! one other monitor is running using the same status file
<span class="nc" id="L342">      logger.warn(</span>
          &quot;Error: One other monitor is probably running using the same status file: &quot; +
          statusFile);
<span class="nc" id="L345">      return;</span>
    }
<span class="nc" id="L347">    synchronized (directories) {</span>
      try {
<span class="nc" id="L349">        final HashMap&lt;String, FileItem&gt; newHashMap = JsonHandler.mapper</span>
<span class="nc" id="L350">            .readValue(statusFile,</span>
<span class="nc" id="L351">                       new TypeReference&lt;HashMap&lt;String, FileItem&gt;&gt;() {</span>
                       });
<span class="nc" id="L353">        fileItems.putAll(newHashMap);</span>
<span class="nc" id="L354">        initialized = true;</span>
<span class="nc" id="L355">      } catch (final JsonParseException ignored) {</span>
<span class="nc" id="L356">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L357">      } catch (final JsonMappingException ignored) {</span>
<span class="nc" id="L358">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L359">      } catch (final IOException ignored) {</span>
<span class="nc" id="L360">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L361">      }</span>
<span class="nc" id="L362">    }</span>
<span class="nc" id="L363">  }</span>

  /**
   * @return True if the FileMonitor is correctly initialized
   */
  public boolean initialized() {
<span class="nc" id="L369">    return initialized;</span>
  }

  protected void saveStatus() {
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">    if (statusFile == null) {</span>
<span class="nc" id="L374">      return;</span>
    }
<span class="fc" id="L376">    synchronized (directories) {</span>
      try {
<span class="fc" id="L378">        JsonHandler.mapper.writeValue(statusFile, fileItems);</span>
<span class="fc" id="L379">        createChkFile();</span>
<span class="nc" id="L380">      } catch (final JsonGenerationException ignored) {</span>
<span class="nc" id="L381">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L382">      } catch (final JsonMappingException ignored) {</span>
<span class="nc" id="L383">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="nc" id="L384">      } catch (final IOException ignored) {</span>
<span class="nc" id="L385">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignored);</span>
<span class="pc" id="L386">      }</span>
<span class="fc" id="L387">    }</span>
<span class="fc" id="L388">  }</span>

  /**
   * @return the number of fileItems in the current history (active, in error
   *     or
   *     past)
   */
  public long getCurrentHistoryNb() {
<span class="fc" id="L396">    synchronized (directories) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">      if (fileItems != null) {</span>
<span class="fc" id="L398">        return fileItems.size();</span>
      }
<span class="nc" id="L400">    }</span>
<span class="nc" id="L401">    return -1;</span>
  }

  /**
   * Reset such that next status will be full (not partial)
   */
  public void setNextAsFullStatus() {
<span class="fc" id="L408">    lastFileItems.clear();</span>
<span class="fc" id="L409">  }</span>

  /**
   * @return the status (updated only) in JSON format
   */
  public String getStatus() {
<span class="fc" id="L415">    Set&lt;String&gt; removedFileItems = null;</span>
<span class="fc" id="L416">    final ConcurrentHashMap&lt;String, FileItem&gt; newFileItems =</span>
        new ConcurrentHashMap&lt;String, FileItem&gt;();
<span class="fc" id="L418">    synchronized (directories) {</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">      if (!lastFileItems.isEmpty()) {</span>
<span class="nc" id="L420">        removedFileItems = ((Map&lt;String, FileItem&gt;) lastFileItems).keySet();</span>
<span class="nc" id="L421">        removedFileItems</span>
<span class="nc" id="L422">            .removeAll(((Map&lt;String, FileItem&gt;) fileItems).keySet());</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">          if (!key.getValue().isStrictlySame(lastFileItems.get(key.getKey()))) {</span>
<span class="nc" id="L425">            newFileItems.put(key.getKey(), key.getValue());</span>
          }
<span class="nc" id="L427">        }</span>
      } else {
<span class="fc bfc" id="L429" title="All 2 branches covered.">        for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="fc" id="L430">          newFileItems.put(key.getKey(), key.getValue());</span>
<span class="fc" id="L431">        }</span>
      }
<span class="fc" id="L433">      final FileMonitorInformation fileMonitorInformation =</span>
          new FileMonitorInformation(name, newFileItems, removedFileItems,
                                     directories, stopFile, statusFile,
                                     elapseTime, scanSubDir, globalok,
                                     globalerror, todayok, todayerror);
<span class="fc bfc" id="L438" title="All 2 branches covered.">      for (final Entry&lt;String, FileItem&gt; key : fileItems.entrySet()) {</span>
<span class="fc" id="L439">        final FileItem clone = key.getValue().clone();</span>
<span class="fc" id="L440">        lastFileItems.put(key.getKey(), clone);</span>
<span class="fc" id="L441">      }</span>
<span class="fc" id="L442">      createChkFile();</span>
<span class="fc" id="L443">      final String status = JsonHandler.writeAsString(fileMonitorInformation);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">      if (removedFileItems != null) {</span>
<span class="nc" id="L445">        removedFileItems.clear();</span>
      }
<span class="fc" id="L447">      newFileItems.clear();</span>
<span class="fc" id="L448">      return status;</span>
    }
  }

  /**
   * @return the elapseTime
   */
  public long getElapseTime() {
<span class="nc" id="L456">    return elapseTime;</span>
  }

  /**
   * @param elapseTime the elapseTime to set
   */
  public void setElapseTime(final long elapseTime) {
<span class="nc" id="L463">    this.elapseTime = elapseTime;</span>
<span class="nc" id="L464">  }</span>

  /**
   * @param filter the filter to set
   */
  public void setFilter(final FileFilter filter) {
<span class="nc" id="L470">    this.filter = filter;</span>
<span class="nc" id="L471">  }</span>

  public void start() {
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    if (timer == null) {</span>
<span class="fc" id="L475">      timer = new HashedWheelTimer(</span>
          new WaarpThreadFactory(&quot;TimerFileMonitor_&quot; + name), 100,
          TimeUnit.MILLISECONDS, 8);
<span class="fc" id="L478">      future = new WaarpFuture(true);</span>
<span class="fc" id="L479">      internalfuture = new WaarpFuture(true);</span>
<span class="pc bpc" id="L480" title="3 of 4 branches missed.">      if (commandValidFileFactory != null &amp;&amp; executor == null) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (fixedThreadPool &gt; 1) {</span>
<span class="nc" id="L482">          executor = Executors.newFixedThreadPool(fixedThreadPool,</span>
                                                  new WaarpThreadFactory(
                                                      &quot;FileMonitorRunner_&quot; +
                                                      name));
<span class="nc bnc" id="L486" title="All 2 branches missed.">        } else if (fixedThreadPool == 0) {</span>
<span class="nc" id="L487">          executor = Executors.newCachedThreadPool(</span>
              new WaarpThreadFactory(&quot;FileMonitorRunner_&quot; + name));
        }
      }
<span class="fc" id="L491">      timer.newTimeout(new FileMonitorTimerTask(this), elapseTime,</span>
                       TimeUnit.MILLISECONDS);
    } // else already started
<span class="pc bpc" id="L494" title="5 of 6 branches missed.">    if (elapseWaarpTime &gt;= DEFAULT_DELAY &amp;&amp; timerWaarp == null &amp;&amp;</span>
        commandCheckIteration != null) {
<span class="nc" id="L496">      timerWaarp = new HashedWheelTimer(</span>
          new WaarpThreadFactory(&quot;TimerFileMonitorWaarp_&quot; + name), 100,
          TimeUnit.MILLISECONDS, 8);
<span class="nc" id="L499">      timerWaarp.newTimeout(</span>
          new FileMonitorTimerInformationTask(commandCheckIteration),
          elapseWaarpTime, TimeUnit.MILLISECONDS);
    }
<span class="fc" id="L503">  }</span>

  public void stop() {
<span class="fc" id="L506">    initialized = false;</span>
<span class="fc" id="L507">    stopped = true;</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">    if (timerWaarp != null) {</span>
<span class="nc" id="L509">      timerWaarp.stop();</span>
    }
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">    if (internalfuture != null) {</span>
<span class="fc" id="L512">      internalfuture.awaitOrInterruptible(elapseTime * 2);</span>
<span class="fc" id="L513">      internalfuture.setSuccess();</span>
    }
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">    if (timer != null) {</span>
<span class="fc" id="L516">      timer.stop();</span>
    }
<span class="fc" id="L518">    timer = null;</span>
<span class="fc" id="L519">    timerWaarp = null;</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">    if (executor != null) {</span>
<span class="nc" id="L521">      executor.shutdown();</span>
<span class="nc" id="L522">      executor = null;</span>
    }
<span class="fc" id="L524">    deleteChkFile();</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">    if (future != null) {</span>
<span class="fc" id="L526">      future.setSuccess();</span>
    }
<span class="fc" id="L528">  }</span>

  /**
   * @return the head of the File queue but does not remove it
   */
  public File peek() {
<span class="nc" id="L534">    final FileItem item = toUse.peek();</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">    if (item == null) {</span>
<span class="nc" id="L536">      return null;</span>
    }
<span class="nc" id="L538">    return item.file;</span>
  }

  /**
   * @return the head of the File queue and removes it
   */
  public File poll() {
<span class="nc" id="L545">    final FileItem item = toUse.poll();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">    if (item == null) {</span>
<span class="nc" id="L547">      return null;</span>
    }
<span class="nc" id="L549">    return item.file;</span>
  }

  /**
   * Wait until the Stop file is created
   */
  public void waitForStopFile() {
<span class="fc" id="L556">    internalfuture.awaitOrInterruptible();</span>
<span class="fc" id="L557">    stop();</span>
<span class="fc" id="L558">  }</span>

  private boolean checkStop() {
<span class="pc bpc" id="L561" title="1 of 4 branches missed.">    if (stopped || stopFile.exists()) {</span>
<span class="fc" id="L562">      logger.warn(</span>
          &quot;STOPPING the FileMonitor {} since condition is fullfilled: stop file found ({}): &quot; +
<span class="fc" id="L564">          stopFile.exists(), name, stopFile);</span>
<span class="fc" id="L565">      internalfuture.setSuccess();</span>
<span class="fc" id="L566">      return true;</span>
    }
<span class="fc" id="L568">    return false;</span>
  }

  /**
   * Check Files
   *
   * @return False to stop
   */
  protected boolean checkFiles() {
<span class="fc" id="L577">    setThreadName();</span>
<span class="fc" id="L578">    boolean fileItemsChanged = false;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">    if (checkStop()) {</span>
<span class="fc" id="L580">      return false;</span>
    }
<span class="fc" id="L582">    synchronized (directories) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">      for (final File directory : directories) {</span>
<span class="fc" id="L584">        logger.info(&quot;Scan: {}&quot;, directory);</span>
<span class="fc" id="L585">        fileItemsChanged = checkOneDir(fileItemsChanged, directory);</span>
<span class="fc" id="L586">      }</span>
<span class="fc" id="L587">    }</span>
<span class="fc" id="L588">    setThreadName();</span>
<span class="fc" id="L589">    boolean error = false;</span>
    // Wait for all commands to finish before continuing
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">    for (final Future&lt;?&gt; futureResult : results) {</span>
<span class="nc" id="L592">      createChkFile();</span>
      try {
<span class="nc" id="L594">        futureResult.get();</span>
<span class="nc" id="L595">      } catch (final InterruptedException e) {//NOSONAR</span>
<span class="nc" id="L596">        SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L597">        logger.info(&quot;Interruption so exit&quot;);</span>
<span class="nc" id="L598">        error = true;</span>
<span class="nc" id="L599">      } catch (final ExecutionException e) {</span>
<span class="nc" id="L600">        logger.error(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L601">        error = true;</span>
<span class="nc" id="L602">      } catch (final Throwable e) {</span>
<span class="nc" id="L603">        logger.error(&quot;Exception during execution&quot;, e);</span>
<span class="nc" id="L604">        error = true;</span>
<span class="nc" id="L605">      }</span>
<span class="nc" id="L606">    }</span>
<span class="fc" id="L607">    logger.debug(&quot;Scan over&quot;);</span>
<span class="fc" id="L608">    results.clear();</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">    if (error) {</span>
      // do not save ?
      // this.saveStatus()
<span class="nc" id="L612">      return false;</span>
    }
    // now check that all existing items are still valid
<span class="fc" id="L615">    final List&lt;FileItem&gt; todel = new LinkedList&lt;FileItem&gt;();</span>
<span class="fc" id="L616">    synchronized (directories) {</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">      for (final FileItem item : fileItems.values()) {</span>
<span class="pc bpc" id="L618" title="1 of 4 branches missed.">        if (item.file != null &amp;&amp; item.file.isFile()) {</span>
<span class="fc" id="L619">          continue;</span>
        }
<span class="fc" id="L621">        todel.add(item);</span>
<span class="fc" id="L622">      }</span>
      // remove invalid files
<span class="fc bfc" id="L624" title="All 2 branches covered.">      for (final FileItem fileItem : todel) {</span>
<span class="fc" id="L625">        final String newName =</span>
<span class="fc" id="L626">            AbstractDir.normalizePath(fileItem.file.getAbsolutePath());</span>
<span class="fc" id="L627">        fileItems.remove(newName);</span>
<span class="fc" id="L628">        toUse.remove(fileItem);</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        if (commandRemovedFile != null) {</span>
<span class="fc" id="L630">          commandRemovedFile.run(fileItem);</span>
        }
<span class="fc" id="L632">        fileItem.file = null;</span>
<span class="fc" id="L633">        fileItem.hash = null;</span>
<span class="fc" id="L634">        fileItemsChanged = true;</span>
<span class="fc" id="L635">      }</span>
<span class="fc" id="L636">    }</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">    if (fileItemsChanged) {</span>
<span class="fc" id="L638">      saveStatus();</span>
    } else {
<span class="fc" id="L640">      createChkFile();</span>
    }
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">    if (checkStop()) {</span>
<span class="nc" id="L643">      return false;</span>
    }
<span class="fc" id="L645">    logger.debug(&quot;Finishing step&quot;);</span>

<span class="pc bpc" id="L647" title="2 of 4 branches missed.">    if (commandCheckIteration != null &amp;&amp; timerWaarp == null) {</span>
<span class="fc" id="L648">      commandCheckIteration.run(null);</span>
    }
<span class="fc" id="L650">    return true;</span>
  }

  private void setIfAlreadyUsed(final FileItem fileItem, final boolean valid) {
<span class="fc bfc" id="L654" title="All 6 branches covered.">    if (!ignoreAlreadyUsed &amp;&amp; fileItem.specialId != DbConstant.ILLEGALVALUE &amp;&amp;</span>
        fileItem.used) {
<span class="pc bpc" id="L656" title="2 of 5 branches missed.">      switch (fileItem.status) {</span>
        case START:
<span class="nc" id="L658">          fileItem.status = Status.CHANGING;</span>
<span class="nc" id="L659">          break;</span>
        case CHANGING:
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L662">            fileItem.status = Status.VALID;</span>
          }
          break;
        case VALID:
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L667">            fileItem.status = Status.RESTART;</span>
          }
          break;
        case DONE:
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="nc" id="L672">            fileItem.status = Status.START;</span>
          }
          break;
        case RESTART:
<span class="fc" id="L676">          break;</span>
      }
    } else {
<span class="pc bpc" id="L679" title="1 of 3 branches missed.">      switch (fileItem.status) {</span>
        case START:
<span class="nc" id="L681">          fileItem.status = Status.CHANGING;</span>
<span class="nc" id="L682">          break;</span>
        case CHANGING:
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">          if (valid) {</span>
<span class="fc" id="L685">            fileItem.status = Status.VALID;</span>
          }
          break;
        case VALID:
        case DONE:
        case RESTART:
          break;
      }
    }
<span class="fc" id="L694">  }</span>

  /**
   * @param fileItemsChanged
   * @param directory
   *
   * @return True if one file at least has changed
   */
  protected boolean checkOneDir(boolean fileItemsChanged,
                                final File directory) {
    try {
<span class="fc" id="L705">      File[] files = directory.listFiles(filter);</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">      for (final File file : files) {</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (checkStop()) {</span>
<span class="nc" id="L708">          return false;</span>
        }
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">        if (file.isDirectory()) {</span>
<span class="nc" id="L711">          continue;</span>
        }
<span class="fc" id="L713">        final String newName =</span>
<span class="fc" id="L714">            AbstractDir.normalizePath(file.getAbsolutePath());</span>
        final FileItem fileItem;
<span class="fc" id="L716">        synchronized (directories) {</span>
<span class="fc" id="L717">          fileItem = fileItems.get(newName);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">          if (fileItem == null) {</span>
            // never seen until now
<span class="fc" id="L720">            fileItems.put(newName, new FileItem(file));</span>
<span class="fc" id="L721">            fileItemsChanged = true;</span>
<span class="fc" id="L722">            continue;</span>
          }
<span class="fc bfc" id="L724" title="All 4 branches covered.">          if (fileItem.used &amp;&amp; ignoreAlreadyUsed) {</span>
            // already used so ignore
<span class="fc" id="L726">            continue;</span>
          }
<span class="fc" id="L728">        }</span>
<span class="fc" id="L729">        logger.debug(&quot;File check: {}&quot;, fileItem);</span>
<span class="fc" id="L730">        final long size = fileItem.file.length();</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (size != fileItem.size) {</span>
<span class="fc" id="L732">          fileItemsChanged = isFileItemsChangedOnSize(fileItem, size);</span>
<span class="fc" id="L733">          continue;</span>
        }
<span class="fc" id="L735">        final long lastTimeModified = fileItem.file.lastModified();</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (lastTimeModified != fileItem.lastTime) {</span>
<span class="fc" id="L737">          fileItemsChanged =</span>
<span class="fc" id="L738">              isFileItemsChangedOnLastTimeModified(fileItem, lastTimeModified);</span>
<span class="fc" id="L739">          continue;</span>
        }
        // now check Hash or third time
        try {
<span class="fc" id="L743">          final byte[] hash =</span>
<span class="fc" id="L744">              FilesystemBasedDigest.getHash(fileItem.file, true, digest);</span>
<span class="pc bpc" id="L745" title="1 of 4 branches missed.">          if (hash == null || fileItem.hash == null) {</span>
            // First set
<span class="fc" id="L747">            fileItemsChanged = isFileItemsChangedOnHash(fileItem, hash);</span>
<span class="fc" id="L748">            continue;</span>
          }
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">          if (!Arrays.equals(hash, fileItem.hash)) {</span>
            // Second check true
<span class="nc" id="L752">            fileItemsChanged = isFileItemsChangedOnHash(fileItem, hash);</span>
<span class="nc" id="L753">            continue;</span>
          } else {
<span class="fc bfc" id="L755" title="All 2 branches covered.">            setIfAlreadyUsed(fileItem, fileItem.status != Status.DONE);</span>
          }
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">          if (checkStop()) {</span>
<span class="nc" id="L758">            return false;</span>
          }
<span class="fc" id="L760">          boolean toIgnore = false;</span>
<span class="pc bpc" id="L761" title="1 of 6 branches missed.">          if (!ignoreAlreadyUsed &amp;&amp; fileItem.used &amp;&amp;</span>
              fileItem.specialId != DbConstant.ILLEGALVALUE) {
<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (fileItem.status != Status.RESTART) {</span>
<span class="fc" id="L764">              logger.debug(&quot;File Ignore check: {}&quot;, fileItem);</span>
<span class="fc" id="L765">              toIgnore = true;</span>
            }
          }
<span class="fc" id="L768">          logger.debug(&quot;File Run check: {}&quot;, fileItem);</span>
          // now time and hash are the same so act on it
<span class="fc" id="L770">          fileItem.timeUsed = System.currentTimeMillis();</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">          if (commandValidFileFactory != null) {</span>
<span class="nc" id="L772">            final FileMonitorCommandRunnableFuture torun =</span>
<span class="nc" id="L773">                commandValidFileFactory.create(fileItem);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (!torun.checkFileItemBusiness(fileItem)) {</span>
<span class="nc" id="L775">              logger.debug(&quot;File Ignore Business check: {}&quot;, fileItem);</span>
<span class="nc" id="L776">              continue;</span>
            }
<span class="nc bnc" id="L778" title="All 2 branches missed.">            if (toIgnore) {</span>
<span class="nc" id="L779">              continue;</span>
            }
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (executor != null) {</span>
<span class="nc" id="L782">              final Future&lt;?&gt; torunFuture = executor.submit(torun);</span>
<span class="nc" id="L783">              results.add(torunFuture);</span>
<span class="nc" id="L784">            } else {</span>
<span class="nc" id="L785">              torun.run(fileItem);</span>
            }
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">          } else if (commandValidFile != null) {</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (!commandValidFile.checkFileItemBusiness(fileItem)) {</span>
<span class="fc" id="L789">              logger.debug(&quot;File Ignore Business check: {}&quot;, fileItem);</span>
<span class="fc" id="L790">              continue;</span>
            }
<span class="fc bfc" id="L792" title="All 2 branches covered.">            if (toIgnore) {</span>
<span class="fc" id="L793">              continue;</span>
            }
<span class="fc" id="L795">            commandValidFile.run(fileItem);</span>
          } else {
<span class="nc bnc" id="L797" title="All 2 branches missed.">            if (toIgnore) {</span>
<span class="nc" id="L798">              continue;</span>
            }
<span class="nc" id="L800">            toUse.add(fileItem);</span>
          }
<span class="fc" id="L802">          fileItemsChanged = true;</span>
<span class="nc" id="L803">        } catch (final Throwable e) {</span>
<span class="nc" id="L804">          setThreadName();</span>
<span class="nc" id="L805">          logger.error(&quot;Error during final file check&quot;, e);</span>
<span class="fc" id="L806">        }</span>
      }
<span class="fc bfc" id="L808" title="All 2 branches covered.">      if (scanSubDir) {</span>
<span class="fc" id="L809">        files = directory.listFiles();</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (final File file : files) {</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">          if (checkStop()) {</span>
<span class="nc" id="L812">            return false;</span>
          }
<span class="fc bfc" id="L814" title="All 2 branches covered.">          if (file.isDirectory()) {</span>
<span class="fc" id="L815">            fileItemsChanged = checkOneDir(fileItemsChanged, file);</span>
          }
        }
      }
<span class="nc" id="L819">    } catch (final Throwable e) {</span>
<span class="nc" id="L820">      setThreadName();</span>
<span class="nc" id="L821">      logger.error(&quot;Issue during Directory and File Checking&quot;, e);</span>
      // ignore
<span class="fc" id="L823">    }</span>
<span class="fc" id="L824">    return fileItemsChanged;</span>
  }

  private boolean isFileItemsChangedOnHash(final FileItem fileItem,
                                           final byte[] hash) {
<span class="fc" id="L829">    fileItem.hash = hash;</span>
<span class="fc" id="L830">    fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L831">    logger.debug(&quot;File Hash check: {}&quot;, fileItem);</span>
<span class="fc" id="L832">    return true;</span>
  }

  private boolean isFileItemsChangedOnLastTimeModified(final FileItem fileItem,
                                                       final long lastTimeModified) {
    // changed or second time check
<span class="fc" id="L838">    fileItem.lastTime = lastTimeModified;</span>
<span class="fc bfc" id="L839" title="All 4 branches covered.">    if (!ignoreAlreadyUsed &amp;&amp; fileItem.used) {</span>
<span class="fc" id="L840">      fileItem.hash = null;</span>
    }
<span class="fc" id="L842">    fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L843">    logger.debug(&quot;File Change check: {}({})&quot;, fileItem, lastTimeModified);</span>
<span class="fc" id="L844">    return true;</span>
  }

  private boolean isFileItemsChangedOnSize(final FileItem fileItem,
                                           final long size) {
    // changed or second size check
<span class="fc" id="L850">    fileItem.size = size;</span>
<span class="fc" id="L851">    fileItem.status = Status.CHANGING;</span>
<span class="fc" id="L852">    logger.debug(&quot;File Size check: {}({})&quot;, fileItem, size);</span>
<span class="fc" id="L853">    return true;</span>
  }

  /**
   * Timer task
   */
  protected static class FileMonitorTimerTask implements TimerTask {
    protected final FileMonitor fileMonitor;

    /**
     * @param fileMonitor
     */
<span class="fc" id="L865">    protected FileMonitorTimerTask(final FileMonitor fileMonitor) {</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">      if (logger == null) {</span>
<span class="nc" id="L867">        logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
      }
<span class="fc" id="L869">      this.fileMonitor = fileMonitor;</span>
<span class="fc" id="L870">    }</span>

    @Override
    public void run(final Timeout timeout) {
      try {
<span class="fc bfc" id="L875" title="All 2 branches covered.">        if (fileMonitor.checkFiles()) {</span>
<span class="fc" id="L876">          fileMonitor.setThreadName();</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">          if (fileMonitor.timer != null) {</span>
            try {
<span class="fc" id="L879">              fileMonitor.timer.newTimeout(this, fileMonitor.elapseTime,</span>
                                           TimeUnit.MILLISECONDS);
<span class="nc" id="L881">            } catch (final Throwable e) {</span>
<span class="nc" id="L882">              logger.error(&quot;Error while pushing next filemonitor step&quot;, e);</span>
              // ignore and stop
<span class="nc" id="L884">              fileMonitor.internalfuture.setSuccess();</span>
<span class="pc" id="L885">            }</span>
          } else {
<span class="nc" id="L887">            logger.warn(&quot;No Timer found&quot;);</span>
<span class="nc" id="L888">            fileMonitor.internalfuture.setSuccess();</span>
          }
        } else {
<span class="fc" id="L891">          fileMonitor.setThreadName();</span>
<span class="fc" id="L892">          logger.warn(&quot;Stop file found&quot;);</span>
<span class="fc" id="L893">          fileMonitor.deleteChkFile();</span>
<span class="fc" id="L894">          fileMonitor.internalfuture.setSuccess();</span>
        }
<span class="nc" id="L896">      } catch (final Throwable e) {</span>
<span class="nc" id="L897">        fileMonitor.setThreadName();</span>
<span class="nc" id="L898">        logger.error(&quot;Issue during Directory and File Checking&quot;, e);</span>
<span class="nc" id="L899">        fileMonitor.internalfuture.setSuccess();</span>
<span class="fc" id="L900">      }</span>
<span class="fc" id="L901">    }</span>

  }

  /**
   * Class to run Waarp Business information in fixed delay rather than after
   * each check
   */
  protected class FileMonitorTimerInformationTask implements TimerTask {
    protected final FileMonitorCommandRunnableFuture informationMonitorCommand;

    /**
     * @param informationMonitorCommand
     */
    protected FileMonitorTimerInformationTask(
<span class="nc" id="L916">        final FileMonitorCommandRunnableFuture informationMonitorCommand) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">      if (logger == null) {</span>
<span class="nc" id="L918">        logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
      }
<span class="nc" id="L920">      this.informationMonitorCommand = informationMonitorCommand;</span>
<span class="nc" id="L921">    }</span>

    @Override
    public void run(final Timeout timeout) {
      try {
<span class="nc" id="L926">        Thread.currentThread().setName(&quot;FileMonitorInformation_&quot; + name);</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (!checkStop()) {</span>
<span class="nc" id="L928">          informationMonitorCommand.run(null);</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">          if (timerWaarp != null &amp;&amp; !checkStop()) {</span>
            try {
<span class="nc" id="L931">              timerWaarp</span>
<span class="nc" id="L932">                  .newTimeout(this, elapseWaarpTime, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L933">            } catch (final Throwable e) {</span>
              // stop and ignore
<span class="nc" id="L935">              logger.error(&quot;Error during nex filemonitor information step&quot;, e);</span>
<span class="nc" id="L936">              internalfuture.setSuccess();</span>
<span class="nc" id="L937">            }</span>
          } else {
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (timerWaarp != null) {</span>
<span class="nc" id="L940">              logger.warn(&quot;Stop file found&quot;);</span>
            } else {
<span class="nc" id="L942">              logger.warn(&quot;No Timer found&quot;);</span>
            }
<span class="nc" id="L944">            internalfuture.setSuccess();</span>
          }
        } else {
<span class="nc" id="L947">          logger.warn(&quot;Stop file found&quot;);</span>
<span class="nc" id="L948">          internalfuture.setSuccess();</span>
        }
<span class="nc" id="L950">      } catch (final Throwable e) {</span>
        // stop and ignore
<span class="nc" id="L952">        Thread.currentThread().setName(&quot;FileMonitorInformation_&quot; + name);</span>
<span class="nc" id="L953">        logger.error(&quot;Error during nex filemonitor information step&quot;, e);</span>
<span class="nc" id="L954">        internalfuture.setSuccess();</span>
<span class="nc" id="L955">      }</span>
<span class="nc" id="L956">    }</span>
  }

  /**
   * Used by Waarp Business information
   */
  @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;@class&quot;)
  public static class FileMonitorInformation {
    public String name;
    public ConcurrentHashMap&lt;String, FileItem&gt; fileItems;
    public Set&lt;String&gt; removedFileItems;
    public List&lt;File&gt; directories;
    public File stopFile;
    public File statusFile;
    public long elapseTime;
    public boolean scanSubDir;
    public AtomicLong globalok;
    public AtomicLong globalerror;
    public AtomicLong todayok;
    public AtomicLong todayerror;

<span class="nc" id="L977">    public FileMonitorInformation() {</span>
      // empty constructor for JSON
<span class="nc" id="L979">    }</span>

    protected FileMonitorInformation(final String name,
                                     final ConcurrentHashMap&lt;String, FileItem&gt; fileItems,
                                     final Set&lt;String&gt; removedFileItems,
                                     final List&lt;File&gt; directories,
                                     final File stopFile, final File statusFile,
                                     final long elapseTime,
                                     final boolean scanSubDir,
                                     final AtomicLong globalok,
                                     final AtomicLong globalerror,
                                     final AtomicLong todayok,
<span class="fc" id="L991">                                     final AtomicLong todayerror) {</span>
<span class="fc" id="L992">      this.name = name;</span>
<span class="fc" id="L993">      this.fileItems = fileItems;</span>
<span class="fc" id="L994">      this.removedFileItems = removedFileItems;</span>
<span class="fc" id="L995">      this.directories = directories;</span>
<span class="fc" id="L996">      this.stopFile = stopFile;</span>
<span class="fc" id="L997">      this.statusFile = statusFile;</span>
<span class="fc" id="L998">      this.elapseTime = elapseTime;</span>
<span class="fc" id="L999">      this.scanSubDir = scanSubDir;</span>
<span class="fc" id="L1000">      this.globalok = globalok;</span>
<span class="fc" id="L1001">      this.globalerror = globalerror;</span>
<span class="fc" id="L1002">      this.todayok = todayok;</span>
<span class="fc" id="L1003">      this.todayerror = todayerror;</span>
<span class="fc" id="L1004">    }</span>

  }

<span class="fc" id="L1008">  public enum Status {</span>
<span class="fc" id="L1009">    START, CHANGING, VALID, DONE, RESTART</span>
  }

  /**
   * One element in the directory
   */
  public static class FileItem implements Cloneable {
    public File file;
    public long size;
    public byte[] hash;
<span class="pc" id="L1019">    public long lastTime = Long.MIN_VALUE;</span>
<span class="pc" id="L1020">    public long timeUsed = Long.MIN_VALUE;</span>
    public boolean used;
<span class="pc" id="L1022">    public Status status = Status.START;</span>
<span class="pc" id="L1023">    public long specialId = DbConstant.ILLEGALVALUE;</span>

<span class="nc" id="L1025">    public FileItem() {</span>
      // empty constructor for JSON
<span class="nc" id="L1027">    }</span>

    /**
     * @param file
     */
<span class="fc" id="L1032">    protected FileItem(final File file) {</span>
<span class="fc" id="L1033">      this.file = file;</span>
<span class="fc" id="L1034">    }</span>

    @Override
    public int hashCode() {
<span class="nc" id="L1038">      return file.hashCode();</span>
    }

    @Override
    public boolean equals(final Object obj) {
      // equality is based on file itself
<span class="nc bnc" id="L1044" title="All 4 branches missed.">      return obj instanceof FileItem &amp;&amp; file.equals(((FileItem) obj).file);</span>
    }

    /**
     * @param item
     *
     * @return True if the fileItem is strictly the same (and not only the
     *     file as in equals)
     */
    public boolean isStrictlySame(final FileItem item) {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">      return item != null &amp;&amp;</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">             file.getAbsolutePath().equals(item.file.getAbsolutePath()) &amp;&amp;</span>
<span class="nc bnc" id="L1056" title="All 8 branches missed.">             file.length() == item.size &amp;&amp; lastTime == item.lastTime &amp;&amp;</span>
             timeUsed == item.timeUsed &amp;&amp; used == item.used &amp;&amp;
<span class="nc bnc" id="L1058" title="All 4 branches missed.">             status.equals(item.status) &amp;&amp;</span>
<span class="nc bnc" id="L1059" title="All 4 branches missed.">             (hash != null? Arrays.equals(hash, item.hash) : item.hash == null);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L1064">      return file.getAbsolutePath() + &quot; : &quot; + size + &quot; : &quot; + specialId + &quot; : &quot; +</span>
             used + &quot; : &quot; + status + &quot; : &quot; + lastTime + &quot; : &quot; + timeUsed;
    }

    @Override
    public FileItem clone() { //NOSONAR
<span class="fc" id="L1070">      final FileItem clone = new FileItem(file);</span>
<span class="fc" id="L1071">      clone.hash = hash;</span>
<span class="fc" id="L1072">      clone.lastTime = lastTime;</span>
<span class="fc" id="L1073">      clone.timeUsed = timeUsed;</span>
<span class="fc" id="L1074">      clone.used = used;</span>
<span class="fc" id="L1075">      clone.specialId = specialId;</span>
<span class="fc" id="L1076">      clone.status = status;</span>
<span class="fc" id="L1077">      clone.size = size;</span>
<span class="fc" id="L1078">      return clone;</span>
    }
  }

  public static void main(final String[] args) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">    if (logger == null) {</span>
<span class="nc" id="L1084">      logger = WaarpLoggerFactory.getLogger(FileMonitor.class);</span>
    }
<span class="nc bnc" id="L1086" title="All 2 branches missed.">    if (args.length &lt; 3) {</span>
<span class="nc" id="L1087">      SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1088">          .syserr(&quot;Need a statusfile, a stopfile and a directory to test&quot;);</span>
<span class="nc" id="L1089">      return;</span>
    }
<span class="nc" id="L1091">    final File file = new File(args[0]);</span>
<span class="nc bnc" id="L1092" title="All 4 branches missed.">    if (file.exists() &amp;&amp; !file.isFile()) {</span>
<span class="nc" id="L1093">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a correct status file&quot;);</span>
<span class="nc" id="L1094">      return;</span>
    }
<span class="nc" id="L1096">    final File stopfile = new File(args[1]);</span>
<span class="nc bnc" id="L1097" title="All 4 branches missed.">    if (file.exists() &amp;&amp; !file.isFile()) {</span>
<span class="nc" id="L1098">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a correct stop file&quot;);</span>
<span class="nc" id="L1099">      return;</span>
    }
<span class="nc" id="L1101">    final File dir = new File(args[2]);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">    if (!dir.isDirectory()) {</span>
<span class="nc" id="L1103">      SysErrLogger.FAKE_LOGGER.syserr(&quot;Not a directory&quot;);</span>
<span class="nc" id="L1104">      return;</span>
    }
<span class="nc" id="L1106">    final FileMonitorCommandRunnableFuture filemonitor =</span>
<span class="nc" id="L1107">        new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(final FileItem file) {
<span class="nc" id="L1110">            SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1111">                .syserr(&quot;File New: &quot; + file.file.getAbsolutePath());</span>
<span class="nc" id="L1112">            finalizeValidFile(true, 0);</span>
<span class="nc" id="L1113">          }</span>
        };
<span class="nc" id="L1115">    final FileMonitor monitor =</span>
        new FileMonitor(&quot;test&quot;, file, stopfile, dir, null, 0,
                        new RegexFileFilter(
                            RegexFileFilter.REGEX_XML_EXTENSION), false,
<span class="nc" id="L1119">                        filemonitor, new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(final FileItem file) {
<span class="nc" id="L1122">            SysErrLogger.FAKE_LOGGER</span>
<span class="nc" id="L1123">                .syserr(&quot;File Del: &quot; + file.file.getAbsolutePath());</span>
<span class="nc" id="L1124">          }</span>
<span class="nc" id="L1125">        }, new FileMonitorCommandRunnableFuture() {</span>
          @Override
          public void run(final FileItem unused) {
<span class="nc" id="L1128">            SysErrLogger.FAKE_LOGGER.syserr(&quot;Check done&quot;);</span>
<span class="nc" id="L1129">          }</span>
        });
<span class="nc" id="L1131">    filemonitor.setMonitor(monitor);</span>
<span class="nc" id="L1132">    monitor.start();</span>
<span class="nc" id="L1133">    monitor.waitForStopFile();</span>
<span class="nc" id="L1134">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>