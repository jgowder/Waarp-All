<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WaarpSslUtility.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp Filesystem</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.crypto.ssl</a> &gt; <span class="el_source">WaarpSslUtility.java</span></div><h1>WaarpSslUtility.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.crypto.ssl;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.handler.ssl.SslHandler;
import io.netty.util.concurrent.DefaultEventExecutor;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.common.utility.WaarpThreadFactory;

import java.util.NoSuchElementException;

/**
 * Utilities for SSL support
 */
public final class WaarpSslUtility {
  /**
   * Internal Logger
   */
<span class="fc" id="L49">  private static final WaarpLogger logger =</span>
<span class="fc" id="L50">      WaarpLoggerFactory.getLogger(WaarpSslUtility.class);</span>

  /**
   * EventExecutor associated with Ssl utility
   */
<span class="fc" id="L55">  private static final EventExecutor SSL_EVENT_EXECUTOR =</span>
      new DefaultEventExecutor(new WaarpThreadFactory(&quot;SSLEVENT&quot;));
  /**
   * ChannelGroup for SSL
   */
<span class="fc" id="L60">  private static final ChannelGroup sslChannelGroup =</span>
      new DefaultChannelGroup(&quot;SslChannelGroup&quot;, SSL_EVENT_EXECUTOR);

  /**
   * Closing channel with SSL close at first step
   */
<span class="fc" id="L66">  public static final ChannelFutureListener SSLCLOSE =</span>
<span class="fc" id="L67">      new ChannelFutureListener() {</span>

        @Override
        public void operationComplete(final ChannelFuture future)
            throws Exception {
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">          if (future.channel().isActive()) {</span>
<span class="fc" id="L73">            final SSLTHREAD thread = new SSLTHREAD(future.channel());</span>
<span class="fc" id="L74">            thread.start();</span>
          }
<span class="fc" id="L76">        }</span>
      };

  private WaarpSslUtility() {
  }

  /**
   * Add the Channel as SSL handshake will start soon
   *
   * @param channel
   */
  public static void addSslOpenedChannel(final Channel channel) {
<span class="fc" id="L88">    sslChannelGroup.add(channel);</span>
<span class="fc" id="L89">  }</span>

  /**
   * Add a SslHandler in a pipeline when the channel is already active
   *
   * @param future might be null, condition to start to add the
   *     handler to
   *     the pipeline
   * @param pipeline
   * @param sslHandler
   * @param listener action once the handshake is done
   */
  @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
  public static void addSslHandler(final ChannelFuture future,
                                   final ChannelPipeline pipeline,
                                   final ChannelHandler sslHandler,
                                   final GenericFutureListener&lt;? extends Future&lt;? super Channel&gt;&gt; listener) {
<span class="nc bnc" id="L106" title="All 2 branches missed.">    if (future == null) {</span>
<span class="nc" id="L107">      logger.debug(&quot;Add SslHandler: &quot; + pipeline.channel());</span>
<span class="nc" id="L108">      pipeline.addFirst(&quot;SSL&quot;, sslHandler);</span>
<span class="nc" id="L109">      ((SslHandler) sslHandler).handshakeFuture().addListener(listener);</span>
    } else {
<span class="nc" id="L111">      future.addListener(new GenericFutureListener() {</span>
        @Override
        public void operationComplete(final Future future) throws Exception {
<span class="nc" id="L114">          logger.debug(&quot;Add SslHandler: &quot; + pipeline.channel());</span>
<span class="nc" id="L115">          pipeline.addFirst(&quot;SSL&quot;, sslHandler);</span>
<span class="nc" id="L116">          ((SslHandler) sslHandler).handshakeFuture().addListener(listener);</span>
<span class="nc" id="L117">        }</span>
      });
    }
<span class="nc" id="L120">    logger.debug(&quot;Checked Ssl Handler to be added: &quot; + pipeline.channel());</span>
<span class="nc" id="L121">  }</span>

  /**
   * Wait for the handshake on the given channel (better to use addSslHandler
   * when handler is added after
   * channel is active)
   *
   * @param channel
   *
   * @return True if the Handshake is done correctly
   */
  public static boolean waitForHandshake(final Channel channel) {
<span class="fc" id="L133">    final ChannelHandler handler = channel.pipeline().first();</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    if (handler instanceof SslHandler) {</span>
<span class="fc" id="L135">      logger.debug(&quot;Start handshake SSL: &quot; + channel);</span>
<span class="fc" id="L136">      final SslHandler sslHandler = (SslHandler) handler;</span>
      // Get the SslHandler and begin handshake ASAP.
      // Get notified when SSL handshake is done.
<span class="fc" id="L139">      final Future&lt;Channel&gt; handshakeFuture = sslHandler.handshakeFuture();</span>
<span class="fc" id="L140">      WaarpNettyUtil.awaitOrInterrupted(handshakeFuture,</span>
<span class="fc" id="L141">                                        sslHandler.getHandshakeTimeoutMillis() +</span>
                                        100);
<span class="fc" id="L143">      logger.debug(&quot;Handshake: &quot; + handshakeFuture.isSuccess() + &quot;: &quot; + channel,</span>
<span class="fc" id="L144">                   handshakeFuture.cause());</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if (!handshakeFuture.isSuccess()) {</span>
<span class="nc" id="L146">        channel.close();</span>
<span class="nc" id="L147">        return false;</span>
      }
<span class="fc" id="L149">    } else {</span>
<span class="nc" id="L150">      logger.info(&quot;SSL Not found but connected: {} {}&quot;,</span>
<span class="nc" id="L151">                  handler.getClass().getName());</span>
    }
<span class="fc" id="L153">    return true;</span>
  }

  /**
   * Waiting for the channel to be opened and ready (Client side) (blocking
   * call)
   *
   * @param future a future on connect only
   *
   * @return the channel if correctly associated, else return null
   */
  public static Channel waitforChannelReady(final ChannelFuture future) {
    // Wait until the connection attempt succeeds or fails.
<span class="fc" id="L166">    WaarpNettyUtil.awaitOrInterrupted(future);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (!future.isSuccess()) {</span>
<span class="nc" id="L168">      logger.error(&quot;Channel not connected&quot;, future.cause());</span>
<span class="nc" id="L169">      return null;</span>
    }
<span class="fc" id="L171">    final Channel channel = future.channel();</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    if (waitForHandshake(channel)) {</span>
<span class="fc" id="L173">      return channel;</span>
    }
<span class="nc" id="L175">    return null;</span>
  }

  /**
   * Utility to force all channels to be closed
   */
  public static void forceCloseAllSslChannels() {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (SSL_EVENT_EXECUTOR.isShutdown()) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">      for (final Channel channel : sslChannelGroup) {</span>
<span class="nc" id="L184">        closingSslChannel(channel);</span>
<span class="nc" id="L185">      }</span>
<span class="nc" id="L186">      WaarpNettyUtil.awaitOrInterrupted(sslChannelGroup.close());</span>
<span class="nc" id="L187">      SSL_EVENT_EXECUTOR.shutdownGracefully();</span>
    }
<span class="fc" id="L189">  }</span>

  /**
   * Utility method to close a channel in SSL mode correctly (if any)
   *
   * @param channel
   */
  public static ChannelFuture closingSslChannel(final Channel channel) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (channel.isActive()) {</span>
<span class="fc" id="L198">      removingSslHandler(null, channel, true);</span>
<span class="fc" id="L199">      logger</span>
<span class="fc" id="L200">          .debug(&quot;Close the channel and returns the ChannelFuture: &quot; + channel);</span>
<span class="fc" id="L201">      return channel.closeFuture();</span>
    }
<span class="fc" id="L203">    logger.debug(&quot;Already closed&quot;);</span>
<span class="fc" id="L204">    return channel.newSucceededFuture();</span>
  }

  /**
   * Remove the SslHandler (if any) cleanly
   *
   * @param future if not null, wait for this future to be done to
   *     removed
   *     the sslhandler
   * @param channel
   * @param close True to close the channel, else to only remove it
   */
  @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
  public static void removingSslHandler(final ChannelFuture future,
                                        final Channel channel,
                                        final boolean close) {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (channel.isActive()) {</span>
<span class="fc" id="L221">      channel.config().setAutoRead(true);</span>
<span class="fc" id="L222">      final ChannelHandler handler = channel.pipeline().first();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      if (handler instanceof SslHandler) {</span>
<span class="fc" id="L224">        final SslHandler sslHandler = (SslHandler) handler;</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="nc" id="L226">          future.addListener(new GenericFutureListener() {</span>
            @Override
            public void operationComplete(final Future future)
                throws Exception {
<span class="nc" id="L230">              logger.debug(&quot;Found SslHandler and wait for Ssl.close()&quot;);</span>
<span class="nc" id="L231">              final ChannelHandlerContext cht =</span>
<span class="nc" id="L232">                  channel.pipeline().context(sslHandler);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">              if (cht.channel().isActive()) {</span>
<span class="nc" id="L234">                cht.close().addListener(</span>
<span class="nc" id="L235">                    new GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;() {</span>
                      @Override
                      public void operationComplete(
                          final Future&lt;? super Void&gt; future) throws Exception {
<span class="nc" id="L239">                        logger.debug(&quot;Ssl closed&quot;);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                        if (!close) {</span>
<span class="nc" id="L241">                          channel.pipeline().remove(sslHandler);</span>
                        } else {
<span class="nc bnc" id="L243" title="All 2 branches missed.">                          if (channel.isActive()) {</span>
<span class="nc" id="L244">                            channel.close();</span>
                          }
                        }
<span class="nc" id="L247">                      }</span>
                    });
              }
<span class="nc" id="L250">            }</span>
          });
        } else {
<span class="fc" id="L253">          logger</span>
<span class="fc" id="L254">              .debug(&quot;Found SslHandler and wait for Ssl.close() : &quot; + channel);</span>
<span class="fc" id="L255">          final ChannelHandlerContext cht =</span>
<span class="fc" id="L256">              channel.pipeline().context(sslHandler);</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">          if (cht.channel().isActive()) {</span>
<span class="fc" id="L258">            cht.close()</span>
<span class="fc" id="L259">               .addListener(new GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;() {</span>
                 @Override
                 public void operationComplete(
                     final Future&lt;? super Void&gt; future) throws Exception {
<span class="fc" id="L263">                   logger.debug(&quot;Ssl closed: &quot; + channel);</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                   if (!close) {</span>
<span class="nc" id="L265">                     channel.pipeline().remove(sslHandler);</span>
                   } else {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">                     if (channel.isActive()) {</span>
<span class="nc" id="L268">                       channel.close();</span>
                     }
                   }
<span class="fc" id="L271">                 }</span>
               });
          }
        }
<span class="fc" id="L275">      } else {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (channel.isActive()) {</span>
<span class="nc" id="L277">          channel.close();</span>
        }
      }
    }
<span class="fc" id="L281">  }</span>

  /**
   * Wait for the channel with SSL to be closed
   *
   * @param channel
   * @param delay
   *
   * @return True if an error occurs as an interruption
   */
  public static boolean waitForClosingSslChannel(final Channel channel,
                                                 final long delay) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">    if (!WaarpNettyUtil.awaitOrInterrupted(channel.closeFuture(), delay)) {</span>
      try {
<span class="nc" id="L295">        channel.pipeline().remove(WaarpSslHandler.class);</span>
<span class="nc" id="L296">        logger.debug(&quot;try to close anyway&quot;);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (channel.isActive()) {</span>
<span class="nc" id="L298">          WaarpNettyUtil.awaitOrInterrupted(channel.close(), delay);</span>
        }
<span class="nc" id="L300">        return false;</span>
<span class="nc" id="L301">      } catch (final NoSuchElementException e) {</span>
        // ignore
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (channel.isActive()) {</span>
<span class="nc" id="L304">          WaarpNettyUtil.awaitOrInterrupted(channel.closeFuture(), delay);</span>
        }
      }
    }
<span class="fc" id="L308">    return true;</span>
  }

  /**
   * Thread used to ensure we are not in IO thread when waiting
   */
  private static class SSLTHREAD extends Thread {
    private final Channel channel;

    /**
     * @param channel
     */
<span class="fc" id="L320">    private SSLTHREAD(final Channel channel) {</span>
<span class="fc" id="L321">      this.channel = channel;</span>
<span class="fc" id="L322">      setDaemon(true);</span>
<span class="fc" id="L323">      setName(&quot;SSLTHREAD_&quot; + getName());</span>
<span class="fc" id="L324">    }</span>

    @Override
    public void run() {
<span class="fc" id="L328">      closingSslChannel(channel);</span>
<span class="fc" id="L329">    }</span>

  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>