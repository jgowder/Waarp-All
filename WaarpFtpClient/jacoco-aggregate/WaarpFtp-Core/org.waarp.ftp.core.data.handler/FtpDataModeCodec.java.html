<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FtpDataModeCodec.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp R66 client</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.data.handler</a> &gt; <span class="el_source">FtpDataModeCodec.java</span></div><h1>FtpDataModeCodec.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.data.handler;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageCodec;
import org.waarp.common.exception.InvalidArgumentException;
import org.waarp.common.file.DataBlock;
import org.waarp.common.future.WaarpFuture;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferMode;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferStructure;
import org.waarp.ftp.core.data.handler.FtpSeekAheadData.SeekAheadNoBackArrayException;

import java.util.List;

/**
 * First CODEC :&lt;br&gt;
 * - encode : takes a {@link DataBlock} and transforms it to a ByteBuf&lt;br&gt;
 * - decode : takes a ByteBuf and transforms it to a {@link DataBlock}&lt;br&gt;
 * STREAM and BLOCK mode are implemented. COMPRESSED mode is not implemented.
 */
public class FtpDataModeCodec extends ByteToMessageCodec&lt;DataBlock&gt; {
  /*
   * 3.4.1. STREAM MODE The data is transmitted as a stream of bytes. There is no restriction on the
   * representation type used; record structures are allowed. In a record structured file EOR and EOF will each
   * be indicated by a two-byte control code. The first byte of the control code will be all ones, the escape
   * character. The second byte will have the low order bit on and zeros elsewhere for EOR and the second low
   * order bit on for EOF; that is, the byte will have value 1 for EOR and value 2 for EOF. EOR and EOF may be
   * indicated together on the last byte transmitted by turning both low order bits on (i.e., the value 3). If a
   * byte of all ones was intended to be sent as data, it should be repeated in the second byte of the control
   * code. If the structure is a file structure, the EOF is indicated by the sending host closing the data
   * connection and all bytes are data bytes. 3.4.2. BLOCK MODE The file is transmitted as a series of data
   * blocks preceded by one or more header bytes. The header bytes contain a count field, and descriptor code.
   * The count field indicates the total length of the data block in bytes, thus marking the beginning of the
   * next data block (there are no filler bits). The descriptor code defines: last block in the file (EOF) last
   * block in the record (EOR), restart marker (see the Section on Error Recovery and Restart) or suspect data
   * (i.e., the data being transferred is suspected of errors and is not reliable). This last code is NOT
   * intended for error control within FTP. It is motivated by the desire of sites exchanging certain types of
   * data (e.g., seismic or weather data) to send and receive all the data despite local errors (such as
   * &quot;magnetic tape read errors&quot;), but to indicate in the transmission that certain portions are suspect).
   * Record structures are allowed in this mode, and any representation type may be used. The header consists of
   * the three bytes. Of the 24 bits of header information, the 16 low order bits shall represent byte count,
   * and the 8 high order bits shall represent descriptor codes as shown below. Block Header
   * +----------------+----------------+----------------+ | Descriptor | Byte Count | | 8 bits | 16 bits |
   * +----------------+----------------+----------------+ The descriptor codes are indicated by bit flags in the
   * descriptor byte. Four codes have been assigned, where each code number is the decimal value of the
   * corresponding bit in the byte. Code Meaning 128 End of data block is EOR 64 End of data block is EOF 32
   * Suspected errors in data block 16 Data block is a restart marker With this encoding, more than one
   * descriptor coded condition may exist for a particular block. As many bits as necessary may be flagged. The
   * restart marker is embedded in the data stream as an integral number of 8-bit bytes representing printable
   * characters in the language being used over the control connection (e.g., default--NVT-ASCII). &lt;SP&gt; (Space,
   * in the appropriate language) must not be used WITHIN a restart marker. For example, to transmit a
   * six-character marker, the following would be sent: +--------+--------+--------+ |Descrptr| Byte count |
   * |code= 16| = 6 | +--------+--------+--------+ +--------+--------+--------+ | Marker | Marker | Marker | | 8
   * bits | 8 bits | 8 bits | +--------+--------+--------+ +--------+--------+--------+ | Marker | Marker |
   * Marker | | 8 bits | 8 bits | 8 bits | +--------+--------+--------+
   */
  /**
   * Transfer Mode
   */
  private TransferMode mode;

  /**
   * Structure Mode
   */
  private TransferStructure structure;

  /**
   * Ftp Data Block
   */
  private DataBlock dataBlock;

  /**
   * Last byte for STREAM+RECORD
   */
  private int lastbyte;

  /**
   * Is the underlying DataNetworkHandler ready to receive block
   */
  private volatile boolean isReady;

  /**
   * Blocking step between DataNetworkHandler and this Codec in order to wait
   * that the DataNetworkHandler is
   * ready
   */
<span class="fc" id="L108">  private final WaarpFuture codecLocked = new WaarpFuture();</span>

  /**
   * @param mode
   * @param structure
   */
<span class="fc" id="L114">  public FtpDataModeCodec(TransferMode mode, TransferStructure structure) {</span>
<span class="fc" id="L115">    this.mode = mode;</span>
<span class="fc" id="L116">    this.structure = structure;</span>
<span class="fc" id="L117">  }</span>

  /**
   * Inform the Codec that DataNetworkHandler is ready (called from
   * DataNetworkHandler after setCorrectCodec).
   */
  public void setCodecReady() {
<span class="fc" id="L124">    codecLocked.setSuccess();</span>
<span class="fc" id="L125">  }</span>

  protected DataBlock decodeRecordStandard(ByteBuf buf, int length) {
<span class="nc" id="L128">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(length);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (lastbyte == 0xFF) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">      if (readByteForDataBlock(buf, newbuf)) {</span>
<span class="nc" id="L131">        lastbyte = 0;</span>
      }
    }
    try {
      while (true) { //NOSONAR
<span class="nc" id="L136">        lastbyte = buf.readByte();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (lastbyte == 0xFF) {</span>
<span class="nc" id="L138">          readByteForDataBlock(buf, newbuf);</span>
        } else {
<span class="nc" id="L140">          newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
        }
<span class="nc" id="L142">        lastbyte = 0;</span>
      }
<span class="nc" id="L144">    } catch (final IndexOutOfBoundsException e) {</span>
      // End of read
    }
<span class="nc" id="L147">    dataBlock.setBlock(newbuf);</span>
<span class="nc" id="L148">    return dataBlock;</span>
  }

  private boolean readByteForDataBlock(final ByteBuf buf,
                                       final ByteBuf newbuf) {
<span class="nc" id="L153">    final int nextbyte = buf.readByte();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    if (nextbyte == 0xFF) {</span>
<span class="nc" id="L155">      newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
<span class="nc" id="L156">      return false;</span>
    } else {
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (nextbyte == 1) {</span>
<span class="nc" id="L159">        dataBlock.setEOR(true);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">      } else if (nextbyte == 2) {</span>
<span class="nc" id="L161">        dataBlock.setEOF(true);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">      } else if (nextbyte == 3) {</span>
<span class="nc" id="L163">        dataBlock.setEOR(true);</span>
<span class="nc" id="L164">        dataBlock.setEOF(true);</span>
      }
<span class="nc" id="L166">      return true;</span>
    }
  }

  protected DataBlock decodeRecord(ByteBuf buf, int length) {
    FtpSeekAheadData sad;
    try {
<span class="nc" id="L173">      sad = new FtpSeekAheadData(buf);</span>
<span class="nc" id="L174">    } catch (final SeekAheadNoBackArrayException e1) {</span>
<span class="nc" id="L175">      return decodeRecordStandard(buf, length);</span>
<span class="nc" id="L176">    }</span>
<span class="nc" id="L177">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(length);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if (lastbyte == 0xFF) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (readBytesFromSad(sad, newbuf)) {</span>
<span class="nc" id="L180">        lastbyte = 0;</span>
      }
    }
    try {
<span class="nc bnc" id="L184" title="All 2 branches missed.">      while (sad.pos &lt; sad.limit) {</span>
<span class="nc" id="L185">        lastbyte = sad.bytes[sad.pos++];</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (lastbyte == 0xFF) {</span>
<span class="nc" id="L187">          readBytesFromSad(sad, newbuf);</span>
        } else {
<span class="nc" id="L189">          newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
        }
<span class="nc" id="L191">        lastbyte = 0;</span>
      }
<span class="nc" id="L193">    } catch (final IndexOutOfBoundsException e) {</span>
      // End of read
<span class="nc" id="L195">    }</span>
<span class="nc" id="L196">    sad.setReadPosition(0);</span>
<span class="nc" id="L197">    dataBlock.setBlock(newbuf);</span>
<span class="nc" id="L198">    return dataBlock;</span>
  }

  private boolean readBytesFromSad(final FtpSeekAheadData sad,
                                   final ByteBuf newbuf) {
<span class="nc" id="L203">    final int nextbyte = sad.bytes[sad.pos++];</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (nextbyte == 0xFF) {</span>
<span class="nc" id="L205">      newbuf.writeByte((byte) (lastbyte &amp; 0xFF));</span>
<span class="nc" id="L206">      return false;</span>
    } else {
<span class="nc bnc" id="L208" title="All 2 branches missed.">      if (nextbyte == 1) {</span>
<span class="nc" id="L209">        dataBlock.setEOR(true);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">      } else if (nextbyte == 2) {</span>
<span class="nc" id="L211">        dataBlock.setEOF(true);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">      } else if (nextbyte == 3) {</span>
<span class="nc" id="L213">        dataBlock.setEOR(true);</span>
<span class="nc" id="L214">        dataBlock.setEOF(true);</span>
      }
<span class="nc" id="L216">      return true;</span>
    }
  }

  @Override
  protected void decode(ChannelHandlerContext ctx, ByteBuf buf,
                        List&lt;Object&gt; out) throws Exception {
    // First test if the connection is fully ready (block might be
    // transfered
    // by client before connection is ready)
<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (!isReady) {</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">      if (!codecLocked.awaitOrInterruptible()) {</span>
<span class="nc" id="L228">        throw new InvalidArgumentException(</span>
            &quot;Codec not unlocked while should be&quot;);
      }
<span class="fc" id="L231">      isReady = true;</span>
    }
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    if (buf.readableBytes() == 0) {</span>
<span class="nc" id="L234">      return;</span>
    }
    // If STREAM Mode, no task to do, just next filter
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (mode == TransferMode.STREAM) {</span>
<span class="fc" id="L238">      dataBlock = new DataBlock();</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      if (structure != TransferStructure.RECORD) {</span>
<span class="fc" id="L240">        final ByteBuf newbuf = Unpooled.wrappedBuffer(buf);</span>
<span class="fc" id="L241">        buf.readerIndex(buf.readableBytes());</span>
<span class="fc" id="L242">        newbuf.retain();</span>
<span class="fc" id="L243">        dataBlock.setBlock(newbuf);</span>
<span class="fc" id="L244">        out.add(dataBlock);</span>
<span class="fc" id="L245">        return;</span>
      }
      // Except if RECORD Structure!
<span class="nc" id="L248">      final int length = buf.readableBytes();</span>
<span class="nc" id="L249">      out.add(decodeRecord(buf, length));</span>
<span class="nc" id="L250">      return;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    } else if (mode == TransferMode.BLOCK) {</span>
      // Now we are in BLOCK Mode
      // Make sure if the length field was received.
<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (buf.readableBytes() &lt; 3) {</span>
        // The length field was not received yet - return null.
        // This method will be invoked again when more packets are
        // received and appended to the buffer.
<span class="nc" id="L258">        return;</span>
      }

      // The length field is in the buffer.

      // Mark the current buffer position before reading the length field
      // because the whole frame might not be in the buffer yet.
      // We will reset the buffer position to the marked position if
      // there's not enough bytes in the buffer.
<span class="nc" id="L267">      buf.markReaderIndex();</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (dataBlock == null) {</span>
<span class="nc" id="L270">        dataBlock = new DataBlock();</span>
      }
      // Read the descriptor
<span class="nc" id="L273">      dataBlock.setDescriptor(buf.readByte());</span>

      // Read the length field.
<span class="nc" id="L276">      final byte upper = buf.readByte();</span>
<span class="nc" id="L277">      final byte lower = buf.readByte();</span>
<span class="nc" id="L278">      dataBlock.setByteCount(upper, lower);</span>

      // Make sure if there's enough bytes in the buffer.
<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (buf.readableBytes() &lt; dataBlock.getByteCount()) {</span>
        // The whole bytes were not received yet - return null.
        // This method will be invoked again when more packets are
        // received and appended to the buffer.

        // Reset to the marked position to read the length field again
        // next time.
<span class="nc" id="L288">        buf.resetReaderIndex();</span>

<span class="nc" id="L290">        return;</span>
      }
<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (dataBlock.getByteCount() &gt; 0) {</span>
        // There's enough bytes in the buffer. Read it.
<span class="nc" id="L294">        dataBlock.setBlock(buf.readBytes(dataBlock.getByteCount()));</span>
      }
<span class="nc" id="L296">      final DataBlock returnDataBlock = dataBlock;</span>
      // Free the datablock for next frame
<span class="nc" id="L298">      dataBlock = null;</span>
      // Successfully decoded a frame. Return the decoded frame.
<span class="nc" id="L300">      out.add(returnDataBlock);</span>
<span class="nc" id="L301">      return;</span>
    }
    // Type unimplemented
<span class="nc" id="L304">    throw new InvalidArgumentException(&quot;Mode unimplemented: &quot; + mode.name());</span>
  }

  protected ByteBuf encodeRecordStandard(DataBlock msg, ByteBuf buffer) {
<span class="nc" id="L308">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(msg.getByteCount());</span>
    int newbyte;
    try {
      while (true) { //NOSONAR
<span class="nc" id="L312">        newbyte = buffer.readByte();</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (newbyte == 0xFF) {</span>
<span class="nc" id="L314">          newbuf.writeByte((byte) 0xFF);</span>
        }
<span class="nc" id="L316">        newbuf.writeByte((byte) (newbyte &amp; 0xFF));</span>
      }
<span class="nc" id="L318">    } catch (final IndexOutOfBoundsException e) {</span>
      // end of read
    }
<span class="nc" id="L321">    int value = 0;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">    if (msg.isEOF()) {</span>
<span class="nc" id="L323">      value += 2;</span>
    }
<span class="nc bnc" id="L325" title="All 2 branches missed.">    if (msg.isEOR()) {</span>
<span class="nc" id="L326">      value += 1;</span>
    }
<span class="nc bnc" id="L328" title="All 2 branches missed.">    if (value &gt; 0) {</span>
<span class="nc" id="L329">      newbuf.writeByte((byte) 0xFF);</span>
<span class="nc" id="L330">      newbuf.writeByte((byte) (value &amp; 0xFF));</span>
    }
<span class="nc" id="L332">    msg.clear();</span>
<span class="nc" id="L333">    return newbuf;</span>
  }

  protected ByteBuf encodeRecord(DataBlock msg, ByteBuf buffer) {
    FtpSeekAheadData sad;
    try {
<span class="nc" id="L339">      sad = new FtpSeekAheadData(buffer);</span>
<span class="nc" id="L340">    } catch (final SeekAheadNoBackArrayException e1) {</span>
<span class="nc" id="L341">      return encodeRecordStandard(msg, buffer);</span>
<span class="nc" id="L342">    }</span>
<span class="nc" id="L343">    final ByteBuf newbuf = ByteBufAllocator.DEFAULT.buffer(msg.getByteCount());</span>
    int newbyte;
    try {
<span class="nc bnc" id="L346" title="All 2 branches missed.">      while (sad.pos &lt; sad.limit) {</span>
<span class="nc" id="L347">        newbyte = sad.bytes[sad.pos++];</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (newbyte == 0xFF) {</span>
<span class="nc" id="L349">          newbuf.writeByte((byte) 0xFF);</span>
        }
<span class="nc" id="L351">        newbuf.writeByte((byte) (newbyte &amp; 0xFF));</span>
      }
<span class="nc" id="L353">    } catch (final IndexOutOfBoundsException e) {</span>
      // end of read
<span class="nc" id="L355">    }</span>
<span class="nc" id="L356">    int value = 0;</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (msg.isEOF()) {</span>
<span class="nc" id="L358">      value += 2;</span>
    }
<span class="nc bnc" id="L360" title="All 2 branches missed.">    if (msg.isEOR()) {</span>
<span class="nc" id="L361">      value += 1;</span>
    }
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (value &gt; 0) {</span>
<span class="nc" id="L364">      newbuf.writeByte((byte) 0xFF);</span>
<span class="nc" id="L365">      newbuf.writeByte((byte) (value &amp; 0xFF));</span>
    }
<span class="nc" id="L367">    msg.clear();</span>
<span class="nc" id="L368">    sad.setReadPosition(0);</span>
<span class="nc" id="L369">    return newbuf;</span>
  }

  /**
   * Encode a DataBlock in the correct format for Mode
   *
   * @param msg
   *
   * @return the ByteBuf or null when the last block is already done
   *
   * @throws InvalidArgumentException
   */
  protected ByteBuf encode(DataBlock msg) throws InvalidArgumentException {
<span class="fc bfc" id="L382" title="All 2 branches covered.">    if (msg.isCleared()) {</span>
<span class="fc" id="L383">      return null;</span>
    }
<span class="fc" id="L385">    final ByteBuf buffer = msg.getBlock();</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">    if (mode == TransferMode.STREAM) {</span>
      // If record structure, special attention
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">      if (structure == TransferStructure.RECORD) {</span>
<span class="nc" id="L389">        return encodeRecord(msg, buffer);</span>
      }
<span class="fc" id="L391">      msg.clear();</span>
<span class="fc" id="L392">      return buffer;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">    } else if (mode == TransferMode.BLOCK) {</span>
<span class="nc" id="L394">      int length = msg.getByteCount();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">      final ByteBuf newbuf = ByteBufAllocator.DEFAULT</span>
<span class="nc" id="L396">          .buffer(length &gt; 0xFFFF? 0xFFFF + 3 : length + 3);</span>
<span class="nc" id="L397">      final byte[] header = new byte[3];</span>
      // Is there any data left
<span class="nc bnc" id="L399" title="All 2 branches missed.">      if (length == 0) {</span>
        // It could be an empty block for EOR or EOF
<span class="nc bnc" id="L401" title="All 4 branches missed.">        if (msg.isEOF() || msg.isEOR()) {</span>
<span class="nc" id="L402">          header[0] = msg.getDescriptor();</span>
<span class="nc" id="L403">          header[1] = 0;</span>
<span class="nc" id="L404">          header[2] = 0;</span>
<span class="nc" id="L405">          newbuf.writeBytes(header);</span>
          // Next call will be the last one
<span class="nc" id="L407">          msg.clear();</span>
          // return the last block
<span class="nc" id="L409">          return newbuf;</span>
        }
        // This was the very last call
<span class="nc" id="L412">        msg.clear();</span>
        // return the end of encode
<span class="nc" id="L414">        return null;</span>
      }
      // Is this a Restart so only Markers
<span class="nc bnc" id="L417" title="All 2 branches missed.">      if (msg.isRESTART()) {</span>
<span class="nc" id="L418">        header[0] = msg.getDescriptor();</span>
<span class="nc" id="L419">        header[1] = msg.getByteCountUpper();</span>
<span class="nc" id="L420">        header[2] = msg.getByteCountLower();</span>
<span class="nc" id="L421">        newbuf.writeBytes(header);</span>
<span class="nc" id="L422">        newbuf.writeBytes(msg.getByteMarkers());</span>
        // Next call will be the last one
<span class="nc" id="L424">        msg.clear();</span>
        // return the last block
<span class="nc" id="L426">        return newbuf;</span>
      }
      // Work on sub block, ignoring descriptor since it is not the last
      // one
<span class="nc bnc" id="L430" title="All 2 branches missed.">      if (length &gt; 0xFFFF) {</span>
<span class="nc" id="L431">        header[0] = 0;</span>
<span class="nc" id="L432">        header[1] = (byte) 0xFF;</span>
<span class="nc" id="L433">        header[2] = (byte) 0xFF;</span>
<span class="nc" id="L434">        newbuf.writeBytes(header);</span>
        // Now take the first 0xFFFF bytes from buffer
<span class="nc" id="L436">        newbuf.writeBytes(msg.getBlock(), 0xFFFF);</span>
<span class="nc" id="L437">        length -= 0xFFFF;</span>
<span class="nc" id="L438">        msg.setByteCount(length);</span>
        // return the sub block
<span class="nc" id="L440">        return newbuf;</span>
      }
      // Last final block, using the descriptor
<span class="nc" id="L443">      header[0] = msg.getDescriptor();</span>
<span class="nc" id="L444">      header[1] = msg.getByteCountUpper();</span>
<span class="nc" id="L445">      header[2] = msg.getByteCountLower();</span>
<span class="nc" id="L446">      newbuf.writeBytes(header);</span>
      // real data
<span class="nc" id="L448">      newbuf.writeBytes(buffer, length);</span>
      // Next call will be the last one
<span class="nc" id="L450">      msg.clear();</span>
      // return the last block
<span class="nc" id="L452">      return newbuf;</span>
    }
    // Mode unimplemented
<span class="nc" id="L455">    throw new InvalidArgumentException(&quot;Mode unimplemented: &quot; + mode.name());</span>
  }

  /**
   * @return the mode
   */
  public TransferMode getMode() {
<span class="nc" id="L462">    return mode;</span>
  }

  /**
   * @param mode the mode to set
   */
  public void setMode(TransferMode mode) {
<span class="fc" id="L469">    this.mode = mode;</span>
<span class="fc" id="L470">  }</span>

  /**
   * @return the structure
   */
  public TransferStructure getStructure() {
<span class="nc" id="L476">    return structure;</span>
  }

  /**
   * @param structure the structure to set
   */
  public void setStructure(TransferStructure structure) {
<span class="fc" id="L483">    this.structure = structure;</span>
<span class="fc" id="L484">  }</span>

  @Override
  protected void encode(ChannelHandlerContext ctx, DataBlock msg, ByteBuf out)
      throws Exception {
    // First test if the connection is fully ready (block might be
    // transfered
    // by client before connection is ready)
<span class="fc bfc" id="L492" title="All 2 branches covered.">    if (!isReady) {</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">      if (!codecLocked.awaitOrInterruptible()) {</span>
<span class="nc" id="L494">        throw new InvalidArgumentException(</span>
            &quot;Codec not unlocked while should be&quot;);
      }
<span class="fc" id="L497">      isReady = true;</span>
    }
<span class="fc" id="L499">    ByteBuf next = encode(msg);</span>
    // Could be splitten in several block
<span class="fc bfc" id="L501" title="All 2 branches covered.">    while (next != null) {</span>
<span class="fc" id="L502">      out.writeBytes(next);</span>
<span class="fc" id="L503">      next = encode(msg);</span>
    }
<span class="fc" id="L505">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>