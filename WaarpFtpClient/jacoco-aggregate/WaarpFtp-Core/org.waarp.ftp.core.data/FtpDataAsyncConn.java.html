<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FtpDataAsyncConn.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Ftp R66 client</a> &gt; <a href="../index.html" class="el_bundle">WaarpFtp-Core</a> &gt; <a href="index.source.html" class="el_package">org.waarp.ftp.core.data</a> &gt; <span class="el_source">FtpDataAsyncConn.java</span></div><h1>FtpDataAsyncConn.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.ftp.core.data;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import org.waarp.common.command.exception.Reply425Exception;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpNettyUtil;
import org.waarp.ftp.core.command.FtpArgumentCode;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferMode;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferStructure;
import org.waarp.ftp.core.command.FtpArgumentCode.TransferType;
import org.waarp.ftp.core.config.FtpConfiguration;
import org.waarp.ftp.core.config.FtpInternalConfiguration;
import org.waarp.ftp.core.data.handler.DataNetworkHandler;
import org.waarp.ftp.core.exception.FtpNoConnectionException;
import org.waarp.ftp.core.session.FtpSession;
import org.waarp.ftp.core.utils.FtpChannelUtils;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Main class that handles Data connection using asynchronous connection with
 * Netty
 */
public class FtpDataAsyncConn {
  /**
   * Internal Logger
   */
<span class="fc" id="L53">  private static final WaarpLogger logger =</span>
<span class="fc" id="L54">      WaarpLoggerFactory.getLogger(FtpDataAsyncConn.class);</span>
  /**
   * SessionInterface
   */
  private final FtpSession session;

  /**
   * Current Data Network Handler
   */
  private DataNetworkHandler dataNetworkHandler;

  /**
   * Data Channel with the client
   */
  private Channel dataChannel;

  /**
   * External address of the client (active)
   */
  private InetSocketAddress remoteAddress;

  /**
   * Local listening address for the server (passive)
   */
  private InetSocketAddress localAddress;

  /**
   * Active: the connection is done from the Server to the Client on this
   * remotePort Passive: not used
   */
<span class="fc" id="L84">  private int remotePort = -1;</span>

  /**
   * Active: the connection is done from the Server from this localPort to the
   * Client Passive: the connection is
   * done from the Client to the Server on this localPort
   */
<span class="fc" id="L91">  private int localPort = -1;</span>

  /**
   * Is the connection passive
   */
<span class="fc" id="L96">  private final AtomicBoolean passiveMode = new AtomicBoolean(false);</span>

  /**
   * Is the server binded (active or passive, but mainly passive)
   */
<span class="fc" id="L101">  private final AtomicBoolean isBind = new AtomicBoolean(false);</span>

  /**
   * The FtpTransferControl
   */
  private final FtpTransferControl transferControl;

  /**
   * Current TransferType. Default ASCII
   */
<span class="fc" id="L111">  private FtpArgumentCode.TransferType transferType =</span>
      FtpArgumentCode.TransferType.ASCII;

  /**
   * Current TransferSubType. Default NONPRINT
   */
<span class="fc" id="L117">  private FtpArgumentCode.TransferSubType transferSubType =</span>
      FtpArgumentCode.TransferSubType.NONPRINT;

  /**
   * Current TransferStructure. Default FILE
   */
<span class="fc" id="L123">  private FtpArgumentCode.TransferStructure transferStructure =</span>
      FtpArgumentCode.TransferStructure.FILE;

  /**
   * Current TransferMode. Default Stream
   */
<span class="fc" id="L129">  private FtpArgumentCode.TransferMode transferMode =</span>
      FtpArgumentCode.TransferMode.STREAM;

  /**
   * Constructor for Active session by default
   *
   * @param session
   */
<span class="fc" id="L137">  public FtpDataAsyncConn(final FtpSession session) {</span>
<span class="fc" id="L138">    this.session = session;</span>
<span class="fc" id="L139">    dataChannel = null;</span>
<span class="fc" id="L140">    remoteAddress = FtpChannelUtils.getRemoteInetSocketAddress(</span>
<span class="fc" id="L141">        this.session.getControlChannel());</span>
<span class="fc" id="L142">    remotePort = remoteAddress.getPort();</span>
<span class="fc" id="L143">    setDefaultLocalPort();</span>
<span class="fc" id="L144">    resetLocalAddress();</span>
<span class="fc" id="L145">    passiveMode.set(false);</span>
<span class="fc" id="L146">    isBind.set(false);</span>
<span class="fc" id="L147">    transferControl = new FtpTransferControl(session);</span>
<span class="fc" id="L148">  }</span>

  /**
   * @param channel
   *
   * @return True if the given channel is the same as the one currently
   *     registered
   */
  public final boolean checkCorrectChannel(final Channel channel) {
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">    if (dataChannel == null || channel == null) {</span>
<span class="nc" id="L158">      return false;</span>
    }
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    return dataChannel.compareTo(channel) == 0;</span>
  }

  /**
   * Clear the Data Connection
   */
  public final synchronized void clear() {
<span class="fc" id="L167">    unbindData();</span>
<span class="fc" id="L168">    transferControl.clear();</span>
<span class="fc" id="L169">    passiveMode.set(false);</span>
<span class="fc" id="L170">    remotePort = -1;</span>
<span class="fc" id="L171">    localPort = -1;</span>
<span class="fc" id="L172">  }</span>

  /**
   * Set the local port to the default (0 meaning any available)
   */
  private void setDefaultLocalPort() {
<span class="fc" id="L178">    setLocalPort(0);</span>
<span class="fc" id="L179">  }</span>

  /**
   * Set the Local Port (Active or Passive)
   *
   * @param localPort
   */
  public final synchronized void setLocalPort(final int localPort) {
<span class="fc" id="L187">    this.localPort = localPort;</span>
<span class="fc" id="L188">  }</span>

  /**
   * @return the local address
   */
  public final InetSocketAddress getLocalAddress() {
<span class="fc" id="L194">    return localAddress;</span>
  }

  /**
   * @return the remote address
   */
  public final InetSocketAddress getRemoteAddress() {
<span class="fc" id="L201">    return remoteAddress;</span>
  }

  /**
   * @return the remotePort
   */
  public final int getRemotePort() {
<span class="fc" id="L208">    return remotePort;</span>
  }

  /**
   * @return the localPort
   */
  public final synchronized int getLocalPort() {
<span class="fc" id="L215">    return localPort;</span>
  }

  private synchronized void resetLocalAddress() {
<span class="fc" id="L219">    localAddress = new InetSocketAddress(</span>
<span class="fc" id="L220">        FtpChannelUtils.getLocalInetAddress(session.getControlChannel()),</span>
        localPort);
<span class="fc" id="L222">  }</span>

  /**
   * Change to active connection (reset localPort to default)
   *
   * @param address remote address
   */
  public final synchronized void setActive(final InetSocketAddress address) {
<span class="fc" id="L230">    unbindData();</span>
<span class="fc" id="L231">    setDefaultLocalPort();</span>
<span class="fc" id="L232">    resetLocalAddress();</span>
<span class="fc" id="L233">    remoteAddress = address;</span>
<span class="fc" id="L234">    passiveMode.set(false);</span>
<span class="fc" id="L235">    isBind.set(false);</span>
<span class="fc" id="L236">    remotePort = remoteAddress.getPort();</span>
<span class="fc" id="L237">    logger.debug(&quot;SetActive: {}&quot;, this);</span>
<span class="fc" id="L238">  }</span>

  /**
   * Change to passive connection (all necessaries informations like local
   * port
   * should have been set)
   */
  public final void setPassive() {
<span class="fc" id="L246">    unbindData();</span>
<span class="fc" id="L247">    resetLocalAddress();</span>
<span class="fc" id="L248">    passiveMode.set(true);</span>
<span class="fc" id="L249">    isBind.set(false);</span>
<span class="fc" id="L250">    logger.debug(&quot;SetPassive: {}&quot;, this);</span>
<span class="fc" id="L251">  }</span>

  /**
   * @return the passiveMode
   */
  public final boolean isPassiveMode() {
<span class="fc" id="L257">    return passiveMode.get();</span>
  }

  /**
   * @return True if the connection is bind (active = connected, passive = not
   *     necessarily connected)
   */
  public final boolean isBind() {
<span class="fc" id="L265">    return isBind.get();</span>
  }

  /**
   * Is the Data dataChannel connected
   *
   * @return True if the dataChannel is connected
   */
  public final synchronized boolean isActive() {
<span class="pc bpc" id="L274" title="3 of 4 branches missed.">    return dataChannel != null &amp;&amp; dataChannel.isActive();</span>
  }

  /**
   * @return the transferMode
   */
  public final synchronized FtpArgumentCode.TransferMode getMode() {
<span class="fc" id="L281">    return transferMode;</span>
  }

  /**
   * @param transferMode the transferMode to set
   */
  public final synchronized void setMode(
      final FtpArgumentCode.TransferMode transferMode) {
<span class="fc" id="L289">    this.transferMode = transferMode;</span>
<span class="fc" id="L290">    setCorrectCodec();</span>
<span class="fc" id="L291">  }</span>

  /**
   * @return the transferStructure
   */
  public final synchronized FtpArgumentCode.TransferStructure getStructure() {
<span class="fc" id="L297">    return transferStructure;</span>
  }

  /**
   * @param transferStructure the transferStructure to set
   */
  public final synchronized void setStructure(
      final FtpArgumentCode.TransferStructure transferStructure) {
<span class="fc" id="L305">    this.transferStructure = transferStructure;</span>
<span class="fc" id="L306">    setCorrectCodec();</span>
<span class="fc" id="L307">  }</span>

  /**
   * @return the transferSubType
   */
  public final synchronized FtpArgumentCode.TransferSubType getSubType() {
<span class="fc" id="L313">    return transferSubType;</span>
  }

  /**
   * @param transferSubType the transferSubType to set
   */
  public final synchronized void setSubType(
      final FtpArgumentCode.TransferSubType transferSubType) {
<span class="fc" id="L321">    this.transferSubType = transferSubType;</span>
<span class="fc" id="L322">    setCorrectCodec();</span>
<span class="fc" id="L323">  }</span>

  /**
   * @return the transferType
   */
  public final synchronized FtpArgumentCode.TransferType getType() {
<span class="fc" id="L329">    return transferType;</span>
  }

  /**
   * @param transferType the transferType to set
   */
  public final synchronized void setType(
      final FtpArgumentCode.TransferType transferType) {
<span class="fc" id="L337">    this.transferType = transferType;</span>
<span class="fc" id="L338">    setCorrectCodec();</span>
<span class="fc" id="L339">  }</span>

  /**
   * @return True if the current mode for data connection is FileInterface +
   *     (Stream or Block) + (Ascii or
   *     Image)
   */
  public final boolean isFileStreamBlockAsciiImage() {
<span class="pc bpc" id="L347" title="8 of 12 branches missed.">    return transferStructure == TransferStructure.FILE &amp;&amp;</span>
           (transferMode == TransferMode.STREAM ||
            transferMode == TransferMode.ZLIB ||
            transferMode == TransferMode.BLOCK) &amp;&amp;
           (transferType == TransferType.ASCII ||
            transferType == TransferType.IMAGE);
  }

  /**
   * @return True if the current mode for data connection is Stream
   */
  public final boolean isStreamFile() {
<span class="pc bpc" id="L359" title="2 of 6 branches missed.">    return (transferMode == TransferMode.STREAM ||</span>
            transferMode == TransferMode.ZLIB) &amp;&amp;
           transferStructure == TransferStructure.FILE;
  }

  /**
   * This function must be called after any changes of parameters, ie after
   * MODE, STRU, TYPE
   */
  private void setCorrectCodec() {
    try {
<span class="nc" id="L370">      getDataNetworkHandler().setCorrectCodec();</span>
<span class="fc" id="L371">    } catch (final FtpNoConnectionException ignored) {</span>
      // nothing
<span class="nc" id="L373">    }</span>
<span class="fc" id="L374">  }</span>

  /**
   * Unbind connection when close the Data Channel
   */
  public final synchronized void unbindData() {
<span class="fc bfc" id="L380" title="All 2 branches covered.">    if (isBind.get()) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (passiveMode.get()) {</span>
<span class="fc" id="L382">        isBind.set(false);</span>
<span class="fc" id="L383">        final InetSocketAddress local = getLocalAddress();</span>
<span class="fc" id="L384">        ChannelFuture future = null;</span>
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">        if (dataChannel != null &amp;&amp; dataChannel.isActive()) {</span>
<span class="nc" id="L386">          future = WaarpSslUtility.closingSslChannel(dataChannel);</span>
        }
<span class="fc" id="L388">        session.getConfiguration().getFtpInternalConfiguration()</span>
<span class="fc" id="L389">               .unbindPassive(local);</span>
        // Previous mode was Passive so remove the current configuration if
        // any
<span class="fc" id="L392">        final InetAddress remote = remoteAddress.getAddress();</span>
<span class="fc" id="L393">        session.getConfiguration().delFtpSession(remote, local);</span>
        // prepare the validation of the next connection
<span class="fc" id="L395">        getFtpTransferControl().resetWaitForOpenedDataChannel();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="nc" id="L397">          future.awaitUninterruptibly(FtpConfiguration.getDataTimeoutCon());</span>
        }
<span class="fc" id="L399">      } else {</span>
<span class="fc" id="L400">        isBind.set(false);</span>
<span class="fc" id="L401">        ChannelFuture future = null;</span>
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">        if (dataChannel != null &amp;&amp; dataChannel.isActive()) {</span>
<span class="nc" id="L403">          future = WaarpSslUtility.closingSslChannel(dataChannel);</span>
        }
<span class="fc" id="L405">        getFtpTransferControl().resetWaitForOpenedDataChannel();</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (future != null) {</span>
<span class="nc" id="L407">          future.awaitUninterruptibly(FtpConfiguration.getDataTimeoutCon());</span>
        }
      }
    }
<span class="fc" id="L411">    dataChannel = null;</span>
<span class="fc" id="L412">    dataNetworkHandler = null;</span>
<span class="fc" id="L413">  }</span>

  /**
   * Initialize the socket from Server side (only used in Passive)
   *
   * @return True if OK
   *
   * @throws Reply425Exception
   */
  public final boolean initPassiveConnection() throws Reply425Exception {
<span class="fc" id="L423">    unbindData();</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">    if (passiveMode.get()) {</span>
      // Connection is enable but the client will do the real connection
<span class="fc" id="L426">      session.getConfiguration().getFtpInternalConfiguration()</span>
<span class="fc" id="L427">             .bindPassive(getLocalAddress(), session.isDataSsl());</span>
<span class="fc" id="L428">      isBind.set(true);</span>
<span class="fc" id="L429">      return true;</span>
    }
    // Connection is already prepared
<span class="nc" id="L432">    return true;</span>
  }

  /**
   * Return the current Data Channel
   *
   * @return the current Data Channel
   *
   * @throws FtpNoConnectionException
   */
  public final Channel getCurrentDataChannel() throws FtpNoConnectionException {
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (dataChannel == null) {</span>
<span class="fc" id="L444">      throw new FtpNoConnectionException(&quot;No Data Connection active&quot;);</span>
    }
<span class="fc" id="L446">    return dataChannel;</span>
  }

  /**
   * @return the DataNetworkHandler
   *
   * @throws FtpNoConnectionException
   */
  public final synchronized DataNetworkHandler getDataNetworkHandler()
      throws FtpNoConnectionException {
<span class="fc bfc" id="L456" title="All 2 branches covered.">    if (dataNetworkHandler == null) {</span>
<span class="fc" id="L457">      throw new FtpNoConnectionException(&quot;No Data Connection active&quot;);</span>
    }
<span class="fc" id="L459">    return dataNetworkHandler;</span>
  }

  /**
   * @param dataNetworkHandler the {@link DataNetworkHandler} to set
   */
  public final synchronized void setDataNetworkHandler(
      final DataNetworkHandler dataNetworkHandler) {
<span class="fc" id="L467">    this.dataNetworkHandler = dataNetworkHandler;</span>
<span class="fc" id="L468">  }</span>

  /**
   * @param configuration
   *
   * @return a new Passive Port
   */
  public static int getNewPassivePort(final FtpConfiguration configuration) {
<span class="fc" id="L476">    synchronized (FtpConfiguration.ftpConfiguration) {</span>
<span class="fc" id="L477">      int port = -1;</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">      for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L479">        port = configuration.getNextRangePort();</span>
<span class="pc bpc" id="L480" title="2 of 4 branches missed.">        if (port &gt; 0 &amp;&amp; WaarpNettyUtil.availablePort(port)) {</span>
<span class="fc" id="L481">          return port;</span>
        }
        try {
<span class="nc" id="L484">          Thread.sleep(FtpInternalConfiguration.RETRYINMS);// NOSONAR</span>
<span class="nc" id="L485">        } catch (final InterruptedException e) {// NOSONAR</span>
<span class="nc" id="L486">          SysErrLogger.FAKE_LOGGER.ignoreLog(e);</span>
<span class="nc" id="L487">        }</span>
      }
<span class="nc" id="L489">      return -1;</span>
    }
  }

  /**
   * @return The current status in String of the different parameters
   */
  public final String getStatus() {
<span class="fc" id="L497">    final StringBuilder builder = new StringBuilder(&quot;Data connection: &quot;).append(</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        isActive()? &quot;connected &quot; : &quot;not connected &quot;).append(</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        isBind()? &quot;bind &quot; : &quot;not bind &quot;).append(</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        isPassiveMode()? &quot;passive mode&quot; : &quot;active mode&quot;).append('\n').append(</span>
<span class="fc" id="L501">        &quot;Mode: &quot;).append(transferMode.name()).append(&quot; localPort: &quot;).append(</span>
<span class="fc" id="L502">        getLocalPort()).append(&quot; remotePort: &quot;).append(getRemotePort()).append(</span>
<span class="fc" id="L503">        '\n').append(&quot;Structure: &quot;).append(transferStructure.name()).append(</span>
<span class="fc" id="L504">        '\n').append(&quot;Type: &quot;).append(transferType.name()).append(' ').append(</span>
<span class="fc" id="L505">        transferSubType.name());</span>
<span class="fc" id="L506">    return builder.toString();</span>
  }

  /**
   *
   */
  @Override
  public String toString() {
<span class="fc" id="L514">    return getStatus().replace('\n', ' ');</span>
  }

  /**
   * @return the FtpTransferControl
   */
  public final FtpTransferControl getFtpTransferControl() {
<span class="fc" id="L521">    return transferControl;</span>
  }

  /**
   * Set the new connected Data Channel
   *
   * @param dataChannel the new Data Channel
   *
   * @throws Reply425Exception
   */
  public final synchronized void setNewOpenedDataChannel(
      final Channel dataChannel) throws Reply425Exception {
<span class="fc" id="L533">    this.dataChannel = dataChannel;</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">    if (dataChannel == null) {</span>
      final String curmode;
<span class="nc bnc" id="L536" title="All 2 branches missed.">      if (isPassiveMode()) {</span>
<span class="nc" id="L537">        curmode = &quot;passive&quot;;</span>
      } else {
<span class="nc" id="L539">        curmode = &quot;active&quot;;</span>
      }
      // Cannot open connection
<span class="nc" id="L542">      throw new Reply425Exception(</span>
          &quot;Cannot open &quot; + curmode + &quot; data connection&quot;);
    }
<span class="fc" id="L545">    isBind.set(true);</span>
<span class="fc" id="L546">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>