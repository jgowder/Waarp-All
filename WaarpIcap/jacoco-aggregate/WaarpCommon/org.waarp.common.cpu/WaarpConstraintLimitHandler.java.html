<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>WaarpConstraintLimitHandler.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp ICAP Client</a> &gt; <a href="../index.html" class="el_bundle">WaarpCommon</a> &gt; <a href="index.source.html" class="el_package">org.waarp.common.cpu</a> &gt; <span class="el_source">WaarpConstraintLimitHandler.java</span></div><h1>WaarpConstraintLimitHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.common.cpu;

import io.netty.handler.traffic.AbstractTrafficShapingHandler;
import org.waarp.common.logging.SysErrLogger;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.ThreadLocalRandom;

import java.util.LinkedList;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * Abstract class for Constraint Limit Handler for Waarp project
 */
public abstract class WaarpConstraintLimitHandler implements Runnable {
  /**
   * Internal Logger
   */
<span class="fc" id="L39">  private static final WaarpLogger logger =</span>
<span class="fc" id="L40">      WaarpLoggerFactory.getLogger(WaarpConstraintLimitHandler.class);</span>

  private static final String NOALERT = &quot;noAlert&quot;;
  public static final long LOWBANDWIDTH_DEFAULT = 1048576;
<span class="pc" id="L44">  public String lastAlert = NOALERT;</span>
<span class="pc" id="L45">  private boolean constraintInactive = true;</span>
  private boolean useCpuLimits;
  private boolean useBandwidthLimit;

<span class="pc" id="L49">  private final ThreadLocalRandom random = ThreadLocalRandom.current();</span>
  private CpuManagementInterface cpuManagement;
<span class="pc" id="L51">  private double cpuLimit = 1.0; // was 0.8</span>
  private int channelLimit; // was 1000
  private boolean isServer;
  private double lastLA;
  private long lastTime;

  // Dynamic throttling
<span class="pc" id="L58">  private long waitForNetOp = 1000;</span>
<span class="pc" id="L59">  private long timeoutCon = 10000;</span>
  private double highCpuLimit; // was 0.8
  private double lowCpuLimit; // was 0.5
<span class="pc" id="L62">  private double percentageDecreaseRatio = 0.25;</span>
<span class="pc" id="L63">  private long delay = 1000;</span>
<span class="pc" id="L64">  private long limitLowBandwidth = LOWBANDWIDTH_DEFAULT;</span>
  private AbstractTrafficShapingHandler handler;
  private ScheduledThreadPoolExecutor executor;

  private static class CurLimits {
    long read;
    long write;

<span class="nc" id="L72">    private CurLimits(final long read, final long write) {</span>
<span class="nc" id="L73">      this.read = read;</span>
<span class="nc" id="L74">      this.write = write;</span>
<span class="nc" id="L75">    }</span>
  }

<span class="pc" id="L78">  private final LinkedList&lt;CurLimits&gt; curLimits = new LinkedList&lt;CurLimits&gt;();</span>
  private int nbSinceLastDecrease;
  private static final int PAYLOAD = 5;
  // 5 seconds of payload when new high cpu

  /**
   * Empty constructor
   */
<span class="nc" id="L86">  public WaarpConstraintLimitHandler() {</span>
    // Do nothing except setup standard value for inactivity
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (cpuManagement == null) {</span>
<span class="nc" id="L89">      cpuManagement = new CpuManagementNoInfo();</span>
    }
<span class="nc" id="L91">  }</span>

  /**
   * This constructor enables only throttling bandwidth with cpu usage
   *
   * @param waitForNetOp 1000 ms as wait for a network operation
   * @param timeOutCon 10000 ms as timeout limit
   * @param useJdkCpuLimit True to use JDK Cpu native or False for
   *     JavaSysMon
   * @param lowcpuLimit for proactive cpu limitation (throttling
   *     bandwidth)
   *     (0&lt;= x &lt; 1 &amp; highcpulimit)
   * @param highcpuLimit for proactive cpu limitation (throttling
   *     bandwidth)
   *     (0&lt;= x &lt;= 1) 0 meaning no
   *     throttle activated
   * @param percentageDecrease for proactive cpu limitation,
   *     throttling
   *     bandwidth reduction (0 &lt; x &lt; 1) as 0.25
   *     for 25% of reduction
   * @param handler the GlobalTrafficShapingHandler associated (null
   *     to have
   *     no proactive cpu
   *     limitation)
   * @param delay the delay between 2 tests for proactive cpu
   *     limitation
   * @param limitLowBandwidth the minimal bandwidth (read or write) to
   *     apply
   *     when decreasing bandwidth (low
   *     limit = 4096)
   */
  public WaarpConstraintLimitHandler(final long waitForNetOp,
                                     final long timeOutCon,
                                     final boolean useJdkCpuLimit,
                                     final double lowcpuLimit,
                                     final double highcpuLimit,
                                     final double percentageDecrease,
                                     final AbstractTrafficShapingHandler handler,
                                     final long delay,
                                     final long limitLowBandwidth) {
<span class="nc" id="L131">    this(waitForNetOp, timeOutCon, true, useJdkCpuLimit, 0, 0, lowcpuLimit,</span>
         highcpuLimit, percentageDecrease, handler, delay, limitLowBandwidth);
<span class="nc" id="L133">  }</span>

  /**
   * This constructor enables only Connection check ability
   *
   * @param useCpuLimit True to enable cpuLimit on connection check
   * @param useJdKCpuLimit True to use JDK Cpu native or False for
   *     JavaSysMon
   * @param cpulimit high cpu limit (0&lt;= x &lt; 1) to refuse new
   *     connections
   * @param channellimit number of connection limit (0&lt;= x)
   */
  public WaarpConstraintLimitHandler(final long waitForNetOp,
                                     final long timeOutCon,
                                     final boolean useCpuLimit,
                                     final boolean useJdKCpuLimit,
                                     final double cpulimit,
                                     final int channellimit) {
<span class="nc" id="L151">    this(waitForNetOp, timeOutCon, useCpuLimit, useJdKCpuLimit, cpulimit,</span>
         channellimit, 0, 0, 0.01, null, 1000000, LOWBANDWIDTH_DEFAULT);
<span class="nc" id="L153">  }</span>

  /**
   * This constructor enables both Connection check ability and throttling
   * bandwidth with cpu usage
   *
   * @param waitForNetOp2 1000 ms as wait for a network operation
   * @param timeOutCon2 10000 ms as timeout limit
   * @param useCpuLimit True to enable cpuLimit on connection check
   * @param useJdKCpuLimit True to use JDK Cpu native or False for
   *     JavaSysMon
   * @param cpulimit high cpu limit (0&lt;= x &lt; 1) to refuse new
   *     connections
   * @param channellimit number of connection limit (0&lt;= x)
   * @param lowcpuLimit for proactive cpu limitation (throttling
   *     bandwidth)
   *     (0&lt;= x &lt; 1 &amp; highcpulimit)
   * @param highcpuLimit for proactive cpu limitation (throttling
   *     bandwidth)
   *     (0&lt;= x &lt;= 1) 0 meaning no
   *     throttle activated
   * @param percentageDecrease for proactive cpu limitation,
   *     throttling
   *     bandwidth reduction (0 &lt; x &lt; 1) as 0.25
   *     for 25% of reduction
   * @param handler the GlobalTrafficShapingHandler associated (null
   *     to have
   *     no proactive cpu
   *     limitation)
   * @param delay the delay between 2 tests for proactive cpu
   *     limitation
   * @param limitLowBandwidth the minimal bandwidth (read or write) to
   *     apply
   *     when decreasing bandwidth (low
   *     limit = 4096)
   */
  public WaarpConstraintLimitHandler(final long waitForNetOp2,
                                     final long timeOutCon2,
                                     final boolean useCpuLimit,
                                     final boolean useJdKCpuLimit,
                                     final double cpulimit,
                                     final int channellimit,
                                     final double lowcpuLimit,
                                     final double highcpuLimit,
                                     final double percentageDecrease,
                                     final AbstractTrafficShapingHandler handler,
                                     final long delay,
<span class="fc" id="L200">                                     final long limitLowBandwidth) {</span>
<span class="fc" id="L201">    useCpuLimits = useCpuLimit;</span>
<span class="fc" id="L202">    waitForNetOp = waitForNetOp2;</span>
<span class="fc" id="L203">    timeoutCon = timeOutCon2;</span>
<span class="fc" id="L204">    lowCpuLimit = lowcpuLimit;</span>
<span class="fc" id="L205">    highCpuLimit = highcpuLimit;</span>
<span class="fc" id="L206">    this.limitLowBandwidth = limitLowBandwidth;</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">    if (this.limitLowBandwidth &lt; LOWBANDWIDTH_DEFAULT) {</span>
<span class="fc" id="L208">      this.limitLowBandwidth = LOWBANDWIDTH_DEFAULT;</span>
    }
<span class="fc" id="L210">    this.delay = delay;</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">    if (lowCpuLimit &lt;= 0) {</span>
<span class="fc" id="L212">      lowCpuLimit = highCpuLimit / 2;</span>
    }
<span class="fc" id="L214">    percentageDecreaseRatio = percentageDecrease;</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">    if (percentageDecreaseRatio &lt;= 0) {</span>
<span class="nc" id="L216">      percentageDecreaseRatio = 0.01;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    } else if (percentageDecreaseRatio &gt;= 1) {</span>
<span class="nc" id="L218">      percentageDecreaseRatio /= 100;</span>
    }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (delay &lt; waitForNetOp &gt;&gt; 1) {</span>
<span class="fc" id="L221">      this.delay = waitForNetOp;</span>
    }
<span class="fc" id="L223">    this.handler = handler;</span>
<span class="pc bpc" id="L224" title="3 of 4 branches missed.">    if (useCpuLimits || highCpuLimit &gt; 0) {</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">      if (useJdKCpuLimit) {</span>
        try {
<span class="fc" id="L227">          cpuManagement = new CpuManagement();</span>
<span class="fc" id="L228">          constraintInactive = false;</span>
<span class="nc" id="L229">        } catch (final UnsupportedOperationException e) {</span>
<span class="nc" id="L230">          cpuManagement = new CpuManagementNoInfo();</span>
<span class="nc" id="L231">          constraintInactive = true;</span>
<span class="pc" id="L232">        }</span>
      } else {
<span class="nc" id="L234">        cpuManagement = new CpuManagementSysmon();</span>
<span class="nc" id="L235">        constraintInactive = false;</span>
      }
    } else {
      // no test at all
<span class="nc" id="L239">      constraintInactive = true;</span>
<span class="nc" id="L240">      cpuManagement = new CpuManagementNoInfo();</span>
    }
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">    useBandwidthLimit = highcpuLimit &gt; 0;</span>
<span class="fc" id="L243">    cpuLimit = cpulimit;</span>
<span class="fc" id="L244">    channelLimit = channellimit;</span>
<span class="fc" id="L245">    lastTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L246" title="3 of 6 branches missed.">    if (this.handler != null &amp;&amp; !constraintInactive &amp;&amp; !useBandwidthLimit) {</span>
<span class="nc" id="L247">      executor = new ScheduledThreadPoolExecutor(1);</span>
<span class="nc" id="L248">      executor.scheduleWithFixedDelay(this, this.delay, this.delay,</span>
                                      TimeUnit.MILLISECONDS);
    }
<span class="fc" id="L251">  }</span>

  /**
   * Release the resources
   */
  public void release() {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    if (executor != null) {</span>
<span class="nc" id="L258">      executor.shutdownNow();</span>
    }
<span class="fc" id="L260">  }</span>

  /**
   * To explicitly set this handler as server mode
   *
   * @param isServer
   */
  public void setServer(final boolean isServer) {
<span class="fc" id="L268">    this.isServer = isServer;</span>
<span class="fc" id="L269">  }</span>

  private double getLastLA() {
<span class="fc" id="L272">    final long newTime = System.currentTimeMillis();</span>
    // first check if last test was done too shortly
    // If last test was wrong, then redo the test
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">    if (newTime - lastTime &lt; waitForNetOp &gt;&gt; 1 &amp;&amp; lastLA &lt;= cpuLimit) {</span>
      // last test was OK, so Continue
<span class="fc" id="L277">      return lastLA;</span>
    }
<span class="nc" id="L279">    lastTime = newTime;</span>
<span class="nc" id="L280">    lastLA = cpuManagement.getLoadAverage();</span>
<span class="nc" id="L281">    return lastLA;</span>
  }

  /**
   * @return True if one of the limit is exceeded. Always False if not a
   *     server mode
   */
  public boolean checkConstraints() {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">    if (!isServer) {</span>
<span class="nc" id="L290">      return false;</span>
    }
<span class="pc bpc" id="L292" title="3 of 6 branches missed.">    if (useCpuLimits &amp;&amp; cpuLimit &lt; 1 &amp;&amp; cpuLimit &gt; 0) {</span>
<span class="fc" id="L293">      getLastLA();</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">      if (lastLA &lt;= cpuLimit) {</span>
<span class="fc" id="L295">        lastAlert = NOALERT;</span>
<span class="fc" id="L296">        return false;</span>
      }
<span class="nc" id="L298">      lastAlert = &quot;CPU Constraint: &quot; + lastLA + &quot; &gt; &quot; + cpuLimit;</span>
<span class="nc" id="L299">      logger.info(lastAlert);</span>
<span class="nc" id="L300">      return true;</span>
    }
<span class="nc bnc" id="L302" title="All 2 branches missed.">    if (channelLimit &gt; 0) {</span>
<span class="nc" id="L303">      final int nb = getNumberLocalChannel();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">      if (channelLimit &lt; nb) {</span>
<span class="nc" id="L305">        lastAlert = &quot;LocalNetwork Constraint: &quot; + nb + &quot; &gt; &quot; + channelLimit;</span>
<span class="nc" id="L306">        logger.info(lastAlert);</span>
<span class="nc" id="L307">        return true;</span>
      }
    }
<span class="nc" id="L310">    lastAlert = NOALERT;</span>
<span class="nc" id="L311">    return false;</span>
  }

  /**
   * @return the current number of active Local Channel
   */
  protected abstract int getNumberLocalChannel();

  /**
   * Same as checkConstraints except that the thread will sleep some time
   * proportionally to the current Load (if
   * CPU related)
   *
   * @param step the current step in retry
   *
   * @return True if one of the limit is exceeded. Always False if not a
   *     server mode
   */
  public boolean checkConstraintsSleep(final int step) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">    if (!isServer) {</span>
<span class="nc" id="L331">      return false;</span>
    }
<span class="nc" id="L333">    long delayNew = waitForNetOp &gt;&gt; 1;</span>
<span class="nc bnc" id="L334" title="All 6 branches missed.">    if (useCpuLimits &amp;&amp; cpuLimit &lt; 1 &amp;&amp; cpuLimit &gt; 0) {</span>
<span class="nc" id="L335">      final long newTime = System.currentTimeMillis();</span>
      // first check if last test was done too shortly
<span class="nc bnc" id="L337" title="All 2 branches missed.">      if (newTime - lastTime &lt; delayNew) {</span>
        // If last test was wrong, then wait a bit then redo the test
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (lastLA &gt; cpuLimit) {</span>
<span class="nc" id="L340">          final double sleep =</span>
<span class="nc" id="L341">              lastLA * delayNew * (step + 1) * random.nextFloat();</span>
<span class="nc" id="L342">          final long shorttime = ((long) sleep / 10) * 10;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">          if (shorttime &gt;= 10) {</span>
            try {
<span class="nc" id="L345">              Thread.sleep(shorttime);</span>
<span class="nc" id="L346">            } catch (final InterruptedException ignore) {//NOSONAR</span>
<span class="nc" id="L347">              SysErrLogger.FAKE_LOGGER.ignoreLog(ignore);</span>
<span class="nc" id="L348">            }</span>
          }
<span class="nc" id="L350">        } else {</span>
          // last test was OK, so Continue
<span class="nc" id="L352">          lastAlert = NOALERT;</span>
<span class="nc" id="L353">          return false;</span>
        }
      }
    }
<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (checkConstraints()) {</span>
<span class="nc" id="L358">      delayNew = getSleepTime() * (step + 1);</span>
      try {
<span class="nc" id="L360">        Thread.sleep(delayNew);</span>
<span class="nc" id="L361">      } catch (final InterruptedException ignore) {//NOSONAR</span>
<span class="nc" id="L362">        SysErrLogger.FAKE_LOGGER.ignoreLog(ignore);</span>
<span class="nc" id="L363">      }</span>
<span class="nc" id="L364">      return true;</span>
    } else {
<span class="nc" id="L366">      lastAlert = NOALERT;</span>
<span class="nc" id="L367">      return false;</span>
    }
  }

  /**
   * @return a time below TIMEOUTCON with a random
   */
  public long getSleepTime() {
<span class="nc" id="L375">    return (((long) (timeoutCon * random.nextFloat()) + 5000) / 10) * 10;</span>
  }

  /**
   * @return the cpuLimit
   */
  public double getCpuLimit() {
<span class="nc" id="L382">    return cpuLimit;</span>
  }

  /**
   * @param cpuLimit the cpuLimit to set
   */
  public void setCpuLimit(final double cpuLimit) {
<span class="nc" id="L389">    this.cpuLimit = cpuLimit;</span>
<span class="nc" id="L390">  }</span>

  /**
   * @return the channelLimit
   */
  public int getChannelLimit() {
<span class="nc" id="L396">    return channelLimit;</span>
  }

  /**
   * @param channelLimit the channelLimit to set
   */
  public void setChannelLimit(final int channelLimit) {
<span class="nc" id="L403">    this.channelLimit = channelLimit;</span>
<span class="nc" id="L404">  }</span>

  /**
   * Get the current setting on Read Limit (supposed to be not the value in
   * the
   * handler but in the
   * configuration)
   *
   * @return the current setting on Read Limit
   */
  protected abstract long getReadLimit();

  /**
   * Get the current setting on Write Limit (supposed to be not the value in
   * the
   * handler but in the
   * configuration)
   *
   * @return the current setting on Write Limit
   */
  protected abstract long getWriteLimit();

  /**
   * Set the handler
   *
   * @param handler
   */
  public void setHandler(final AbstractTrafficShapingHandler handler) {
<span class="nc" id="L432">    this.handler = handler;</span>
<span class="nc bnc" id="L433" title="All 6 branches missed.">    if (!constraintInactive &amp;&amp; this.handler != null &amp;&amp; useBandwidthLimit) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">      if (executor != null) {</span>
<span class="nc" id="L435">        executor.shutdownNow();</span>
      }
<span class="nc" id="L437">      logger.debug(&quot;Activate Throttle bandwidth according to CPU usage&quot;);</span>
<span class="nc" id="L438">      executor = new ScheduledThreadPoolExecutor(1);</span>
<span class="nc" id="L439">      executor</span>
<span class="nc" id="L440">          .scheduleWithFixedDelay(this, delay, delay, TimeUnit.MILLISECONDS);</span>
    } else {
<span class="nc bnc" id="L442" title="All 2 branches missed.">      if (executor != null) {</span>
<span class="nc" id="L443">        executor.shutdownNow();</span>
<span class="nc" id="L444">        executor = null;</span>
      }
    }
<span class="nc" id="L447">  }</span>

  /**
   * Check every delay if the current cpu usage needs to relax or to
   * constraint
   * the bandwidth
   */
  @Override
  public void run() {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">    if (constraintInactive) {</span>
<span class="nc" id="L457">      return;</span>
    }
<span class="fc" id="L459">    final double curLA = getLastLA();</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">    if (!useBandwidthLimit) {</span>
<span class="nc" id="L461">      return;</span>
    }
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">    if (curLA &gt; highCpuLimit) {</span>
      final CurLimits curlimit;
<span class="nc bnc" id="L465" title="All 2 branches missed.">      if (curLimits.isEmpty()) {</span>
        // get current limit setting
<span class="nc" id="L467">        curlimit = new CurLimits(getReadLimit(), getWriteLimit());</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (curlimit.read == 0) {</span>
          // take the current bandwidth
<span class="nc" id="L470">          curlimit.read = handler.trafficCounter().lastReadThroughput();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">          if (curlimit.read &lt; limitLowBandwidth) {</span>
<span class="nc" id="L472">            curlimit.read = 0;</span>
          }
        }
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (curlimit.write == 0) {</span>
          // take the current bandwidth
<span class="nc" id="L477">          curlimit.write = handler.trafficCounter().lastWriteThroughput();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">          if (curlimit.write &lt; limitLowBandwidth) {</span>
<span class="nc" id="L479">            curlimit.write = 0;</span>
          }
        }
      } else {
<span class="nc" id="L483">        curlimit = curLimits.getLast();</span>
      }
<span class="nc" id="L485">      long newread = (long) (curlimit.read * (1 - percentageDecreaseRatio));</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">      if (newread &lt; limitLowBandwidth) {</span>
<span class="nc" id="L487">        newread = limitLowBandwidth;</span>
      }
<span class="nc" id="L489">      long newwrite = (long) (curlimit.write * (1 - percentageDecreaseRatio));</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      if (newwrite &lt; limitLowBandwidth) {</span>
<span class="nc" id="L491">        newwrite = limitLowBandwidth;</span>
      }
<span class="nc" id="L493">      final CurLimits newlimit = new CurLimits(newread, newwrite);</span>
<span class="nc bnc" id="L494" title="All 6 branches missed.">      if (curLimits.isEmpty() || curlimit.read != newread ||</span>
          curlimit.write != newwrite) {
        // Not same limit so add this limit
<span class="nc" id="L497">        curLimits.add(newlimit);</span>
<span class="nc" id="L498">        logger.info(&quot;Set new low limit since CPU = {} {}:{}&quot;, curLA, newwrite,</span>
<span class="nc" id="L499">                    newread);</span>
<span class="nc" id="L500">        handler.configure(newlimit.write, newlimit.read);</span>
<span class="nc" id="L501">        nbSinceLastDecrease += PAYLOAD;</span>
      }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">    } else if (curLA &lt; lowCpuLimit) {</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">      if (curLimits.isEmpty()) {</span>
        // nothing to do
<span class="fc" id="L506">        return;</span>
      }
<span class="nc bnc" id="L508" title="All 2 branches missed.">      if (nbSinceLastDecrease &gt; 0) {</span>
<span class="nc" id="L509">        nbSinceLastDecrease--;</span>
        // wait a bit more in case
<span class="nc" id="L511">        return;</span>
      }
<span class="nc" id="L513">      nbSinceLastDecrease = 0;</span>
<span class="nc" id="L514">      curLimits.pollLast();</span>
      final CurLimits newlimit;
<span class="nc bnc" id="L516" title="All 2 branches missed.">      if (curLimits.isEmpty()) {</span>
        // reset to default limits
<span class="nc" id="L518">        final long newread = getReadLimit();</span>
<span class="nc" id="L519">        final long newwrite = getWriteLimit();</span>
<span class="nc" id="L520">        logger.info(&quot;restore limit since CPU = {} {}:{}&quot;, curLA, newwrite,</span>
<span class="nc" id="L521">                    newread);</span>
<span class="nc" id="L522">        handler.configure(newwrite, newread);</span>
<span class="nc" id="L523">      } else {</span>
        // set next upper values
<span class="nc" id="L525">        newlimit = curLimits.getLast();</span>
<span class="nc" id="L526">        final long newread = newlimit.read;</span>
<span class="nc" id="L527">        final long newwrite = newlimit.write;</span>
<span class="nc" id="L528">        logger</span>
<span class="nc" id="L529">            .info(&quot;Set new upper limit since CPU = {} {}:{}&quot;, +curLA, newwrite,</span>
<span class="nc" id="L530">                  newread);</span>
<span class="nc" id="L531">        handler.configure(newwrite, newread);</span>
        // give extra payload to prevent a brutal return to normal
<span class="nc" id="L533">        nbSinceLastDecrease = PAYLOAD;</span>
      }
    }
<span class="nc" id="L536">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>