<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>RestHandlerHook.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp R66 Client Gui</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.protocol.http.restv2.resthandlers</a> &gt; <span class="el_source">RestHandlerHook.java</span></div><h1>RestHandlerHook.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package org.waarp.openr66.protocol.http.restv2.resthandlers;

import io.cdap.http.HandlerHook;
import io.cdap.http.HttpResponder;
import io.cdap.http.internal.HandlerInfo;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import org.joda.time.DateTime;
import org.waarp.common.crypto.HmacSha256;
import org.waarp.common.database.exception.WaarpDatabaseException;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.role.RoleDefault;
import org.waarp.common.role.RoleDefault.ROLE;
import org.waarp.common.utility.BaseXx;
import org.waarp.openr66.dao.DAOFactory;
import org.waarp.openr66.dao.HostDAO;
import org.waarp.openr66.dao.exception.DAOConnectionException;
import org.waarp.openr66.dao.exception.DAONoDataException;
import org.waarp.openr66.database.data.DbHostAuth;
import org.waarp.openr66.pojo.Host;
import org.waarp.openr66.protocol.http.restv2.RestServiceInitializer;
import org.waarp.openr66.protocol.http.restv2.converters.HostConfigConverter;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.AbstractRestDbHandler;
import org.waarp.openr66.protocol.http.restv2.dbhandlers.RequiredRole;

import javax.ws.rs.Consumes;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotAllowedException;
import javax.ws.rs.core.MediaType;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static io.netty.handler.codec.http.HttpMethod.*;
import static io.netty.handler.codec.http.HttpResponseStatus.*;
import static javax.ws.rs.core.HttpHeaders.*;
import static javax.ws.rs.core.MediaType.*;
import static org.glassfish.jersey.message.internal.HttpHeaderReader.*;
import static org.glassfish.jersey.message.internal.MediaTypes.*;
import static org.waarp.common.role.RoleDefault.ROLE.*;
import static org.waarp.openr66.protocol.configuration.Configuration.*;
import static org.waarp.openr66.protocol.http.restv2.RestConstants.*;

/**
 * This class defines hooks called before and after the corresponding {@link
 * AbstractRestDbHandler} when a
 * request is made. These hooks check the user authentication and privileges, as
 * well as the request content
 * type.
 */
public class RestHandlerHook implements HandlerHook {

  /**
   * Tells if the REST request authentication is activated.
   */
  private final boolean authenticated;

  /**
   * Stores the key used for HMAC authentication.
   */
  private final HmacSha256 hmac;

  /**
   * The time (in ms) for which a HMAC signed request is valid.
   */
  private final long delay;

  /**
   * The logger for all events.
   */
<span class="fc" id="L96">  private static final WaarpLogger logger =</span>
<span class="fc" id="L97">      WaarpLoggerFactory.getLogger(RestHandlerHook.class);</span>

  /**
   * Hook called before a request handler is called. Checks if the REST method
   * is active in the CRUD
   * configuration, checks the request's content type, and finally checks the
   * user authentication (if
   * activated).
   *
   * @param request the HttpRequest currently being processed
   * @param responder the HttpResponder sending the response
   * @param handlerInfo the information about the handler to which the
   *     request will be sent for processing
   *
   * @return {@code true} if the request can be handed to the handler, or
   *     {@code false} if an error occurred and
   *     a response must be sent immediately.
   */
  @Override
  public boolean preCall(final HttpRequest request,
                         final HttpResponder responder,
                         final HandlerInfo handlerInfo) {

    try {
<span class="fc" id="L121">      final AbstractRestDbHandler handler = getHandler(handlerInfo);</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">      if (!handler.checkCRUD(request)) {</span>
<span class="nc" id="L123">        responder.sendStatus(METHOD_NOT_ALLOWED);</span>
<span class="nc" id="L124">        return false;</span>
      }

<span class="fc" id="L127">      final Method handleMethod = getMethod(handler, handlerInfo);</span>
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">      if (authenticated &amp;&amp; !request.method().equals(OPTIONS)) {</span>
<span class="fc" id="L129">        final String user = checkCredentials(request);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (!checkAuthorization(user, handleMethod)) {</span>
<span class="nc" id="L131">          responder.sendStatus(FORBIDDEN);</span>
<span class="nc" id="L132">          return false;</span>
        }
      }

<span class="fc" id="L136">      final List&lt;MediaType&gt; expectedTypes = getExpectedMediaTypes(handleMethod);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">      if (!checkContentType(request, expectedTypes)) {</span>
<span class="nc" id="L138">        final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="nc" id="L139">        headers.add(ACCEPT, convertToString(expectedTypes));</span>
<span class="nc" id="L140">        responder.sendStatus(UNSUPPORTED_MEDIA_TYPE, headers);</span>
<span class="nc" id="L141">        return false;</span>
      }

<span class="fc" id="L144">      return true;</span>
<span class="fc" id="L145">    } catch (final NotAllowedException e) {</span>
<span class="fc" id="L146">      logger.info(e.getMessage());</span>
<span class="fc" id="L147">      final DefaultHttpHeaders headers = new DefaultHttpHeaders();</span>
<span class="fc" id="L148">      headers.add(WWW_AUTHENTICATE, &quot;Basic, HMAC&quot;);</span>
<span class="fc" id="L149">      responder.sendStatus(UNAUTHORIZED, headers);</span>
<span class="nc" id="L150">    } catch (final InternalServerErrorException e) {</span>
<span class="nc" id="L151">      logger.error(e);</span>
<span class="nc" id="L152">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="nc" id="L153">    } catch (final Throwable t) {</span>
<span class="nc" id="L154">      logger.error(&quot;RESTv2 Unexpected exception caught -&gt;&quot;, t);</span>
<span class="nc" id="L155">      responder.sendStatus(INTERNAL_SERVER_ERROR);</span>
<span class="pc" id="L156">    }</span>
<span class="fc" id="L157">    return false;</span>
  }

  /**
   * Returns the {@link AbstractRestDbHandler} instance corresponding to the
   * info given as parameter.
   *
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding AbstractRestDbHandler
   *
   * @throws IllegalArgumentException if the given handler does not
   *     exist.
   */
  private AbstractRestDbHandler getHandler(final HandlerInfo handlerInfo) {
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">    for (final AbstractRestDbHandler h : RestServiceInitializer.handlers) {</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">      if (h.getClass().getName().equals(handlerInfo.getHandlerName())) {</span>
<span class="fc" id="L174">        return h;</span>
      }
<span class="fc" id="L176">    }</span>
<span class="nc" id="L177">    throw new IllegalArgumentException(</span>
<span class="nc" id="L178">        &quot;The handler &quot; + handlerInfo.getHandlerName() + &quot; does not exist.&quot;);</span>
  }

  /**
   * Returns the {@link Method} object corresponding to the handler method
   * chosen to process the request. This
   * is needed to check for the annotations present on the method.
   *
   * @param handler the handler chosen to process the request
   * @param handlerInfo the information about the handler
   *
   * @return the corresponding Method object
   *
   * @throws IllegalArgumentException if the given method name does
   *     not exist
   */
  private Method getMethod(final AbstractRestDbHandler handler,
                           final HandlerInfo handlerInfo) {
<span class="fc" id="L196">    Method method = null;</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">    for (final Method m : handler.getClass().getMethods()) {//NOSONAR</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">      if (m.getName().equals(handlerInfo.getMethodName()) &amp;&amp;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">          m.getParameterTypes()[0] == HttpRequest.class &amp;&amp;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">          m.getParameterTypes()[1] == HttpResponder.class) {</span>
<span class="fc" id="L201">        method = m;</span>
<span class="fc" id="L202">        break;</span>
      }
    }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L206">      throw new IllegalArgumentException(</span>
<span class="nc" id="L207">          &quot;The handler &quot; + handlerInfo.getHandlerName() +</span>
<span class="nc" id="L208">          &quot; does not have a method &quot; + handlerInfo.getMethodName());</span>
    }
<span class="fc" id="L210">    return method;</span>
  }

  /**
   * Return a List of all the {@link MediaType} accepted by the given {@link
   * Method}. This list is based on the
   * types indicated by the method's {@link Consumes} annotation. If the
   * annotation is absent, the method will
   * be assumed to accept any type.
   *
   * @param method the Method to inspect
   *
   * @return the list of all acceptable MediaType
   */
  private List&lt;MediaType&gt; getExpectedMediaTypes(final Method method) {
<span class="fc" id="L225">    List&lt;MediaType&gt; consumedTypes = WILDCARD_TYPE_SINGLETON_LIST;</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">    if (method.isAnnotationPresent(Consumes.class)) {</span>
<span class="fc" id="L228">      consumedTypes = createFrom(method.getAnnotation(Consumes.class));</span>
    } else {
<span class="nc" id="L230">      logger.warn(String.format(</span>
          &quot;[RESTv2] The method %s of handler %s is missing &quot; +
          &quot;a '%s' annotation for the expected request content type, &quot; +
<span class="nc" id="L233">          &quot;the default value '%s' was given instead.&quot;, method.getName(),</span>
<span class="nc" id="L234">          method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L235">          Consumes.class.getSimpleName(), WILDCARD));</span>
    }

<span class="fc" id="L238">    return consumedTypes;</span>
  }

  /**
   * Checks if the content type of the request is compatible with the expected
   * content type of the method
   * called. If no content type header can be found, the request will be
   * assumed to have a correct content type.
   *
   * @param request the HttpRequest sent by the user
   * @param consumedTypes a list of the acceptable MediaType for the
   *     request
   *
   * @return {@code true} if the request content type is acceptable, {@code
   *     false} otherwise.
   */
  private boolean checkContentType(final HttpRequest request,
                                   final List&lt;MediaType&gt; consumedTypes) {

<span class="fc" id="L257">    final String contentTypeHeader = request.headers().get(CONTENT_TYPE);</span>
<span class="pc bpc" id="L258" title="3 of 4 branches missed.">    if (contentTypeHeader == null || contentTypeHeader.isEmpty()) {</span>
<span class="fc" id="L259">      return true;</span>
    }

    final MediaType requestType;
    try {
<span class="nc" id="L264">      requestType = readAcceptMediaType(contentTypeHeader).get(0);</span>
<span class="nc" id="L265">    } catch (final ParseException e) {</span>
<span class="nc" id="L266">      return false;</span>
<span class="nc" id="L267">    }</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">    for (final MediaType consumedType : consumedTypes) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">      if (requestType.isCompatible(consumedType)) {</span>
<span class="nc" id="L270">        return true;</span>
      }
<span class="nc" id="L272">    }</span>
<span class="nc" id="L273">    return false;</span>
  }

  /**
   * Checks if the user making the request does exist. If the user does exist,
   * this method returns the user's
   * name, otherwise throws a {@link NotAllowedException}.
   *
   * @param request the request currently being processed
   *
   * @return the user's name
   *
   * @throws InternalServerErrorException if an unexpected error
   *     occurred
   * @throws NotAllowedException if the user making the request does
   *     not exist
   */
  protected String checkCredentials(final HttpRequest request) {

<span class="fc" id="L292">    final String authorization = request.headers().get(AUTHORIZATION);</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">    if (authorization == null) {</span>
<span class="fc" id="L295">      throw new NotAllowedException(&quot;Missing header for authentication.&quot;);</span>
    }

<span class="fc" id="L298">    final Pattern basicPattern = Pattern.compile(&quot;(Basic) (\\w+=*)&quot;);</span>
<span class="fc" id="L299">    final Matcher basicMatcher = basicPattern.matcher(authorization);</span>

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">    if (basicMatcher.find()) {</span>

      final String[] credentials;
<span class="fc" id="L304">      credentials =</span>
<span class="fc" id="L305">          new String(BaseXx.getFromBase64(basicMatcher.group(2))).split(&quot;:&quot;, 2);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">      if (credentials.length != 2) {</span>
<span class="nc" id="L307">        throw new NotAllowedException(</span>
            &quot;Invalid header for Basic authentication.&quot;);
      }
<span class="fc" id="L310">      final String user = credentials[0];</span>
<span class="fc" id="L311">      final String pswd = credentials[1];</span>

<span class="fc" id="L313">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="fc" id="L316">        hostDAO = DAO_FACTORY.getHostDAO();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (!hostDAO.exist(user)) {</span>
<span class="fc" id="L318">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="fc" id="L320">        host = hostDAO.select(user);</span>
<span class="nc" id="L321">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L322">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L323">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L324">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="fc" id="L326">        DAOFactory.closeDAO(hostDAO);</span>
      }

      final String key;
      try {
<span class="fc" id="L331">        key = configuration.getCryptoKey().cryptToHex(pswd);</span>
<span class="nc" id="L332">      } catch (final Exception e) {</span>
<span class="nc" id="L333">        throw new InternalServerErrorException(</span>
            &quot;An error occurred when encrypting the password&quot;, e);
<span class="fc" id="L335">      }</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">      if (!Arrays.equals(host.getHostkey(), key.getBytes())) {</span>
<span class="nc" id="L337">        throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
      }

<span class="fc" id="L340">      return user;</span>
    }

<span class="nc" id="L343">    final String authUser = request.headers().get(AUTH_USER);</span>
<span class="nc" id="L344">    final String authDate = request.headers().get(AUTH_TIMESTAMP);</span>

<span class="nc" id="L346">    final Pattern hmacPattern = Pattern.compile(&quot;(HMAC) (\\w+)&quot;);</span>
<span class="nc" id="L347">    final Matcher hmacMatcher = hmacPattern.matcher(authorization);</span>

<span class="nc bnc" id="L349" title="All 6 branches missed.">    if (hmacMatcher.find() &amp;&amp; authUser != null &amp;&amp; authDate != null) {</span>

<span class="nc" id="L351">      final String authKey = hmacMatcher.group(2);</span>
      final DateTime requestDate;
      try {
<span class="nc" id="L354">        requestDate = DateTime.parse(authDate);</span>
<span class="nc" id="L355">      } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L356">        throw new NotAllowedException(&quot;Invalid authentication timestamp.&quot;);</span>
<span class="nc" id="L357">      }</span>
<span class="nc" id="L358">      final DateTime limitTime = requestDate.plus(delay);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      if (DateTime.now().isAfter(limitTime)) {</span>
<span class="nc" id="L360">        throw new NotAllowedException(&quot;Authentication expired.&quot;);</span>
      }

<span class="nc" id="L363">      HostDAO hostDAO = null;</span>
      Host host;
      try {
<span class="nc" id="L366">        hostDAO = DAO_FACTORY.getHostDAO();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (!hostDAO.exist(authUser)) {</span>
<span class="nc" id="L368">          throw new NotAllowedException(&quot;User does not exist.&quot;);</span>
        }
<span class="nc" id="L370">        host = hostDAO.select(authUser);</span>
<span class="nc" id="L371">      } catch (final DAOConnectionException e) {</span>
<span class="nc" id="L372">        throw new InternalServerErrorException(e);</span>
<span class="nc" id="L373">      } catch (final DAONoDataException e) {</span>
<span class="nc" id="L374">        throw new InternalServerErrorException(e);</span>
      } finally {
<span class="nc" id="L376">        DAOFactory.closeDAO(hostDAO);</span>
      }

<span class="nc" id="L379">      validateHMACCredentials(host, authDate, authUser, authKey);</span>

<span class="nc" id="L381">      return authUser;</span>
    }

<span class="nc" id="L384">    throw new NotAllowedException(&quot;Missing credentials.&quot;);</span>
  }

  protected void validateHMACCredentials(final Host host, final String authDate,
                                         final String authUser,
                                         final String authKey)
      throws InternalServerErrorException {
    final String pswd;
    try {
<span class="fc" id="L393">      pswd = configuration.getCryptoKey().decryptHexInString(host.getHostkey());</span>
<span class="nc" id="L394">    } catch (final Exception e) {</span>
<span class="nc" id="L395">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when decrypting the password&quot;, e);
<span class="fc" id="L397">    }</span>

    final String key;
    try {
<span class="fc" id="L401">      key = hmac.cryptToHex(authDate + authUser + pswd);</span>
<span class="nc" id="L402">    } catch (final Exception e) {</span>
<span class="nc" id="L403">      throw new InternalServerErrorException(</span>
          &quot;An error occurred when hashing the key&quot;, e);
<span class="fc" id="L405">    }</span>

<span class="pc bpc" id="L407" title="1 of 2 branches missed.">    if (!key.equals(authKey)) {</span>
<span class="nc" id="L408">      throw new NotAllowedException(&quot;Invalid password.&quot;);</span>
    }
<span class="fc" id="L410">  }</span>

  /**
   * Checks if the user given as argument is authorized to call the given
   * method.
   *
   * @param user the name of the user making the request
   * @param method the method called by the request
   *
   * @return {@code true} if the user is authorized to make the request,
   *     {@code false} otherwise.
   */
  protected boolean checkAuthorization(final String user, final Method method) {
    try {
<span class="fc" id="L424">      final DbHostAuth hostAuth = new DbHostAuth(user);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">      if (hostAuth.isAdminrole()) {</span>
<span class="fc" id="L426">        return true;</span>
      }
<span class="nc" id="L428">    } catch (final WaarpDatabaseException e) {</span>
      // ignore and continue
<span class="fc" id="L430">    }</span>

<span class="fc" id="L432">    ROLE requiredRole = NOACCESS;</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">    if (method.isAnnotationPresent(RequiredRole.class)) {</span>
<span class="fc" id="L434">      requiredRole = method.getAnnotation(RequiredRole.class).value();</span>
    } else {
<span class="nc" id="L436">      logger.warn(String.format(&quot;[RESTv2] The method %s of handler %s is &quot; +</span>
                                &quot;missing a '%s' annotation for the minimum required role, &quot; +
                                &quot;the default value '%s' was given instead.&quot;,
<span class="nc" id="L439">                                method.getName(),</span>
<span class="nc" id="L440">                                method.getDeclaringClass().getSimpleName(),</span>
<span class="nc" id="L441">                                RequiredRole.class.getSimpleName(), NOACCESS));</span>
    }
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (requiredRole == NOACCESS) {</span>
<span class="fc" id="L444">      return true;</span>
    }

<span class="fc" id="L447">    final List&lt;ROLE&gt; roles = HostConfigConverter.getRoles(user);</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">    if (roles != null) {</span>
<span class="fc" id="L449">      final RoleDefault roleDefault = new RoleDefault();</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">      for (final ROLE roleType : roles) {</span>
<span class="fc" id="L451">        roleDefault.addRole(roleType);</span>
<span class="fc" id="L452">      }</span>
<span class="fc" id="L453">      return roleDefault.isContaining(requiredRole);</span>
    }
<span class="nc" id="L455">    return false;</span>
  }

  /**
   * Hook called after a request handler is called.
   *
   * @param httpRequest the request currently being processed
   * @param httpResponseStatus the status of the http response
   *     generated by the request handler
   * @param handlerInfo information about the handler to which the
   *     request was sent
   */
  @Override
  public void postCall(final HttpRequest httpRequest,
                       final HttpResponseStatus httpResponseStatus,
                       final HandlerInfo handlerInfo) {
    // ignore
<span class="fc" id="L472">  }</span>

  /**
   * Creates a HandlerHook which will check for authentication and signature
   * on incoming request depending on
   * the parameters.
   *
   * @param authenticated specifies if the HandlerHook will check
   *     authentication
   * @param hmac the key used for HMAC authentication
   * @param delay the delay for which a HMAC signed request is valid
   */
  public RestHandlerHook(final boolean authenticated, final HmacSha256 hmac,
<span class="fc" id="L485">                         final long delay) {</span>
<span class="fc" id="L486">    this.authenticated = authenticated;</span>
<span class="fc" id="L487">    this.hmac = hmac;</span>
<span class="fc" id="L488">    this.delay = delay;</span>
<span class="fc" id="L489">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>