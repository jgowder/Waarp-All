<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpRequestHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Waarp Gateway Kernel</a> &gt; <a href="index.source.html" class="el_package">org.waarp.gateway.kernel.http</a> &gt; <span class="el_source">HttpRequestHandler.java</span></div><h1>HttpRequestHandler.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.gateway.kernel.http;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.FullHttpRequest;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpRequest;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpUtil;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.codec.http.QueryStringDecoder;
import io.netty.handler.codec.http.cookie.Cookie;
import io.netty.handler.codec.http.cookie.ServerCookieDecoder;
import io.netty.handler.codec.http.cookie.ServerCookieEncoder;
import io.netty.handler.codec.http.multipart.Attribute;
import io.netty.handler.codec.http.multipart.FileUpload;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.NotEnoughDataDecoderException;
import io.netty.handler.codec.http.multipart.InterfaceHttpData;
import io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
import org.waarp.common.crypto.ssl.WaarpSslUtility;
import org.waarp.common.database.DbConstant;
import org.waarp.common.database.data.AbstractDbData.UpdatedInfo;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.gateway.kernel.AbstractHttpBusinessRequest;
import org.waarp.gateway.kernel.AbstractHttpField;
import org.waarp.gateway.kernel.AbstractHttpField.FieldPosition;
import org.waarp.gateway.kernel.AbstractHttpField.FieldRole;
import org.waarp.gateway.kernel.HttpBusinessFactory;
import org.waarp.gateway.kernel.HttpPage;
import org.waarp.gateway.kernel.HttpPage.PageRole;
import org.waarp.gateway.kernel.HttpPageHandler;
import org.waarp.gateway.kernel.database.WaarpActionLogger;
import org.waarp.gateway.kernel.exception.HttpIncorrectRequestException;
import org.waarp.gateway.kernel.session.DefaultHttpAuth;
import org.waarp.gateway.kernel.session.HttpSession;

import java.io.IOException;
import java.nio.channels.ClosedChannelException;
import java.security.SecureRandom;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 *
 */
public abstract class HttpRequestHandler
    extends SimpleChannelInboundHandler&lt;HttpObject&gt; {
  /**
   * Internal Logger
   */
<span class="nc" id="L88">  private static final WaarpLogger logger =</span>
<span class="nc" id="L89">      WaarpLoggerFactory.getLogger(HttpRequestHandler.class);</span>

<span class="nc" id="L91">  private static final SecureRandom random = new SecureRandom();</span>

  protected final String baseStaticPath;
  protected final String cookieSession;
  protected final HttpPageHandler httpPageHandler;

  /**
   * @param baseStaticPath
   * @param cookieSession
   * @param httpPageHandler
   */
  protected HttpRequestHandler(String baseStaticPath, String cookieSession,
<span class="nc" id="L103">                               HttpPageHandler httpPageHandler) {</span>
<span class="nc" id="L104">    this.baseStaticPath = baseStaticPath;</span>
<span class="nc" id="L105">    this.cookieSession = cookieSession;</span>
<span class="nc" id="L106">    this.httpPageHandler = httpPageHandler;</span>
<span class="nc" id="L107">  }</span>

  protected HttpSession session;
  protected HttpPostRequestDecoder decoder;
  protected HttpPage httpPage;
  protected AbstractHttpBusinessRequest businessRequest;

<span class="nc" id="L114">  protected HttpResponseStatus status = HttpResponseStatus.OK;</span>
  protected String errorMesg;

  protected HttpRequest request;
  protected HttpMethod method;

  protected volatile boolean willClose;

  /**
   * Clean method
   * &lt;p&gt;
   * Override if needed
   */
  protected void clean() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">    if (businessRequest != null) {</span>
<span class="nc" id="L129">      businessRequest.cleanRequest();</span>
<span class="nc" id="L130">      businessRequest = null;</span>
    }
<span class="nc bnc" id="L132" title="All 2 branches missed.">    if (decoder != null) {</span>
<span class="nc" id="L133">      decoder.cleanFiles();</span>
<span class="nc" id="L134">      decoder = null;</span>
    }
<span class="nc bnc" id="L136" title="All 2 branches missed.">    if (session != null) {</span>
<span class="nc" id="L137">      session.setFilename(null);</span>
<span class="nc" id="L138">      session.setLogid(DbConstant.ILLEGALVALUE);</span>
    }
<span class="nc" id="L140">  }</span>

  /**
   * Called at the beginning of every new request
   * &lt;p&gt;
   * Override if needed
   */
  protected void initialize() {
    // clean previous FileUpload if Any
<span class="nc" id="L149">    clean();</span>
<span class="nc" id="L150">    willClose = false;</span>
<span class="nc" id="L151">    status = HttpResponseStatus.OK;</span>
<span class="nc" id="L152">    httpPage = null;</span>
<span class="nc" id="L153">    businessRequest = null;</span>
<span class="nc" id="L154">  }</span>

  /**
   * set values from URI
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getUriArgs() throws HttpIncorrectRequestException {
<span class="nc" id="L162">    QueryStringDecoder decoderQuery = new QueryStringDecoder(request.uri());</span>
<span class="nc" id="L163">    Map&lt;String, List&lt;String&gt;&gt; uriAttributes = decoderQuery.parameters();</span>
<span class="nc" id="L164">    Set&lt;String&gt; attributes = uriAttributes.keySet();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">    for (final String name : attributes) {</span>
<span class="nc" id="L166">      List&lt;String&gt; values = uriAttributes.get(name);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">      if (values != null) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="nc" id="L170">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.URL);
<span class="nc bnc" id="L172" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
<span class="nc" id="L174">          values.clear();</span>
<span class="nc" id="L175">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
<span class="nc" id="L178">        values.clear();</span>
      }
<span class="nc" id="L180">    }</span>
<span class="nc" id="L181">  }</span>

  /**
   * set values from Header
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getHeaderArgs() throws HttpIncorrectRequestException {
<span class="nc" id="L189">    Set&lt;String&gt; headerNames = request.headers().names();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">    for (final String name : headerNames) {</span>
<span class="nc" id="L191">      List&lt;String&gt; values = request.headers().getAll((CharSequence) name);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (values != null) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (values.size() == 1) {</span>
          // only one element is allowed
<span class="nc" id="L195">          httpPage.setValue(businessRequest, name, values.get(0),</span>
                            FieldPosition.HEADER);
<span class="nc bnc" id="L197" title="All 2 branches missed.">        } else if (values.size() &gt; 1) {</span>
          // more than one element is not allowed
<span class="nc" id="L199">          values.clear();</span>
<span class="nc" id="L200">          throw new HttpIncorrectRequestException(</span>
              &quot;Too many values for &quot; + name);
        }
<span class="nc" id="L203">        values.clear();</span>
      }
<span class="nc" id="L205">    }</span>
<span class="nc" id="L206">  }</span>

  /**
   * set values from Cookies
   *
   * @throws HttpIncorrectRequestException
   */
  protected void getCookieArgs() throws HttpIncorrectRequestException {
    Set&lt;Cookie&gt; cookies;
<span class="nc" id="L215">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L217">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L219">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="nc bnc" id="L221" title="All 2 branches missed.">    if (!cookies.isEmpty()) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L224">          httpPage.setValue(businessRequest, cookie.name(), cookie.value(),</span>
                            FieldPosition.COOKIE);
        }
<span class="nc" id="L227">      }</span>
    }
<span class="nc" id="L229">    cookies.clear();</span>
<span class="nc" id="L230">  }</span>

  /**
   * To be used for instance to check correctness of connection
   *
   * @param ctx
   */
  protected abstract void checkConnection(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Called when an error is raised. Note that clean() will be called just
   * after.
   *
   * @param ctx
   */
  protected abstract void error(ChannelHandlerContext ctx);

  @Override
  protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg)
      throws Exception {
    try {
<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (msg instanceof HttpRequest) {</span>
<span class="nc" id="L253">        initialize();</span>
<span class="nc" id="L254">        request = (HttpRequest) msg;</span>
<span class="nc" id="L255">        method = request.method();</span>
<span class="nc" id="L256">        final QueryStringDecoder queryStringDecoder =</span>
<span class="nc" id="L257">            new QueryStringDecoder(request.uri());</span>
<span class="nc" id="L258">        final String uriRequest = queryStringDecoder.path();</span>
        HttpPage httpPageTemp;
        try {
<span class="nc" id="L261">          httpPageTemp =</span>
<span class="nc" id="L262">              httpPageHandler.getHttpPage(uriRequest, method.name(), session);</span>
<span class="nc" id="L263">        } catch (final HttpIncorrectRequestException e1) {</span>
          // real error =&gt; 400
<span class="nc" id="L265">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L266">          errorMesg = e1.getMessage();</span>
<span class="nc" id="L267">          writeErrorPage(ctx);</span>
<span class="nc" id="L268">          return;</span>
          // end of task
<span class="nc" id="L270">        }</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (httpPageTemp == null) {</span>
          // if Get =&gt; standard Get
<span class="nc bnc" id="L273" title="All 2 branches missed.">          if (method == HttpMethod.GET) {</span>
<span class="nc" id="L274">            logger.debug(&quot;simple get: &quot; + request.uri());</span>
            // send content (image for instance)
<span class="nc" id="L276">            HttpWriteCacheEnable</span>
<span class="nc" id="L277">                .writeFile(request, ctx, baseStaticPath + uriRequest,</span>
                           cookieSession);
            // end of task
          } else {
            // real error =&gt; 404
<span class="nc" id="L282">            status = HttpResponseStatus.NOT_FOUND;</span>
<span class="nc" id="L283">            writeErrorPage(ctx);</span>
          }
<span class="nc" id="L285">          return;</span>
        }
<span class="nc" id="L287">        httpPage = httpPageTemp;</span>
<span class="nc" id="L288">        session.setCurrentCommand(httpPage.getPagerole());</span>
<span class="nc" id="L289">        WaarpActionLogger.logCreate(DbConstant.admin.getSession(),</span>
                                    &quot;Request received: &quot; +
<span class="nc" id="L291">                                    httpPage.getPagename(), session);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (httpPageTemp.getPagerole() == PageRole.ERROR) {</span>
<span class="nc" id="L293">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L294">          error(ctx);</span>
<span class="nc" id="L295">          clean();</span>
          // order is important: first clean, then create new businessRequest
<span class="nc" id="L297">          businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="nc" id="L298">          willClose = true;</span>
<span class="nc" id="L299">          writeSimplePage(ctx);</span>
<span class="nc" id="L300">          WaarpActionLogger</span>
<span class="nc" id="L301">              .logErrorAction(DbConstant.admin.getSession(), session,</span>
<span class="nc" id="L302">                              &quot;Error: &quot; + httpPage.getPagename(), status);</span>
<span class="nc" id="L303">          return;</span>
          // end of task
        }
<span class="nc" id="L306">        businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="nc" id="L307">        getUriArgs();</span>
<span class="nc" id="L308">        getHeaderArgs();</span>
<span class="nc" id="L309">        getCookieArgs();</span>
<span class="nc" id="L310">        checkConnection(ctx);</span>
<span class="nc bnc" id="L311" title="All 5 branches missed.">        switch (httpPage.getPagerole()) {</span>
          case DELETE:
            // no body element
<span class="nc" id="L314">            delete(ctx);</span>
<span class="nc" id="L315">            return;</span>
          case GETDOWNLOAD:
            // no body element
<span class="nc" id="L318">            getFile(ctx);</span>
<span class="nc" id="L319">            return;</span>
          case HTML:
          case MENU:
            // no body element
<span class="nc" id="L323">            beforeSimplePage(ctx);</span>
<span class="nc" id="L324">            writeSimplePage(ctx);</span>
<span class="nc" id="L325">            return;</span>
          case POST:
          case POSTUPLOAD:
          case PUT:
<span class="nc" id="L329">            post(ctx);</span>
<span class="nc" id="L330">            return;</span>
          default:
            // real error =&gt; 400
<span class="nc" id="L333">            status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L334">            writeErrorPage(ctx);</span>
        }
<span class="nc" id="L336">      } else {</span>
        // New chunk is received: only for Put, Post or PostMulti!
<span class="nc" id="L338">        postChunk(ctx, (HttpContent) msg);</span>
      }
<span class="nc" id="L340">    } catch (final HttpIncorrectRequestException e1) {</span>
      // real error =&gt; 400
<span class="nc bnc" id="L342" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L343">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="nc" id="L345">      errorMesg = e1.getMessage();</span>
<span class="nc" id="L346">      logger.warn(&quot;Error&quot;, e1);</span>
<span class="nc" id="L347">      writeErrorPage(ctx);</span>
<span class="nc" id="L348">    }</span>
<span class="nc" id="L349">  }</span>

  /**
   * Utility to prepare error
   *
   * @param ctx
   * @param message
   *
   * @throws HttpIncorrectRequestException
   */
  protected void prepareError(ChannelHandlerContext ctx, String message)
      throws HttpIncorrectRequestException {
<span class="nc" id="L361">    logger.debug(&quot;Debug &quot; + message);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L364">      return;</span>
    }
<span class="nc" id="L366">    errorMesg = status.reasonPhrase() + &quot; / &quot; + message;</span>
<span class="nc" id="L367">    throw new HttpIncorrectRequestException(errorMesg);</span>
  }

  /**
   * Instantiate the page and the businessRequest handler
   *
   * @param ctx
   *
   * @return True if initialized
   */
  protected boolean setErrorPage(ChannelHandlerContext ctx) {
<span class="nc" id="L378">    httpPage = httpPageHandler.getHttpPage(status.code());</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">    if (httpPage == null) {</span>
<span class="nc" id="L380">      return false;</span>
    }
<span class="nc" id="L382">    businessRequest = httpPage.newRequest(ctx.channel().remoteAddress());</span>
<span class="nc" id="L383">    return true;</span>
  }

  /**
   * Write an error page
   *
   * @param ctx
   */
  protected void writeErrorPage(ChannelHandlerContext ctx) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    WaarpActionLogger.logErrorAction(DbConstant.admin.getSession(), session,</span>
                                     &quot;Error: &quot; + (httpPage == null? &quot;no page&quot; :
<span class="nc" id="L394">                                         httpPage.getPagename()), status);</span>
<span class="nc" id="L395">    error(ctx);</span>
<span class="nc" id="L396">    clean();</span>
<span class="nc" id="L397">    willClose = true;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if (!setErrorPage(ctx)) {</span>
      // really really bad !
<span class="nc" id="L400">      forceClosing(ctx);</span>
<span class="nc" id="L401">      return;</span>
    }
    try {
<span class="nc" id="L404">      writeSimplePage(ctx);</span>
<span class="nc" id="L405">    } catch (final HttpIncorrectRequestException e) {</span>
      // force channel closing
<span class="nc" id="L407">      forceClosing(ctx);</span>
<span class="nc" id="L408">    }</span>
<span class="nc" id="L409">  }</span>

  /**
   * To allow quick answer even if in very bad shape
   *
   * @param ctx
   */
  protected void forceClosing(ChannelHandlerContext ctx) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">    if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L418">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
    }
<span class="nc bnc" id="L420" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc" id="L421">      willClose = true;</span>
<span class="nc" id="L422">      final String answer =</span>
<span class="nc" id="L423">          &quot;&lt;html&gt;&lt;body&gt;Error &quot; + status.reasonPhrase() + &quot;&lt;/body&gt;&lt;/html&gt;&quot;;</span>
<span class="nc" id="L424">      final FullHttpResponse response = getResponse(</span>
<span class="nc" id="L425">          Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8)));</span>
<span class="nc" id="L426">      response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/html&quot;);</span>
<span class="nc" id="L427">      response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="nc" id="L428">      final ChannelFuture future = ctx.writeAndFlush(response);</span>
<span class="nc" id="L429">      logger.debug(&quot;Will close&quot;);</span>
<span class="nc" id="L430">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="nc" id="L432">    WaarpActionLogger.logErrorAction(DbConstant.admin.getSession(), session,</span>
<span class="nc" id="L433">                                     &quot;Error: &quot; + httpPage.getPagename(),</span>
                                     status);
<span class="nc" id="L435">  }</span>

  /**
   * Write a simple page from current httpPage and businessRequest
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void writeSimplePage(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc bnc" id="L446" title="All 2 branches missed.">    logger.debug(</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        &quot;HttpPage: &quot; + (httpPage != null? httpPage.getPagename() : &quot;no page&quot;) +</span>
        &quot; businessRequest: &quot; +
<span class="nc" id="L449">        (businessRequest != null? businessRequest.getClass().getName() :</span>
            &quot;no BR&quot;));
<span class="nc bnc" id="L451" title="All 4 branches missed.">    if (httpPage != null &amp;&amp; httpPage.getPagerole() == PageRole.ERROR) {</span>
      try {
<span class="nc" id="L453">        httpPage</span>
<span class="nc" id="L454">            .setValue(businessRequest, AbstractHttpField.ERRORINFO, errorMesg,</span>
                      FieldPosition.BODY);
<span class="nc" id="L456">      } catch (final HttpIncorrectRequestException e) {</span>
        // ignore
<span class="nc" id="L458">      }</span>
    }
<span class="nc bnc" id="L460" title="All 2 branches missed.">    final String answer =</span>
<span class="nc" id="L461">        httpPage != null? httpPage.getHtmlPage(businessRequest) : &quot;BAD REQUEST&quot;;</span>
    int length;
    // Convert the response content to a ByteBuf.
<span class="nc" id="L464">    final ByteBuf buf =</span>
<span class="nc" id="L465">        Unpooled.wrappedBuffer(answer.getBytes(WaarpStringUtils.UTF8));</span>
<span class="nc" id="L466">    final FullHttpResponse response = getResponse(buf);</span>
<span class="nc" id="L467">    response.headers().set(HttpHeaderNames.CONTENT_TYPE,</span>
<span class="nc" id="L468">                           businessRequest.getContentType());</span>
<span class="nc" id="L469">    response.headers().set(HttpHeaderNames.REFERER, request.uri());</span>
<span class="nc" id="L470">    length = buf.readableBytes();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">    if (!willClose) {</span>
      // There's no need to add 'Content-Length' header
      // if this is the last response.
<span class="nc" id="L474">      response.headers()</span>
<span class="nc" id="L475">              .set(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(length));</span>
    }
    // Write the response.
<span class="nc" id="L478">    final ChannelFuture future = ctx.writeAndFlush(response);</span>
    // Close the connection after the write operation is done if necessary.
<span class="nc bnc" id="L480" title="All 2 branches missed.">    if (willClose) {</span>
<span class="nc" id="L481">      logger.debug(&quot;Will close&quot;);</span>
<span class="nc" id="L482">      future.addListener(WaarpSslUtility.SSLCLOSE);</span>
    }
<span class="nc" id="L484">  }</span>

  /**
   * Could be used for other method (as validation of an authent cookie)
   *
   * @param cookie
   *
   * @return True if this cookie is valid
   */
  protected abstract boolean isCookieValid(Cookie cookie);

  /**
   * Method to add specific Cookies from business definition
   * &lt;p&gt;
   * Override if needed
   *
   * @param response
   * @param cookieNames
   */
  protected void addBusinessCookie(FullHttpResponse response,
                                   Set&lt;String&gt; cookieNames) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">    for (final AbstractHttpField field : httpPage</span>
<span class="nc" id="L506">        .getFieldsForRequest(businessRequest).values()) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">      if (field.isFieldcookieset() &amp;&amp;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">          !cookieNames.contains(field.getFieldname())) {</span>
<span class="nc" id="L509">        response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
                               ServerCookieEncoder.LAX
<span class="nc" id="L511">                                   .encode(field.getFieldname(),</span>
                                           field.fieldvalue));
      }
<span class="nc" id="L514">    }</span>
<span class="nc" id="L515">  }</span>

  /**
   * Method to set Cookies in response
   *
   * @param response
   */
  protected void setCookieEncoder(FullHttpResponse response) {
    Set&lt;Cookie&gt; cookies;
<span class="nc" id="L524">    final String value = request.headers().get(HttpHeaderNames.COOKIE);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L526">      cookies = Collections.emptySet();</span>
    } else {
<span class="nc" id="L528">      cookies = ServerCookieDecoder.LAX.decode(value);</span>
    }
<span class="nc" id="L530">    boolean foundCookieSession = false;</span>
<span class="nc" id="L531">    Set&lt;String&gt; cookiesName = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">    if (!cookies.isEmpty()) {</span>
      // Reset the cookies if necessary.
<span class="nc bnc" id="L534" title="All 2 branches missed.">      for (final Cookie cookie : cookies) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (isCookieValid(cookie)) {</span>
<span class="nc" id="L536">          response.headers().add(HttpHeaderNames.SET_COOKIE,</span>
<span class="nc" id="L537">                                 ServerCookieEncoder.LAX.encode(cookie));</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">          if (cookie.name().equals(cookieSession)) {</span>
<span class="nc" id="L539">            foundCookieSession = true;</span>
          }
<span class="nc" id="L541">          cookiesName.add(cookie.name());</span>
        }
<span class="nc" id="L543">      }</span>
    }
<span class="nc bnc" id="L545" title="All 2 branches missed.">    if (!foundCookieSession) {</span>
<span class="nc" id="L546">      response.headers().add(HttpHeaderNames.SET_COOKIE, ServerCookieEncoder.LAX</span>
<span class="nc" id="L547">          .encode(cookieSession, session.getCookieSession()));</span>
<span class="nc" id="L548">      cookiesName.add(cookieSession);</span>
    }
<span class="nc" id="L550">    addBusinessCookie(response, cookiesName);</span>
<span class="nc" id="L551">    cookiesName.clear();</span>
<span class="nc" id="L552">  }</span>

  /**
   * @param buf might be null
   *
   * @return the Http Response according to the status
   */
  protected FullHttpResponse getResponse(ByteBuf buf) {
    // Decide whether to close the connection or not.
    FullHttpResponse response;
<span class="nc bnc" id="L562" title="All 2 branches missed.">    if (request == null) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">      if (buf != null) {</span>
<span class="nc" id="L564">        response =</span>
            new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status, buf);
<span class="nc" id="L566">        response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="nc" id="L567">                               response.content().readableBytes());</span>
      } else {
<span class="nc" id="L569">        response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, status);</span>
      }
<span class="nc" id="L571">      setCookieEncoder(response);</span>
<span class="nc" id="L572">      willClose = true;</span>
<span class="nc" id="L573">      return response;</span>
    }
<span class="nc" id="L575">    boolean keepAlive = HttpUtil.isKeepAlive(request);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">    willClose |= status != HttpResponseStatus.OK || HttpHeaderValues.CLOSE</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        .contentEqualsIgnoreCase(</span>
<span class="nc" id="L578">            request.headers().get(HttpHeaderNames.CONNECTION)) ||</span>
<span class="nc bnc" id="L579" title="All 4 branches missed.">                 request.protocolVersion().equals(HttpVersion.HTTP_1_0) &amp;&amp;</span>
                 !keepAlive;
<span class="nc bnc" id="L581" title="All 2 branches missed.">    if (willClose) {</span>
<span class="nc" id="L582">      keepAlive = false;</span>
    }
    // Build the response object.
<span class="nc bnc" id="L585" title="All 2 branches missed.">    if (buf != null) {</span>
<span class="nc" id="L586">      response =</span>
<span class="nc" id="L587">          new DefaultFullHttpResponse(request.protocolVersion(), status, buf);</span>
<span class="nc" id="L588">      response.headers().add(HttpHeaderNames.CONTENT_LENGTH,</span>
<span class="nc" id="L589">                             response.content().readableBytes());</span>
    } else {
<span class="nc" id="L591">      response = new DefaultFullHttpResponse(request.protocolVersion(), status);</span>
    }
<span class="nc bnc" id="L593" title="All 2 branches missed.">    if (keepAlive) {</span>
<span class="nc" id="L594">      response.headers()</span>
<span class="nc" id="L595">              .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span>
    }
<span class="nc" id="L597">    setCookieEncoder(response);</span>
<span class="nc" id="L598">    return response;</span>
  }

  /**
   * @return the filename used for this request
   */
  protected abstract String getFilename();

  /**
   * Called before simple Page is called (Menu or HTML)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected abstract void beforeSimplePage(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the result and send back the result
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void finalData(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="nc" id="L626">      businessValidRequestAfterAllDataReceived(ctx);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if (!httpPage.isRequestValid(businessRequest)) {</span>
<span class="nc" id="L628">        throw new HttpIncorrectRequestException(&quot;Request unvalid&quot;);</span>
      }
<span class="nc bnc" id="L630" title="All 6 branches missed.">      switch (httpPage.getPagerole()) {</span>
        case DELETE:
<span class="nc" id="L632">          session.setFilename(getFilename());</span>
<span class="nc" id="L633">          finalDelete(ctx);</span>
<span class="nc" id="L634">          WaarpActionLogger</span>
<span class="nc" id="L635">              .logAction(DbConstant.admin.getSession(), session, &quot;Delete OK&quot;,</span>
                         status, UpdatedInfo.DONE);
<span class="nc" id="L637">          break;</span>
        case GETDOWNLOAD:
<span class="nc" id="L639">          finalGet(ctx);</span>
<span class="nc" id="L640">          WaarpActionLogger</span>
<span class="nc" id="L641">              .logAction(DbConstant.admin.getSession(), session, &quot;Download OK&quot;,</span>
                         status, UpdatedInfo.DONE);
<span class="nc" id="L643">          break;</span>
        case POST:
<span class="nc" id="L645">          finalPost(ctx);</span>
<span class="nc" id="L646">          WaarpActionLogger</span>
<span class="nc" id="L647">              .logAction(DbConstant.admin.getSession(), session, &quot;Post OK&quot;,</span>
                         status, UpdatedInfo.DONE);
<span class="nc" id="L649">          break;</span>
        case POSTUPLOAD:
<span class="nc" id="L651">          finalPostUpload(ctx);</span>
<span class="nc" id="L652">          WaarpActionLogger.logAction(DbConstant.admin.getSession(), session,</span>
                                      &quot;PostUpload OK&quot;, status,
                                      UpdatedInfo.DONE);
<span class="nc" id="L655">          break;</span>
        case PUT:
<span class="nc" id="L657">          finalPut(ctx);</span>
<span class="nc" id="L658">          WaarpActionLogger</span>
<span class="nc" id="L659">              .logAction(DbConstant.admin.getSession(), session, &quot;Put OK&quot;,</span>
                         status, UpdatedInfo.DONE);
<span class="nc" id="L661">          break;</span>
        default:
          // real error =&gt; 400
<span class="nc" id="L664">          status = HttpResponseStatus.BAD_REQUEST;</span>
<span class="nc" id="L665">          throw new HttpIncorrectRequestException(&quot;Unknown request&quot;);</span>
      }
<span class="nc" id="L667">    } catch (final HttpIncorrectRequestException e) {</span>
      // real error =&gt; 400
<span class="nc bnc" id="L669" title="All 2 branches missed.">      if (status == HttpResponseStatus.OK) {</span>
<span class="nc" id="L670">        status = HttpResponseStatus.BAD_REQUEST;</span>
      }
<span class="nc" id="L672">      throw e;</span>
<span class="nc" id="L673">    }</span>
<span class="nc" id="L674">  }</span>

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalDelete(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and send back the result &lt;br&gt;
   * (this method must send back the answer using for instance a ChunkedInput
   * handler and should try to call
   * clean(), but taking into consideration that it will erase all data, so it
   * must be ensured that all data are
   * sent through the wire before calling it. Note however that when the
   * connection is closed or when a new
   * request on the same connection occurs, the clean method is automatically
   * called. The usage of a
   * HttpCleanChannelFutureListener on the last write might be useful.)
   *
   * @param ctx
   */
  protected abstract void finalGet(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the uploaded file and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPostUpload(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the post result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPost(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Method that will use the put result and prepare the result
   *
   * @param ctx
   */
  protected abstract void finalPut(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException;

  /**
   * Validate all data as they should be all received (done before the
   * isRequestValid)
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  public abstract void businessValidRequestAfterAllDataReceived(
      ChannelHandlerContext ctx) throws HttpIncorrectRequestException;

  /**
   * Method that get &quot;get&quot; data, answer has to be written in the business part
   * finalGet
   *
   * @param ctx
   */
  protected void getFile(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc" id="L744">    finalData(ctx);</span>
<span class="nc" id="L745">  }</span>

  /**
   * Method that get delete data
   *
   * @param ctx
   */
  protected void delete(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc" id="L754">    finalData(ctx);</span>
<span class="nc" id="L755">    writeSimplePage(ctx);</span>
<span class="nc" id="L756">    clean();</span>
<span class="nc" id="L757">  }</span>

  /**
   * Method that get post data
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void post(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="nc" id="L769">      decoder =</span>
          new HttpPostRequestDecoder(HttpBusinessFactory.factory, request);
<span class="nc" id="L771">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L772">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L773">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L774">    } catch (final Exception e1) {</span>
      // GETDOWNLOAD Method: should not try to create a HttpPostRequestDecoder
      // So OK but stop here
<span class="nc" id="L777">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L778">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L779">    }</span>

<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (request instanceof FullHttpRequest) {</span>
      // Not chunk version
<span class="nc" id="L783">      readHttpDataAllReceive(ctx);</span>
<span class="nc" id="L784">      finalData(ctx);</span>
<span class="nc" id="L785">      writeSimplePage(ctx);</span>
<span class="nc" id="L786">      clean();</span>
    }
<span class="nc" id="L788">  }</span>

  /**
   * Method that get a chunk of data
   *
   * @param ctx
   * @param chunk
   *
   * @throws HttpIncorrectRequestException
   */
  protected void postChunk(ChannelHandlerContext ctx, HttpContent chunk)
      throws HttpIncorrectRequestException {
    // New chunk is received: only for Post!
    try {
<span class="nc" id="L802">      decoder.offer(chunk);</span>
<span class="nc" id="L803">    } catch (final ErrorDataDecoderException e1) {</span>
<span class="nc" id="L804">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L805">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L806">    }</span>
    // example of reading chunk by chunk (minimize memory usage due to
    // Factory)
<span class="nc" id="L809">    readHttpDataChunkByChunk(ctx);</span>
    // example of reading only if at the end
<span class="nc bnc" id="L811" title="All 2 branches missed.">    if (chunk instanceof LastHttpContent) {</span>
<span class="nc" id="L812">      finalData(ctx);</span>
<span class="nc" id="L813">      writeSimplePage(ctx);</span>
<span class="nc" id="L814">      clean();</span>
    }
<span class="nc" id="L816">  }</span>

  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
      throws Exception {
<span class="nc bnc" id="L821" title="All 2 branches missed.">    if (ctx.channel().isActive()) {</span>
<span class="nc bnc" id="L822" title="All 4 branches missed.">      if (cause != null &amp;&amp; cause.getMessage() != null) {</span>
<span class="nc" id="L823">        logger.warn(&quot;Exception {}&quot;, cause.getMessage(), cause);</span>
      } else {
<span class="nc" id="L825">        logger.warn(&quot;Exception Received&quot;, cause);</span>
      }
<span class="nc bnc" id="L827" title="All 2 branches missed.">      if (cause instanceof ClosedChannelException) {</span>
<span class="nc" id="L828">        return;</span>
      }
<span class="nc" id="L830">      status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L831">      writeErrorPage(ctx);</span>
    }
<span class="nc" id="L833">  }</span>

  @Override
  public void channelInactive(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L837">    super.channelInactive(ctx);</span>
<span class="nc" id="L838">    clean();</span>
<span class="nc" id="L839">  }</span>

  /**
   * Read all InterfaceHttpData from finished transfer
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpDataAllReceive(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    List&lt;InterfaceHttpData&gt; datas;
    try {
<span class="nc" id="L852">      datas = decoder.getBodyHttpDatas();</span>
<span class="nc" id="L853">    } catch (final NotEnoughDataDecoderException e1) {</span>
      // Should not be!
<span class="nc" id="L855">      logger.warn(&quot;decoder issue&quot;, e1);</span>
<span class="nc" id="L856">      status = HttpResponseStatus.NOT_ACCEPTABLE;</span>
<span class="nc" id="L857">      throw new HttpIncorrectRequestException(e1);</span>
<span class="nc" id="L858">    }</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">    for (final InterfaceHttpData data : datas) {</span>
<span class="nc" id="L860">      readHttpData(data, ctx);</span>
<span class="nc" id="L861">    }</span>
<span class="nc" id="L862">  }</span>

  /**
   * Read request by chunk and getting values from chunk to chunk
   *
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpDataChunkByChunk(ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
    try {
<span class="nc bnc" id="L874" title="All 2 branches missed.">      while (decoder.hasNext()) {</span>
<span class="nc" id="L875">        final InterfaceHttpData data = decoder.next();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (data != null) {</span>
          // new value
<span class="nc" id="L878">          readHttpData(data, ctx);</span>
        }
<span class="nc" id="L880">      }</span>
<span class="nc" id="L881">    } catch (final EndOfDataDecoderException e1) {</span>
      // end
<span class="nc" id="L883">    }</span>
<span class="nc" id="L884">  }</span>

  /**
   * Read one Data
   *
   * @param data
   * @param ctx
   *
   * @throws HttpIncorrectRequestException
   */
  protected void readHttpData(InterfaceHttpData data, ChannelHandlerContext ctx)
      throws HttpIncorrectRequestException {
<span class="nc bnc" id="L896" title="All 2 branches missed.">    if (data.getHttpDataType() == HttpDataType.Attribute) {</span>
<span class="nc" id="L897">      final Attribute attribute = (Attribute) data;</span>
<span class="nc" id="L898">      final String name = attribute.getName();</span>
      try {
<span class="nc" id="L900">        final String value = attribute.getValue();</span>
<span class="nc" id="L901">        httpPage.setValue(businessRequest, name, value, FieldPosition.BODY);</span>
<span class="nc" id="L902">      } catch (final IOException e) {</span>
        // Error while reading data from File, only print name and
        // error
<span class="nc" id="L905">        attribute.delete();</span>
<span class="nc" id="L906">        status = HttpResponseStatus.INTERNAL_SERVER_ERROR;</span>
<span class="nc" id="L907">        throw new HttpIncorrectRequestException(e);</span>
<span class="nc" id="L908">      }</span>
<span class="nc" id="L909">      attribute.delete();</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">    } else if (data.getHttpDataType() == HttpDataType.FileUpload) {</span>
<span class="nc" id="L911">      final FileUpload fileUpload = (FileUpload) data;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">      if (fileUpload.isCompleted()) {</span>
<span class="nc" id="L913">        final AbstractHttpField field =</span>
<span class="nc" id="L914">            httpPage.getField(businessRequest, fileUpload.getName());</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (field != null &amp;&amp;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            field.getFieldtype() == FieldRole.BUSINESS_INPUT_FILE) {</span>
<span class="nc" id="L917">          httpPage.setValue(businessRequest, field.getFieldname(), fileUpload);</span>
        } else {
<span class="nc" id="L919">          logger.warn(&quot;File received but no variable for it&quot;);</span>
<span class="nc" id="L920">          fileUpload.delete();</span>
        }
<span class="nc" id="L922">      } else {</span>
<span class="nc" id="L923">        logger.warn(&quot;File still pending but should not&quot;);</span>
<span class="nc" id="L924">        fileUpload.delete();</span>
      }
<span class="nc" id="L926">    } else {</span>
<span class="nc" id="L927">      logger.warn(&quot;Unknown element: &quot; + data);</span>
    }
<span class="nc" id="L929">  }</span>

  /**
   * Default Session Cookie generator
   *
   * @return the new session cookie value
   */
  protected String getNewCookieSession() {
<span class="nc" id="L937">    return &quot;Waarp&quot; + Long.toHexString(random.nextLong());</span>
  }

  /**
   * Default session creation
   *
   * @param ctx
   */
  protected void createNewSessionAtConnection(ChannelHandlerContext ctx) {
<span class="nc" id="L946">    session = new HttpSession();</span>
<span class="nc" id="L947">    session.setHttpAuth(new DefaultHttpAuth(session));</span>
<span class="nc" id="L948">    session.setCookieSession(getNewCookieSession());</span>
<span class="nc" id="L949">    session.setCurrentCommand(PageRole.HTML);</span>
<span class="nc" id="L950">  }</span>

  @Override
  public void channelActive(ChannelHandlerContext ctx) throws Exception {
<span class="nc" id="L954">    super.channelActive(ctx);</span>
<span class="nc" id="L955">    createNewSessionAtConnection(ctx);</span>
<span class="nc" id="L956">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>